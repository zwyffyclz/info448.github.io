[
["index.html", "Android Development: Lecture Notes About this Book", " Android Development: Lecture Notes Joel Ross December 05, 2017 About this Book This book compiles lecture notes and tutorials for the INFO 448 Mobile Development: Android course taught at the University of Washington Information School (most recently in Autumn 2017). The goal of these notes is to provide learning materials for students in the course or anyone else who wishes to learn the basics of developing Android applications. These notes cover the tools, programming languages, and architectures needed to develop applications for the Android platform. This course expects you to have “journeyman”-level skills in Java (apprenticeship done, not yet master). It uses a number of intermediate concepts (like generics and inheritance) without much fanfare or explanation (though see the appendix). It also assumes some familiarity with developing interactive applications (e.g., client-side web applications). These notes are primarily adapted from the official Android developer documentation, compiling and synthesizing those guidelines for pedagogical purposes (and the author’s own interpretation/biases). Please refer to that documentation for the latest information and official guidance. This book is currently in alpha status. Visit us on GitHub to contribute improvements. This book is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["introduction.html", "Lecture 1 Introduction 1.1 Android History 1.2 Building Apps 1.3 App Source Code 1.4 Logging &amp; ADB 1.5 Adding Interaction", " Lecture 1 Introduction This course focuses on Android Development. But what is Android? Android is an operating system. That is, it’s software that connects hardware to software and provides general services. But more than that, it’s a mobile specific operating system: an OS designed to work on mobile (read: handheld, wearable, carry-able) devices. Note that the term “Android” also is used to refer to the “platform” (e.g., devices that use the OS) as well as the ecosystem that surrounds it. This includes the device manufacturers who use the platform, and the applications that can be built and run on this platform. So “Android Development” technically means developing applications that run on the specific OS, it also gets generalized to refer to developing any kind of software that interacts with the platform. 1.1 Android History If you’re going to develop systems for Android, it’s good to have some familiarity with the platform and its history, if only to give you perspective on how and why the framework is designed the way it is: 2003: The platform was originally founded by a start-up “Android Inc.” which aimed to build a mobile OS operating system (similar to what Nokia’s Symbian was doing at the time) 2005: Android was acquired by Google, who was looking to get into mobile 2007: Google announces the Open Handset Alliance, a group of tech companies working together to develop “open standards” for mobile platforms. Members included phone manufacturers like HTC, Samsung, and Sony; mobile carriers like T-Mobile, Sprint, and NTT DoCoMo; hardware manufacturers like Broadcom and Nvidia; and others. The Open Handset Alliance now (2017) includes 86 companies. Note this is the same year the first iPhone came out! 2008: First Android device is released: the HTC Dream (a.k.a. T-Mobile G1) Specs: 528Mhz ARM chip; 256MB memory; 320x480 resolution capacitive touch; slide-out keyboard! Author’s opinion: a fun little device. 2010: First Nexus device is released: the Nexus One. These are Google-developed “flagship” devices, intended to show off the capabilities of the platform. Specs: 1Ghz Scorpion; 512MB memory; .37&quot; at 480x800 AMOLED capacitive touch. For comparison, the iPhone 8 Plus (2017) has: ~2.54Ghz hex-core A11 Bionic 64bit; 3GB RAM; 5.5&quot; at 1920x1080 display. (As of 2016, this program has been superseded by the Pixel range of devices). 2014: Android Wear, a version of Android for wearable devices (watches) is announced. 2016: Daydream, a virtual reality (VR) platform for Android is announced. In short, Google keeps pushing the platform wider so it includes more and more capabilities. Android is incredibly popular! (see e.g., here, here, and here) In any of these analyses there are some questions about what exactly is counted… but what we care about is that there are a lot of Android devices out there! And more than that: there are a lot of different devices! Android Versions Android has gone through a large number of “versions” since it’s release: Date Version Nickname API Level Sep 2008 1.0 Android 1 Apr 2009 1.5 Cupcake 3 Sep 2009 1.6 Donut 4 Oct 2009 2.0 Eclair 5 May 2010 2.2 Froyo 8 Dec 2010 2.3 Gingerbread 9 Feb 2011 3.0 Honeycomb 11 Oct 2011 4.0 Ice Cream Sandwich 14 July 2012 4.1 Jelly Bean 16 Oct 2013 4.4 KitKat 19 Nov 2014 5.0 Lollipop 21 Oct 2015 6.0 Marshmallow 23 Aug 2016 7.0 Nougat 24 Aug 2017 8.0 Oreo 26 Each different “version” is nicknamed after a dessert, in alphabetical order. But as developers, what we care about is the API Level, which indicates what different programming interfaces (classes and methods) are available to use. You can check out an interactive version of the history through Marshmallow at https://www.android.com/history/ For current usage breakdown, see https://developer.android.com/about/dashboards/ Additionally, Android is an “open source” project released through the “Android Open Source Project”, or ASOP. You can find the latest version of the operating system code at https://source.android.com/; it is very worthwhile to actually dig around in the source code sometimes! While new versions are released fairly often, this doesn’t mean that all or even many devices update to the latest version. Instead, users get updated phones historically by purchasing new devices (every 18m on average in US). Beyond that, updates—including security updates—have to come through the mobile carriers, meaning that most devices are never updated beyond the version that they are purchases with. This is a problem from a consumer perspective, particularly in terms of security! There are some efforts on Google’s part to to work around this limitation by moving more and more platform services out of the base operating system into a separate “App” called Google Play Services, as well as to divorce the OS from hardware requirements through the new Project Treble. But what this means for developers is that you can’t expect devices to be running the latest version of the operating system—the range of versions you need to support is much greater than even web development! Android applications must be written for heterogeneous devices. Legal Battles When discussing Android history, we would be remiss if we didn’t mention some of the legal battles surrounding Android. The biggest of these is Oracle v Google. In a nutshell, Oracle claims that the Java API is copyrighted (that the method signatures themselves and how they work are protected), so because Google uses that API in Android, Google is violating the copyright. In 2012 a California federal judge decided in Google favor (that one can’t copyright an API). This was then reversed by the Federal Circuit court in 2014. The verdict was appealed to the US Supreme Court in 2015, who refused to hear the case. It then went back to the the district court, which ruled in 2016 that Google’s use of the API was fair use. This ruling is again under appeal. See https://www.eff.org/cases/oracle-v-google for a summary, as well as https://arstechnica.com/series/series-oracle-v-google/ One interesting side effect of this battle: the Android Nougat and later uses the OpenJDK implementation of Java, instead of Google’s own in-violation-but-fair-use implementation see here. This change shouldn’t have any impact on you as a developer, but it’s worth keeping an eye out for potentially differences between Android and Java SE. There have been other legal challenges as well. While not directly about Android, the other major relevant court battle is Apple v Samsung. In this case, Apple claims that Samsung infringed on their intellectual property (their design patents). This has gone back and forth in terms of damages and what is considered infringing; as of this writing, the latest development is that the Supreme Court heard the case and sided with Samsung that infringing design patents shouldn’t lead to damages in terms of the entire device… it’s complicated (the author is not a lawyer). So overall: Android is a growing, evolving platform that is embedded in and affecting the social infrastructures around information technology in numerous ways. 1.2 Building Apps While Android applications can be developed using any programming environment, the official and best IDE for Android programming is Android Studio. This is a fork of JetBrain’s IntelliJ IDEA application—a Java IDE customized for Android development. You will need to download and install this IDE. Be sure to download the Android Studio bundle that includes the Android SDK (Standard Development Kit): the tools and libraries needed for Android development. In particular, the SDK comes with a number of useful command-line tools. These include: adb, the “Android Device Bridge”, which is a connection between your computer and the device (physical or virtual). This tool is used for console output! emulator, which runs the Android emulator: a virtual machine of an Android device. I recommend making sure that you have the SDK tools (the tools and platform-tools folder) available on your computer’s PATH so you can use them from the command-line. By default, the SDK is found at /Users/$USER/Library/Android/sdk on a Mac, and at C:\\Users\\$USERNAME\\AppData\\Local\\Android\\sdk on Windows. While these tools are all built into the IDE, they can be useful fallbacks for debugging or automation. Creating a Project To begin your first application, launch Android Studio (it may take a few minutes to open). From the Welcome screen, choose to “Start a new Android Studio Project”. This will open up a wizard to walk you through setting up the project. The “Company domain” should be a unique domain for you. For this course, you should include your UW NetID, e.g., joelross.uw.edu. Make a mental note of the project location so you can find your work later (e.g., if it’s in Desktop or Documents). On the next screen, you will need to pick the Minimum SDK level that you wish to support—that is, what is the oldest version of Android your application will be able to run on? For this course, unless otherwise specified, you should target API 15 Ice Cream Sandwich (4.0.3) as a minimum, allowing your application to run on pretty much any Android device. Note that the Minimum SDK is different than the Target SDK, which is the version of Android your application has been tested and designed against. The Target SDK indicates what set of API features you have considered/coded against, even if your app can fall back to older devices that don’t include those features. In many ways, the Target SDK is the “highest SDK I’ve worked with”. For most of this course we will target either API 21 (Lollipop) or API 23 (Marshmallow). On the next screen, select to start with an Empty Activity. Activities are the basic component of Android, each of which acts as a “screen” or “page” in your app. Activities are discussed in more detail in the next lecture. Stick with the default name (MainActivity) on the next screen, and hit “Finish”. Android Studio will take a few minutes to create your project and get everything set up. (Keep an eye on the bottom status bar to wait for everything to be finished). Once it is done, you have a complete (if simple) app! Running the App You can run your app by clicking the “Play” or “Run” button at the top of the IDE. But you’ll need an Android Device to run the app on… luckily, Android Studio comes with one: a virtual Android Emulator. This virtual machine models emulates a generic device with hardware you can specify, though it does have some limitations (e.g., no cellular service, no bluetooth, etc). While it has improved recently, the emulator historically does not work very well on Windows—it runs very, very slowly. The best way to speed the emulator up on any operating system is to make sure you have enabled HAXM (Intel’s Acceleration Manager which allows the emulator to utilize your GPU for rendering): this speeds things up considerably. You can usually install this through Android Studio: go to Tools &gt; Android &gt; SDK Manager to open up the SDK manager for downloading different versions of the Android SDK and other support software. Under “SDK Tools”, find “Intel x86 Emulator Accelerator (HAXM installer)”, check it, and hit “OK” to download. Note that you may need to do additional installation/configuration manually, see the guides (Mac, Windows). It is of course also possible to run your app on a physical device. These are the best for development (they are the fastest, easiest way to test code), though you’ll need a USB cable to be able to wire your device to your computer. Any device will work for this course; you don’t even need cellular service (just WiFi should work). You will need to turn on developer options in order to install development apps on your device! In order to create an emulator for your machine, go to Tools &gt; Android &gt; AVD Manager to open up the Android Virtual Device Manager. You can then choose “Create Virtual Device…” in order to launch the wizard to specify a new emulator. The Nexus 5 is a good choice of hardware profile for making sure you support “older” devices. The Nexus 5X or Pixel are also reasonable device profiles to test against. For now, you’ll want to use a system image for Lollipop API 21 or 22, and almost certainly on x86 (Intel) hardware. Make sure to select one that includes the Google APIs (so you have access to special Google classes). The advanced settings can be used to specify things like the camera and whether it accepts keyboard input (should be on by default). These settings can always be changed later. After the emulator boots, you can slide to unlock it… and your app should be loaded and started shortly thereafter! Note that if you are unfamiliar with Android devices, you should be sure to play around with the interface to get used to the interaction language, e.g., how to click/swipe/drag/long-click elements to use an app. 1.3 App Source Code Android Studio will create a bunch of project files by default—almost all of which are use for something. By default, it will show your project using the Android view, which organizes the files thematically. If you instead change to the Project view you can see what the actual file system looks like (though we’ll usually stick with the Android view). Android Studio. The “view” chooser is marked in red. In the Android view, files are organized as follows: app/ folder contains our application source code manifests/ contains the Android Manifest files, which is sort of like a “config” file for the app java/ contains the Java source code for your project. This is where the “logic” of the application goes res/ contains XML resource files used in the app. This is where we will put layout/appearance information Gradle Scripts contains scripts for the Gradle build tool, which is used to help compile the source code for installation on an device. Each of these components will be discussed in more detail below. XML Resources The res/ folder contains resource files. Resource files are used to define the user interface and other media assets (images, etc). for the application. Using separate files to define the application’s interface than those used for the application’s logic (the Java code) helps keep appearance and behavior separated. To compare to web programming: the resources contain the HTML/CSS content, while the Java code will contain what would normally by written in JavaScript. The vast majority of resource files are specified in XML (EXtensible Markup Language). XML has the exact same syntax as HTML, but you get to make up your own tags what whatever semantic values you want. Except we’ll be using the tags that Android made up and provided: so defining an Android application interface will be a lot like defining a web page, but with a new set of elements. Note that this course expects you to have some familiarity with HTML or XML, but if not you should be able to infer the syntactical structure from the examples. There are a large number of different kinds of resources, which are organized into different folders: res/drawable/: contains graphics (PNG, JPEG, etc) that will be “drawn” on the screen res/layout/: contains user interface XML layout files for the app’s content res/mipmap/: contains launcher icon files in different resolutions to support different devices res/values/: contains XML definitions for general constants There are other kinds of resources as well: see Available Resources or Lecture 2 for details. The most common resource you’ll work out are the layout resources, which are XML files that specify the visual layout of the component (like the HTML for a web page). If you open a layout file (e.g., activity_main.xml) in Android Studio, by default it will be shown in a “Design” view. This view lets you use a graphical system to lay out your application, similar to what you might do with a PowerPoint slide. Click the “Text” tab at the bottom to switch to the XML code view. Using the design view is frowned upon by many developers for historical resources, even as it becomes more powerful with successive versions of Android Studio. It’s often cleaner and more effective to write out the layouts and content in direct XML code. This is the same difference between writing your own HTML and using something like FrontPage or DreamWeaver or Wix to create a page. While those are legitimate applications, they are seen as less “professional”. This course will focus on the XML code for creating layouts, rather than utilizing the design tool. See here for more on its features. In the code view, you can see the XML: tags, attributes, values. Elements are nested inside one another. The provided XML code defines a layout (a &lt;android.support.constraint.ConstraintLayout&gt;) to organize things, and inside that is a &lt;TextView&gt; (a View representing some text). Note that most of the element attributes are namespaced, e.g. with an android: prefix, to avoid any potential conflicts (so we know we’re talking about Android’s text instead of something else). The android:text attribute of the &lt;TextView&gt; contains some text. You can change that and re-run the app to see it update! You will be able to specify what your app looks like by creating these XML layout files. For example, try replacing the &lt;TextView&gt; with a &lt;Button&gt;: &lt;Button android:id=&quot;@+id/my_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Click Me!&quot; /&gt; This XML defines a Button. The android:text attribute in this case specifies what text is shown on the button. Lecture 2 will describe in more detail the meaning of the other attributes, but you should be able to make a pretty good educated guess based on the names. (You can keep the app: scoped attributes if you want the button to stay in the center of the screen. Positioning will be discussed in Lecture 2). The Manifest Besides resource files, the other XML you may need to edit is the Manifest File AndroidManifest.xml, found in the manifest/ folder in the Android project view. The Manifest acts like a “configuration” file for the application, specifying application-level details such as the app’s name, icon, and permissions. For example, you can change the displayed name of the app by modifying the android:label attribute of the &lt;application&gt; element. By default, the label is a reference to another resource found in the res/values/strings.xml file, which contains definitions for string “constants”. Ideally all user-facing strings—including things like button text—should be defined as these constants. You will usually need to make at least one change to the Manifest for each app (e.g., tweaking the display name), so you should be familiar with it. Java Activities Besides using XML for specifying layouts, Android applications are written in Java, with the source code found in the java/ folder in the Android project view (in a nested folder structure based on your app’s package name). The Java code handles program control and logic, as well as data storage and manipulation. Writing Android code will feel a lot writing any other Java program: you create classes, define methods, instantiate objects, and call methods on those objects. But because you’re working within a framework, there is a set of code that already exists to call specific methods. As a developer, your task will be to fill in what these methods do in order to run your specific application. In web terms, this is closer to working with Angular (a framework) than jQuery (a library). So while you can and will implement “normal” Java classes and models in your code, you will most frequently be utilizing classes a specific set of classes required by the framework, giving Android applications a common structure. The most basic component in an Android program is an Activity, which represents a single screen in the app (see Lecture 3 for more details). The default provided MainActivity class is an example of this: the class extends Activity (actually it extends a subclass that supports Material Design components), allowing you to make your own customizations to the app’s behavior within the Android framework. In this class, we override the inherited onCreate() method that is called by the framework when the Activity starts—this method thus acts a little bit like the constructor for a class (though see Lecture 3 for a more nuanced discussion). We call the super method to make sure the framework does it stuff, and then setContentView() to specify what the content (appearance) of the Activity should be. This is passed in a value from something called R. R is a class that is generated at compile time and contains constants that are defined by the XML “resource” files! Those files are converted into Java variables, which we can access through the R class. Thus R.layout.activity_main refers to the activity_main layout found in the res/layouts/ folder. That is how Android knows what layout file to show on the screen. Dalvik On a desktop, Java code needs to be compiled into bytecode and runs on a virtual machine (the Java Virtual Machine (JVM)). Pre-Lollipop (5.0), Android code ran on a a virtual machine called Dalvik. Fun fact for people with a Computer Science background: Dalvik uses a register-based architecture rather than a stack-based one! A developer would write Java code, which would then be compiled into JVM bytecode, which would then be translated into DVM (Dalvik Virtual Machine) bytecode, that could be run on Android devices. This DVM bytecode is stored in .dex or .odex (“[Optimized] Dalvik Executable”) files, which is what was loaded onto the device. The process of converting from Java code to dex files is called “dexing” (so code that has been compiled and converted is called “dexed”). Dalvik does include JIT (“Just In Time”) compilation to native code that runs much faster than the code interpreted by the virtual machine, similar to the Java HotSpot. This native code is faster because no translation step is needed to talk to the actual hardware (via the OS). However, from Lollipop (5.0) on, Android instead uses Android Runtime (ART) to run code. ART’s biggest benefit is that it compiles the .dex bytecode into native code at installation using AOT (“Ahead of Time”) compilation. ART continues to accept .dex bytecode for backwards compatibility (so the same dexing process occurs), but the code that is actually installed and run on a device is native. This allows for applications to have faster execution, but at the cost of longer install times—and since you only install an application once, this is a pretty good trade. After being built, an Android application (the source, dexed bytecode, and any non-code resources such as images) are packaged into an .apk file. This are basically zip files (it uses the same gzip compression); if you rename the file to be .zip and you can uncompress it! The .apk file is then cryptographically signed to specify its authenticity, and either “side-loaded” onto the device or uploaded to an App Store for deployment. In short: the signed .apk file is basically the “executable” version of your program! Note that the Android application framework code (e.g., the base Activity class) is actually “pre-DEXed” (pre-compiled) on the device; when you write code, you’re compiling against empty code stubs (rather than needing to include those classes in your .apk)! That said, any other 3rd-party libraries you include will be copied into your built app, which can increase its file size both for installation and on the device. Usefully, since Android code is written for a virtual machine anyway, Android apps can be developed and built on any computer’s operating system (unlike some other mobile OS…). Gradle Scripts To summarize, after writing your Java and XML source code, in order to “build” and run your app you need to: Generate Java source files (e.g., R) from the XML resource files Compile the Java code into JVM bytecode “dex” the JVM bytecode into Dalvik bytecode Pack code and other assets into an .apk Cryptographically sign the .apk file to authorize it Transfer the .apk to your device, install, and run it! This is a lot of steps! Luckily the IDE handles it for us using an automated build tool called Gradle. Such tools let you, in effect, specify a single command that will do all of these steps at once. It is possible to customize the build script by modifying the Gradle script files, found in the Gradle Scripts folder in the Android project view. There are a lot of these by default: build.gradle: Top-level Gradle build; project-level (for building!) app/build.gradle: Gradle build specific to the app. Use this one to customize your project!, such as for adding dependencies or external libraries. For example, we can change the Target SDK in here. proguard-rules.pro: config for release version (minimization, obfuscation, etc). gradle.properties: Gradle-specific build settings, shared local.properties: settings local to this machine only settings.gradle: Gradle-specific build settings, shared Note that older Android applications were developed using Apache ANT. The build script was stored in the build.xml file, with build.properties and local.properties containing global and local build settings. While Gradle is more common these days, you should be aware of ANT for legacy purposes. It is also possible to use Gradle to build and install your app from the command-line if you want. You’ll need to make sure that you have a device (either physical or virtual) connected and running. Then from inside the project folder, you can build and install your app with # use the provided Gradle wrapper to run the `installDebug` script ./gradlew installDebug You can also launch the app from the command-line with the command # use adb to start adb shell am start -n package.name/.ActivityName You can run both these commands in sequence by connecting them with an &amp;&amp; (which short-circuits, so it will only launch if the build was successful). 1.4 Logging &amp; ADB In Android, we can’t use System.out.println() because we don’t actually have a console to print to! More specifically, the device (which is where the application is running) doesn’t have access to standard out (stdout), which is what Java means by System.out. It is possible to get access to stdout with adb using adb shell stop; adb shell setprop log.redirect-stdio true; adb shell start, but this is definitely not ideal. Instead, Android provides a Logging system that we can use to write out debugging information, and which is automatically accessible over the adb (Android Debugging Bridge). Logged messages can be filtered, categorized, sorted, etc. Logging can also be disabled in production builds for performance reasons (though it often isn’t, because people make mistakes). To perform this logging, we’ll use the android.util.Log1 class. This class includes a number of static methods, which all basically wrap around println to print to the device’s log file, which is then accessible through the adb. You will need to import the Log class! You can have Android Studio automatically add the import for a class by selecting that class name and hitting alt-return (you will be prompted if the class name is ambiguous). For better results, turn on “Add unambiguous imports on the fly” in the IDE Preferences. The device’s log file is stored persistently… sort of. It’s a 16k file, but it is shared across the entire system. Since every single app and piece of the system writes to it, it fills up fast. Hence filtering/searching becomes important, and you tend to watch the log (and debug your app) in real time! Log Methods Log provides methods that correspond to different level of priority (importance) of the messages being recorded. From low to high priority: Log.v(): VERBOSE output. This is the most detailed, for everyday messages. This is often the go-to, default level for logging. Ideally, Log.v() calls should only be compiled into an application during development, and removed for production versions. Log.d(): DEBUG output. This is intended for lower-level, less detailed messages (but still code-level, that is referring to specific programming messages). These messages can be compiled into the code but are removed at runtime in production builds through Gradle. Log.i(): INFO output. This is intended for “high-level” information, such at the user level (rather than specifics about code). Log.w(): WARN output. For warnings Log.e(): ERROR output. For errors Also if you look at the API… Log.wtf()! These different levels are used to help “filter out the noise”. So you can look just at errors, at errors and warnings, at error, warn, and info… all the way down to seeing everything with verbose. A huge amount of information is logged, so filtering really helps! Each Log method takes two Strings as parameters. The second is the message to print. The first is a “tag”—a String that’s prepended to the output which you can search and filter on. This tag is usually the App or Class name (e.g., “AndroidDemo”, “MainActivity”). A common practice is to declare a TAG constant you can use throughout the class: private static final String TAG = &quot;MainActivity&quot;; Logcat You can view the logs via adb (the debugging bridge) and a service called Logcat (from “log” and “conCATenation”, since it concatenates the logs). The easiest way to check Logcat is to use Android Studio. The Logcat browser panel is usually found at the bottom of the screen after you launch an application. It “tails” the log, showing the latest output as it appears. You can use the dropdown box to filter by priority, and the search box to search (e.g., by tag if you want). Android Studio also lets you filter to only show the current application, which is hugely awesome. Note that you may see a lot of Logs that you didn’t produce, including possibly Warnings (e.g., I see a lot of stuff about how OpenGL connects to the graphics card). This is normal! It is also possible to view Logcat through the command-line using adb, and includes complex filtering arguments. See Logcat Command-line Tool for more details. Something else to test: Cause the app to throw a runtime Exception! For example, you could make a new local array and try to access an item out of bounds. Or just throw new RuntimeException() (which is slightly less interesting). Can you see the Stack Trace in the logs? Logging is fantastic and one of the the best techniques we have for debugging, both in how Activities are being used or for any kind of bug (also RuntimeExceptions). It harkens back to printline debugging, which is still a legitimate debugging process. Note that Android Studio does have a built-in debugger if you’re comfortable with such systems. Toast Logs are great for debugging output, but remember that they are only visible for developers (you need to have your phone plugged into the IDE or SDK!) If you want to produce an error or warning message for the user, you need to use a different technique. One simple, quick way of giving some short visual feedback is to use what is called a Toast. This is a tiny little text box that pops up at the bottom of the screen for a moment to quickly display a message. It’s called a “Toast” because it pops up! Toasts are pretty simple to implement, as with the following example (from the official documentation): Toast toast = Toast.makeText(this, &quot;Hello toast!&quot;, Toast.LENGTH_SHORT); toast.show(); //as one line. Don&#39;t forget to show()! Toast.makeText(this, &quot;Hello toast!&quot;, Toast.LENGTH_SHORT).show(); Toasts are created by using the Toast.makeText() factory method (instead of calling a constructor). This method takes three parameters: the Context, or what is producing the Toast (see Chapter 3), the text to display, and an int constant representing the length the Toast should appear. Toasts are intended to be a way to provide information to the user (e.g., giving them quick feedback), but they can possibly be useful for testing too (though in the end, Logcat is going to be your best bet for debugging, especially when trying to solve crashes or see more complex output). 1.5 Adding Interaction Finally, we’ve created a button and discussed how to show visual information to the user… so let’s hook those together! As with JavaScript, in order to have our button do something, we need to register a callback function that can be executed when the button is clicked. In Java, these callback functions are supplied by “listener” objects who can respond to events (see Appendix B for a more detailed discussion). First, we need to get access to a variable that represents the Button we defined in the XML—similar to what you do with document.getElementById() in JavaScript. The method to access an element in Android is called findViewById(), and can be called directly on the Activity: Button button = (Button)findViewById(R.id.my_button); As an argument, we pass in a value defined in the auto-generated R class that represents the button’s id value—this is based on what we put in the &lt;Button&gt;’s android:id attribute. The exact format is discussed in Lecture 2. Note that the method returns a View (a superclass of Button), so we almost always typecast the result. See Lecture 2 for more on the View class. We can then register a listener (callback) by calling the setOnClickListener() method and passing in an anonymous class to act as the listener: button.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { // Perform action on click } }); Tab completion is your friend!! Try just typing the button., and then selecting the method name from the provided list. Similarly, you can begin to type new OnClick and then tab-complete the rest of the class definition. The Android Studio IDE makes this ubiquitous boilerplate code easy to produce. Finally, we can fill in the method to have it log out or toast something when clicked! http://developer.android.com/reference/android/util/Log.html↩ "],
["resources-and-layouts.html", "Lecture 2 Resources and Layouts 2.1 Resources 2.2 Views 2.3 Layouts 2.4 Inputs", " Lecture 2 Resources and Layouts This lecture discusses Resources, which are used to represent elements or data that are separate from the behavior (functional logic) of an app. In particular, this lecture focuses on how resources are used to define Layouts for user interfaces. This lecture focuses on the XML-based source code in an Android app; the Activities lecture begins to detail the source code written in Java. This lecture references code found at https://github.com/info448/lecture02-layouts. 2.1 Resources Resources can be found in the res/ folder, and represent elements or data that are “external” to the code. You can think of them as “media content”: often images, but also things like text clippings (or short String constants), usually defined in XML files. Resources represent components that are separate from the app’s behavior, so are kept separate from the Java code to support the Principle of Separation of Concerns By defining resources in XML, they can be developed (worked on) without coding tools (e.g., with systems like the graphical “design” tab in Android Studio). Theoretically you could have a Graphic Designer create these resources, which can then be integrated into the code without the designer needing to do a lick of Java. Similarly, keeping resources separate allows you to choose what resources to include dynamically. You can choose to show different images based on device screen resolution, or pick different Strings based on the language of the device (internationalization!)—the behavior of the app is the same, but the “content” is different! What should be a resource? In general: Layouts should always be defined as resources UI controls (buttons, etc) should mostly be defined as resources (they are part of layouts), though behavior will be defined programmatically in Java Any graphic images (drawables) should be defined as resources Any user-facing strings should be defined as resources Style and theming information should be defined as resources As introduced in Lecture 1, there are a number of different resource types used in Android, and which can be found in the res/ folder of a default Android project, including: res/drawable/: contains graphics (PNG, JPEG, etc) res/layout/: contains UI XML layout files res/mipmap/: contains launcher icon files in different resolutions res/values/: contains XML definitions for general constants, which can include: /strings.xml: short string constants (e.g., button labels) /colors.xml: color constants /styles.xml : constants for style and theme details /dimen.xml : dimensional constants (like default margins); not created by default in Android Studio 2.3+. The details about these different kinds of resources is a bit scattered throughout the documentation, but Resource Types2 is a good place to start, as is Providing Resources. R Resources are usually defined as XML (which is similar in syntax to HTML). When an application is compiled, the build tools (e.g., Gradle) will generate an additional Java class called R (for “resource”). This class contains what is basically a giant list of static “constants”—at least one for each XML element. For example, consider the strings.xml resource, which is used to define String constants. The provided strings.xml defines two constants of type &lt;string&gt;. The name attribute specifies the name that the variable will take, and the content of the element gives that variable’s value. Thus &lt;string name=&quot;app_name&quot;&gt;Layout Demo&lt;/string&gt; &lt;string name=&quot;greeting&quot;&gt;Hello Android!&lt;/string&gt; will in effect be compiled into constants similar to: public static final String app_name = &quot;My Application&quot;; public static final String greeting = &quot;Hello Android!&quot;; All of the resource constants are compiled into inner classes inside R, one for each resource type. So an R file containing the above strings would be structured like: public class R { public static class string { public static final String app_name = &quot;My Application&quot;; public static final String greeting = &quot;Hello Android!&quot;; } } This allows you to use dot notation to refer to each resource based on its type (e.g., R.string.greeting)—similar to the syntax used to refer to nested JSON objects! For most resources, the identifier is defined as an element attribute (name attribute for values like Strings; id for specific View elements in layouts). For more complex resources such as entire layouts or drawables, the identifier is the filename (without the file extension): for example R.layout.activity_main refers to the root element of the layout/activity_main.xml file. More generally, each resource can be referred to with [(package_name).]R.resource_type.identifier. Note that the file name string.xml is just a convention for readability; all children of a &lt;resource&gt; element are compiled into R dependent on their type, not their source code location. So it is possible to have lots of different resource files, depending on your needs. The robot_list.xml file is not a standard resource. You can find the generated R.java file inside app/build/generated/source/r/debug/... (Use the Project Files view in Android Studio). If you actually open the R.java file, you’ll see that the static constants are actually just int values that are pointers to element references (similar to passing a pointer* around in the C language); the content of the value is stored elsewhere (so it can be adjusted at runtime; see below). This does mean that in our Java code we usually work with int as the data type for XML resources such as Strings, because we’re actually working with pointers to those resources. For example, the setContentView() call in an Activity’s onCreate() takes in a resource int. You can think of each int constant as a “key” or “index” for that resource (in the list of all resources). Android does the hard work of taking that int, looking it up in an internal resource table, finding the associated XML file, and then getting the right element out of that XML. (By hard work, I mean in terms of implementation. Android is looking up these references directly in memory, so the look-up is fast). Because the R class is included in the Java, we can access these int constants directly in our code (as R.resource_type.identifier), as in the setContentView() method. However, if you want to actually get the String value, you can look that up by using the application’s Resources() object: Resources res = this.getResources(); //get access to application&#39;s resources String myString = res.getString(R.string.myString); //look up value of that resource The other comment method that utilizes resources will be findViewById(int), which is used to reference a View element (e.g., a button) specified in a layout resource in order to call methods on it in Java, as in the example from the previous lecture. The R class is regenerated all time (any time you change a resource, which is often); when Eclipse was the recommend Android IDE, you often needed to manually regenerate the class so that the IDE’s index would stay up to date! You can perform a similar task in Android Studio by using Build &gt; Clean Project and Build &gt; Rebuild Project. It is also possible to reference one resource from another within the XML using the @ symbol, following the schema @[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt;. For example, in the Manifest you can see that the application’s label is referred to via @string/app_name. You can also use the + symbol to create a new resource that we can refer to; this is a bit like declaring a variable inside an XML attribute. This is most commonly used with the android:id attribute (android:id=&quot;@+id/identifier&quot;) to create a variable referring to that View; see below for details. Alternative Resources One main advantage to separating resources from the Java code is that it allows them to be localized and changed depending on the device! Android allows the developer to specify folders for “alternative” resources, such as for different languages or device screen resolutions. At runtime, Android will check the configuration of the device, and try to find an alternative resource that matches that configuration. If it it can’t find a relevant alternative resource, it will fall back to the “default” resource. There are many different configurations that can be used to influence resources; see Providing Resources3. To highlight a few options, you can specify different resources based on: Language and region (e.g., via two-letter ISO codes) Screen size(small, normal, medium, large, xlarge) Screen orientation (port for portrait, land for landscape) Specific screen pixel density (dpi) (ldpi, mdpi, hdpi, xhdpi, xxhdpi, etc.). xxhdpi is pretty common for high-end devices. Note that dpi is “dots per inch”, so these values represent the number of pixels relative to the device size! Platform version (v1, v4, v7… for each API number) Configurations are indicated using the directory name, giving folders the form &lt;resource_name&gt;(-&lt;config_qualifier&gt;)+. For example, the values-fr/ would contain constant values for devices with a French language configuration. Importantly, the resource file itself should to be the same for both the qualifier and unqualified resource name (e.g., values/strings.xml and values-fr/strings.xml). This is because Android will load the file inside the qualified resource if it matches the device’s configuration in place of the “default” unqualified resource. The names need to be the same so one can replace the other! You can see this in action by using the New Resource wizard (File &gt; New &gt; Android resource file) to create a string resource (such as for the app_name) in another language. Change the device’s language settings (via the device’s Settings &gt; Language &amp; Input &gt; Language) to see the content automatically adjust! &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Mon Application&lt;/string&gt; &lt;/resources&gt; You can view the directory structure that supports this by switching to the Package project view in Android Studio. 2.2 Views The most common type of element you’ll define as a resource are Views4. View is the superclass for visual interface elements—a visual component on the screen is a View. Specific types of Views include: TextViews, ImageViews, Buttons, etc. View is a superclass for these components because it allows us to use polymorphism to treat all these visual elements as instances of the same type. We can lay them out, draw them, click on them, move them, etc. And all the behavior will be the same (though subclasses can also have “extra” features). Here’s the big trick: one subclass of View is ViewGroup5. A ViewGroup is a View can contain other “child” Views. But since ViewGroup is a View… it can contain more ViewGroups inside it! Thus we can nest Views within Views, following the Composite Pattern. This ends up working a lot like HTML (which can have DOM elements like &lt;div&gt; inside other DOM elements), allowing for complex user interfaces. Like the HTML DOM, Android Views are thus structured into a tree, what is known as the View hierarchy. Views are defined inside of Layouts—that is, inside a layout resource, which is an XML file describing Views. These resources are “inflated” (rendered) into UI objects that are part of the application. Technically, a Layout is simply a ViewGroup that provide “ordering” and “positioning” information for the Views inside of it. Layouts let the system “lay out” the Views intelligently and effectively. Individual views shouldn’t know their own position; this follows from good good object-oriented design and keeps the Views encapsulated. Android studio does come with a graphical Layout Editor (the “Design” tab) that can be used to create layouts. However, most developers stick with writing layouts in XML. This is mostly because early design tools were pathetic and unusable, so XML was all we had. Although Android Studio’s graphical editor can be effective, for this course you should create layouts “by hand” in XML. This is helpful for making sure you understand the pieces underlying development, and is a skill you should be comfortable with anyway (similar to how we encourage people to use git from the command-line). View Properties Before we get into how to group Views, let’s focus on the individual, basic View classes. As an example, consider the activity_main layout in the lecture code. This layout contains two individual View elements (inside a Layout): a TextView and a Button. All View have properties which define the state of the View. Properties are usually specified within the resource XML as element attributes. Some examples of these property attributes are described below. android:id specifies a unique identifier for the View. This identifier needs to be unique within the layout, though ideally is unique within the entire app for clarity. The @+ syntax is used to define a new View id resource—almost like you are declaring a variable inside the element attribute! You will need to use the @+ whenever you specify a new id, which will allow it to be referenced either from the Java code (as R.id.identifier) or by other XML resources (as @id/identifier). Identifiers must be legal Java variable names (because they are turned into a variable name in the R class), and by convention are named in lower_case format. Style tip: it is useful to prefix each View’s id with its type (e.g., btn, txt, edt). This helps with making the code self-documenting! You should give each interactive View a unique id, which will allow its state to automatically be saved when the Activity is destroyed. See here for details. android:layout_width and android:layout_height are used to specify the View’s size on the screen (see ViewGroup.LayoutParams for documentation). These values can be a specific value (e.g., 12dp), but more commonly are one of two special values: wrap_content, meaning the dimension should be as large as the content requires, plus padding. match_parent, meaning the dimension should be as large as the parent (container) element, minus padding. This value was renamed from fill_parent (which has now been deprecated). Android utilizes the following dimensions or units: dp is a “density-independent pixel”. On a 160-dpi (dots-per-inch) screen, 1dp equals 1px (pixel). But as dpi increases, the number of pixels per dp increases. These values should be used instead of px, as it allows dimensions to work independent of the hardware’s dpi (which is highly variable). px is an actual screen pixel. DO NOT USE THIS (use dp instead!) sp is a “scale-independent pixel”. This value is like dp, but is scaled by the system’s font preference (e.g., if the user has selected that the device should display in a larger font, 1sp will cover more dp). You should always use sp for text dimensions, in order to support user preferences and accessibility. pt is 1/72 of an inch of the physical screen. Similar units mm and in are available. Not recommended for use. android:padding, android:paddingLeft, android:margin, android:marginLeft, etc. are used to specify the margin and padding for Views. These work basically the same way they do in CSS: padding is the space between the content and the “edge” of the View, and margin is the space between Views. Note that unlike CSS, margins between elements do not collapse. android:textSize specifies the “font size” of textual Views (use sp units!), android:textColor specifies the color of text (best practice: reference a color resource!), etc. There are lots of other properties as well! You can see a listing of generic properties in the View6 documentation, look at the options in the “Design” tab of Android Studio, or browse the auto-complete options in the IDE. Each different View class (e.g., TextView, ImageView, etc.) will also have their own set of properties. Note that unlike CSS, styling properties specified in the layout XML resources are not inherited: you’re effectively specifying an inline style attribute for that element, and one that won’t affect child elements. In order to define shared style properties, you’ll need to use styles resources, which are discussed in a later lecture. Views and Java Displaying a View on a screen is called inflating that View. The process is called “inflating” based on the idea that it is “unpacking” or “expanding” a compact resource description into a complex Java Object. When a View is inflated, it is instantiate as an object: the inflation process changes the &lt;Button&gt; XML into a new Button() object in Java, with the property attributes passed as a parameter to that constructor. Thus you can think of each XML element as representing a particular Java Object that will be instantiated and referenced at runtime. This is almost exactly like how JSX components in React are individual objects! Remember that you can get a reference to these objects from the Java code using the findViewById() method. Once you have a reference to a View object in Java, it is possible to specify visual properties dynamically via Java methods (e.g., setText(), setPadding()). However, you should only use Java methods to specify View properties when they need to be dynamic (e.g., the text changes in response to a button click)—it is much cleaner and effective to specify as much visual detail in the XML resource files as possible. It’s also possible to dynamically replace one layout resource with another (see below). Views also have inspection methods such as isVisible() and hasFocus() if you need to check the View’s state. DO NOT instantiate or define Views or View appearances in an Activity’s onCreate() method, unless the properties (e.g., content) truly cannot be determined before runtime! DO specify layouts in the XML instead. Practice Add a new ImageView element that contains a picture. Be sure and specify its id and size (experiment with different options). You should specify the content of the image in the XML resource using the android:src attribute (use @ to reference a drawable), but you can specify the content dynamically in Java code if you want to change it later. ImageView imageView = (ImageView)findViewById(R.id.img_view); imageView.setImageResource(R.drawable.my_image); 2.3 Layouts As mentioned above, a Layout is a grouping of Views (specifically, a ViewGroup). A Layout acts as a container for other Views, to help structure the elements on the screen. Layouts are all subclasses of ViewGroup, so you can use its inheritance documentation to see a (mostly) complete list of options, though many of the listed classes are deprecated in favor of later, more generic/powerful options. LinearLayout Probably the simplest Layout to understand is the LinearLayout. This Layout orders the children Views in a line (“linearly”). All children are laid out in a single direction, but you can specify whether this is horizontal or vertical with the android:orientation property. See LinearLayout.LayoutParams for a list of all attribute options! Remember: since a Layout is a ViewGroup is a View, you can also utilize all the properties discussed above such as padding or background color; the support of the attributes is inherited! (But remember that the properties themselves are not inherited by child elements: you can’t set the textSize for a Layout and have it apply to all child Views). Another common property you might want to control in a LinearLayout is how much of any remaining space the elements should occupy (e.g., should they expand). This is done with the android:layout_weght property. After all element sizes are calculated (via their individual properties), the remaining space within the Layout is divided up proportionally to the layout_weight of each element (which defaults to 0 so default elements get no extra space). See the example in the guide for more details. Useful tip: Give elements 0dp width or height and 1 for weight to make everything in the Layout the same size! This is a similar behavior to the flex-grow property in the CSS Flexbox framework. You can also use the android:layout_gravity property to specify the “alignment” of elements within the Layout (e.g., where they “fall” to). Note that this property is declared for individual child Views to state where they are positioned; the android:gravity property specifies where the content of an element should be aligned. An important point Since Layouts are Views, you can of course nest LinearLayouts inside each other! So you can make “grids” by creating a vertical LinearLayout containing “rows” of horizontal LinearLayouts (which contain Views). As with HTML, there are lots of different options for achieving any particular interface layout. RelativeLayout A RelativeLayout is more flexible (and hence powerful), but can be more complex to use. In a RelativeLayout, children are positioned “relative” to the parent OR to each other. All children default to the top-left of the Layout, but you can give them properties from RelativeLayout.LayoutParams to specify where they should go instead. For example: android:layout_verticalCenter centers the View vertically within the parent. android:layout_toRightOf places the View to the right of the View with the given resource id (use an @ reference to refer to the View by its id): &lt;TextView android:id=&quot;@+id/first&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;FirstString&quot; /&gt; &lt;TextView android:id=&quot;@+id/second&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/first&quot; android:layout_alignParentLeft=&quot;true&quot; android:text=&quot;SecondString&quot; /&gt; You do not need to specify both toRightOf and toLeftOf; think about placing one element on the screen, then putting another element relative to what came before. This can be tricky. For this reason the author prefers to use LinearLayouts, since you can always produce a Relative positioning using enough LinearLayouts (and most layouts end up being linear in some fashion anyway!) ConstraintLayout ConstraintLayout is a Layout provided as part of an extra support library, and is what is used by Android Studio’s “Design” tool (and thus is the default Layout for new layout resources). ConstraintLayout works in a manner conceptually similar to RelativeLayout, in that you specify the location of Views in relationship to one another. However, ConstraintLayout offers a more powerful set of relationships in the form of constraints, which can be used to create highly responsive layouts. See the class documentation for more details and examples of constraints you can add. The main advantage of ConstraintLayout is that it supports development through Android Studio’s Design tool. However, since this course is focusing on implementing the resource XML files rather than using the specific tool (that may change in a year’s time), we will primarily be using other layouts. Other Layouts There are many other layouts as well, though we won’t go over them all in depth. They all work in similar ways; check the individual class’s documentation for details. FrameLayout is a sort of “placeholder” layout that holds a single child View (a second child will not be shown). You can think of this layout as a way of adding a simple container to use for padding, etc. It is also highly useful for situations where the framework requires you to specify a Layout resource instead of just an individual View. GridLayout arranges Views into a Grid. It is similar to LinearLayout, but places elements into a grid rather than into a line. Note that this is different than a GridView, which is a scrollable, adaptable list (similar to a ListView, which is discussed in the next lecture). TableLayout acts like an HTML table: you define TableRow layouts which can be filled with content. This View is not commonly used. CoordinatorLayout is a class provided as part of an extra support library, and provides support for Material Design widgets and animations. See Lecture 5 for more details. Combining and Inflating Layouts It is possible to combine multiple layout resources files. This is useful if you want to dynamically change what Views are included, or to refactor parts of a layout into different XML files to improve code organization. As one option, you can statically include XML layouts inside other layouts by using an &lt;include&gt; element: &lt;include layout=&quot;@layout/sub_layout&quot;&gt; But it is also possible to dynamically load views “manually” (e.g., in Java code) using the LayoutInflator. This is a class that has the job of “inflating” (rendering) Views. LayoutInflator is implicitly used in the setContentView() method, but can also be used independently with the following syntax: LayoutInflator inflator = getLayoutInflator(); //access the inflator (called on the Activity) View myLayout = inflator.inflate(R.layout.my_layout, parentViewGroup, true); //to attach Note that we never instantiate the LayoutInflator, we just access an object that is defined as part of the Activity. The inflate() method takes a couple of arguments: The first parameter is a reference to the resource to inflate (an int saved in the R class) The second parameter is a ViewGroup to act as the “parent” for this View—e.g., what layout should the View be inflated inside? This can be null if there is not yet a layout context; e.g., you wish to inflate the View but not show it on the screen yet. The third (optional) parameter is whether to actually attach the inflated View to that parent (if not, the parent just provides context and layout parameters to use). If not assigning to parent on inflation, you can later attach the View using methods in ViewGroup (e.g., addView(View)). Manually inflating a View works for dynamically loading resources, and we will often see UI implementation patterns that utilize Inflators. However, for dynamic View creation explicit inflation tends to be messy and hard to maintain (UI work should be specified entirely in the XML, without needing multiple references to parent and child Views) so isn’t as common in modern development. A much cleaner solution is to use a ViewStub7. A ViewStub is like an “on deck” Layout: it is written into the XML, but isn’t actually shown until you choose to reveal it via Java code. With a ViewStub, Android inflates the View at runtime, but then removes it from the parent (leaving a “stub” in its place). When you call inflate() (or setVisible(View.VISIBLE)) on that stub, it is reattached to the View tree and displayed: &lt;!-- XML --&gt; &lt;ViewStub android:id=&quot;@+id/stub&quot; android:inflatedId=&quot;@+id/subTree&quot; android:layout=&quot;@layout/mySubTree&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; //Java ViewStub stub = (ViewStub)findViewById(R.id.stub); View inflated = stub.inflate(); There are many other options for displaying or changing View content. Just remember to define as much of the View as possible in the XML, so that the Java code is kept simple and separate. 2.4 Inputs So far we you have used some basic Views such as TextView, ImageView, and Button. A Button is an example of an Input Control. These are simple (read single-purpose; not necessarily lacking complexity) widgets that allow for user input. There are many such widgets in addition to Button, mostly found in the android.widget package. Many correspond to HTML &lt;input&gt; elements, but Android provided additional widgets at well. You can change the lecture code’s MainActivity to show a View of R.id.input_control_layout to see an example of many widgets (as well as a demonstration of a more complex layout!). These widgets include: Button, a widget that affords clicking. Buttons can display text, images or both. EditText, a widget for user text entry. Note that you can use the android:inputType property to specify the type of the input similar to an HTML &lt;input&gt;. Checkbox, a widget for selecting an on-off state. RadioButton, a widget for selecting from a set of choices. Put RadioButton elements inside a RadioGroup element to make the buttons mutually exclusive. ToggleButton, another widget for selecting an on-off state. Switch, yet another widget for selecting an on-off state. This is just a ToggleButton with a slider UI. It was introduced in API 14 and is the “modern” way of supporting on-off input. Spinner, a widget for picking from an array of choices, similar to a drop-down menu. Note that you should define the choices as a resource (e.g., in strings.xml). Pickers: a compound control around some specific input (dates, times, etc). These are typically used in pop-up dialogs, which will be discussed in a future lecture. …and more! See the android.widget package for further options. All these input controls basically work the same way: you define (instantiate) them in the layout resource, then access them in Java in order to define interaction behavior. There are two ways of interacting with controls (and Views in general) from the Java code: Calling methods on the View to manipulate it. This represents “outside to inside” communication (with respect to the View). Listening for events produced by the View and responding to then. This represents “inside to outside” communication (with respect to the View). An example of the second, event-driven approach was introduced in Lecture 1. This involves registering a listener for the event (after acquiring a reference to the View with findViewById()) and then specifying a callback method (by instantiating the Listener interface) that will be “called back to” when the event occurs. It is also possible to specify the callback method in the XML resource itself by using e.g., the android:onClick attribute. This value of this attribute should be the name of the callback method: &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;handleButtonClick&quot; /&gt; The callback method is declared in the Java code as taking in a View parameter (which will be a reference to whatever View caused the event to occur) and returning void: public void handleButtonClick(View view) { } We will utilize a mix of both of these strategies (defining callbacks in both the Java and the XML) in this class. Author’s Opinion: It is arguable about which approach is “better”. Specifying the callback method in the Java code helps keep the appearance and behavior separate, and avoids introducing hidden dependencies for resources (the Activity must provide the required callback). However, as buttons are made to be pressed, it isn’t unreasonable to give a “name” in the XML resource as to what the button will do, especially as the corresponding Java method may just be a “launcher” method that calls something else. Specifying the callback in the XML resource may often seem faster and easier, and we will use whichever option best supports clarity in our code. Event callbacks are used to respond to all kind of input control widgets. CheckBoxes use an onClick callback, ToggleButtons use onCheckedChanged, etc. Other common events can be found in the View documentation, and are handled via listeners such as OnDragListener (for drags), OnHoverListener (for “hover” events), OnKeyListener (for when user types), or OnLayoutChangeListener (for when the layout changes). In addition to listening for events, it is possible to call methods directly on referenced Views to access their state. In addition to generic View methods such as isVisible() or hasFocus(), it is possible to inquire directly about the state of the input provided. For example, the isChecked() method returns whether or not a checkbox is ticked. This is also a good way of getting access to inputted content from the Java Code. For example, call getText() on an EditText control in order to fetch the contents of that View. For practice, try to log out the contents of the included EditText control when the Button is pressed! Between listening for events and querying for state, we can fully interact with input controls. Check the official documentation for more details on how to use specific individual widgets. https://developer.android.com/guide/topics/resources/available-resources.html↩ http://developer.android.com/guide/topics/resources/providing-resources.html↩ http://developer.android.com/reference/android/view/View.html↩ http://developer.android.com/reference/android/view/ViewGroup.html↩ http://developer.android.com/reference/android/view/View.html#lattrs↩ http://developer.android.com/training/improving-layouts/loading-ondemand.html↩ "],
["activities.html", "Lecture 3 Activities 3.1 Making Activities 3.2 The Activity Lifecycle 3.3 Context 3.4 Multiple Activities", " Lecture 3 Activities This lecture introduces Activities, which are the basic component used in Android applications. Activities provide a framework for the Java code that allows the user to interact with the layouts defined in the resources. This lecture references code found at https://github.com/info448/lecture03-activities. According to Google: An Activity is an application component that provides a screen with which users can interact in order to do something. You can think of an Activity as a single screen in your app, the equivalent of a “window” in a GUI system. Note that Activities don’t need to be full screens: they can also be floating modal windows, embedded inside other Activities (like half a screen), etc. But we’ll begin by thinking of them as full screens. We can have lots of Activities (screens) in an application, and they are loosely connected so we can easily move between them. In many ways, an Activity is a “bookkeeping mechanism”: a place to hold state and data, and tell to Android what to show on the display. It functions much like a Controller (in the Model-View-Controller sense) in that regard! Also to note from the documentation8: An activity is a single, focused thing that the user can do. which implies a design suggestion: Activities (screens) break up your App into “tasks”. Each Activity can represent what a user is doing at one time. If the user does something else, that should be a different Activity (and so probably a different screen). 3.1 Making Activities We specify an Activity for an app by subclassing (extending) the framework’s Activity class. We use inheritance to make a specialized type of Activity. By extending this class, we inherit all of the methods that are needed to control how the Android OS interacts with the Activity—behaviors like showing the screen, allowing Activities to change, and closing the Activity when it is no longer being used. If you look at the default Empty MainActivity, it actually subclasses AppCompatActivity, which is itself a already a specialized subclass of Activity that provides an ActionBar (the toolbar at the top of the screen with the name of you app). If you change the class to just extend Activity, that bar disappears. To make this change, you will need to import the Activity class! The keyboard shortcut to import a class in Android Studio is alt+return, or you can do it by hand (look up the package in the documentation)! I recommend that you change the IDE’s preferences to automatically import classes you use. There are a number of other built-in Activity subclasses that we could subclass instead. We’ll mention them as they become relevant. Many of the available classes have been deprecated in favor of Fragments, which are sort of like “sub-activities” that get nested in larger Activities. Fragments will be discussed in a later lecture. 3.2 The Activity Lifecycle An important point to note: does this Activity have a constructor that we call? No! We never write code that instantiates our Activity (that is: we never call new MainActivity()). There is no main() method in Android. Activities are created and managed by the Android operating system when the app is launched. Although we never call a constructor or main() method, Activities do have an very well-defined lifecycle—that is, a series of events that occur during usage (e.g., when the Activity is created, when it is stopped, etc). When each of these events occur, Android executes a callback method, just like how you specified the onClick() method to react to a button press. We can override these lifecycle callbacks in order to do special actions (read: run our own code) when these events occur. What is the lifecycle? Lifecycle state diagram, from Google9. See also an alternative, simplified diagram. There are 7 “events” that occur in the Activity Lifecycle, which are designated by the callback function that they execute: onCreate(): called when the Activity is first created/instantiated. This is where you initialize the UI (e.g., specify which layout to use), and otherwise do the kinds of work that might go in a constructor. onStart(): called just before the Activity becomes visible to the user. The difference between onStart() and onCreate() is that onStart() can be called more than once (e.g., if you leave the Activity, thereby hiding it, and come back later to make it visible again). onResume(): called just before user interaction starts, indicating that the Activity is ready to be used! This is a little bit like when that Activity “has focus”. While onStart() is called when the Activity becomes visible, onResume() is called when it is ready for interaction. It is possible for an Activity to be visible but not interactive, such as if there is a modal pop-up in front of it (partially hiding it). “onFocus” would have been a better name for this callback. onPause(): called when the system is about to start another Activity (so this one is about to lose focus). This is the “mirror” of onResume(). When paused, the activity stays visible! This callback is usually used to quickly and temporarily store unsaved changes (like saving an email draft in memory) or stop animations or video playback. The Activity may be being closed (and so is on its way out), but could just be losing focus. onStop(): called when the Activity is no longer visible. (e.g., another Activity took over, but also possibly because the current Activity has been destroyed). This callback is a mirror of onStart(). This callback is where you should persist any state information (e.g., saving the user’s document or game state). It is intended to do more complex “saving” work than onPause(). onRestart(): called when the Activity is coming back from a “stopped” state. This event allows you to run distinct code when the App is being “restarted”, rather than created for the first time. It is the least commonly used lifecycle callback. onDestroy(): called when the Activity is about to be closed. This can happen because the user ended the application, or (and this is important!) because the OS is trying to save memory and so kills the Activity on its own. The onDestroy() callback can do final app cleanup, but its is considered better practice to have such functionality in onPause() or onStop(), since they are more reliably executed. Activities are also destroyed (and recreated) when the device’s configuration changes—such as if you rotate the phone! Android apps run on devices with significant hardware constraints in terms of both memory and battery life. Thus the Android OS is very aggressive about not leaving apps running “in the background”. If it determines that an App is no longer necessary (such as because it has been hidden for a while), that app will be destroyed (shut down). Note that this destruction is unpredictable, as the “necessity” of an app being open is dependent on the OS’s resource allocation rules. Thus in practice, you should implement Activities as if they could be destroyed at any moment—you cannot rely on them to continue running if they are not visible. Note that apps may not need to use all of these callbacks! For example, if there is no difference between starting from scratch and resuming from stop, then you don’t need an onRestart() (since onStart() goes in the middle). Similarly, onStart() may not be needed if you just use onCreate() and onResume(). But these lifecycles allow for more granularity and the ability to avoid duplicate code. Overriding the Callback Methods When you create an new Empty MainActivity, the onCreate() callback has already been overridden for you, since that’s where the layout is specified. Notice that this callback takes a Bundle as a parameter. A Bundle is an object that stores key-value pairs, like a super-simple HashMap (or an Object in JavaScript, or dictionary in Python). Bundles can only hold basic types (numbers, Strings) and so are used for temporarily “bundling” small amounts of information. See before for details. Also note that we call super.onCreate(). Always call up the inheritance chain!. This allows the system-level behavior to continue without any problem. We can also add other callbacks: for example, onStart() (see the documentation for examples). Again, the IDE’s auto-complete feature lets you just type the name of the callback and get the whole method signature for free! We can quickly add in the event callbacks and Log.v() calls to confirm that they are executed. Then you can use the phone to see them occur: onCreate(), onStart() and onResume() are called when the app is instantiated. You can onPause() the Activity by dragging down the notification drawer from the top of the screen. You can onStop() the Activity by going back to the home screen (click the circle at the bottom). You can onDestroy() the Activity by changing the configuration and rotating the phone: click the “rotate” button on the emulator’s toolbar. Saving and Restoring Activity State As mentioned above, an Activity’s onCreate() method takes in a Bundle as a parameter. This Bundle is used to store information about the Activity’s current state, so that if the Activity is destroyed and recreated (e.g., when the phone is rotated), it can restored in the same state and the user won’t lose any data. For example, the Bundle can store state information for View elements, such as what text a user has typed into an EditText. That way when the user rotates their phone, they won’t lose the form input they’ve entered! If a View has been given an android:id attribute, then that id is used to automatically save the state of that View, with no further effort needed on your own. So you should always give input Views ids! You can also add your own custom information to the Bundle by overriding the Activity’s onSaveInstanceState() callback (use the one for AppCompactActivity that only takes one parameter). It takes as a parameter the Bundle that is being constructed with the saved data: you can add more information to this Bundle using an appropriate put() method (similar to the method used for Maps, but type-sensitive): //declare map key as a constant private static final String MSG_KEY = &quot;message_key&quot;; @Override protected void onSaveInstanceState(Bundle outState) { //put value &quot;Hello World&quot; in bundle with specified key outState.putString(MSG_KEY, &quot;Hello World&quot;); super.onSaveInstanceState(outState); } Note that you should always declare Bundle keys as CONSTANTS to help with readability/modifiability and to catch typos. Be sure to always call super.onSaveInstanceState() so that the super class can do its work to save the View hierarchy’s state! In fact, the reason that Views “automatically” save their state is because this method is calling their own onSaveInstanceState() callback. You can access this saved Bundle from the Activity’s onCreate() method when the Activity is recreated. Note that if the Activity is being created for the first time, then the Bundle will be null—checking for a null value is thus a good way to check if the Activity is being recreated or not: protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); if(savedInstanceState != null){ //Activity has been recreated String msg = savedInstanceState.getString(MSG_KEY); } else { //Activity created for first time } } Remember that a Bundle can only hold a small amount of primitive data: just a couple of numbers or Strings. For more complex data, you’ll need to use the alternative data storage solutions discussed in later lectures. 3.3 Context If you look at the documentation for the Activity class, you’ll notice that it is itself a subclass of something called a Context10. Context is an abstract class that acts as a reference for information about the current running environment: it represents environmental data (information like “What OS is running? Is there a keyboard plugged in?”). You can almost think of the Context as representing the “Application”, though it’s broader than that (Application is actually a subclass of Context!) The Context is used to do “application-level” actions: mostly working with resources (accessing and loading them), but also communicating between Activities. Effectively, it lets us refer to the state in which we are running: the “context” for our code (e.g., “where is this occurring?”). It’s a kind of reflection or meta-programming, in a way. For example, the getResources() method discussed in the last chapter is a method of the Context class, because we need to have some way of saying which set of resources to load! There are a couple of different kinds of Contexts we might wish to refer to: The Application context (e.g., an Application object) references the state of the entire application. It’s basically the Java object that is built out of the &lt;application&gt; element in the Manifest (and so contains that level of information). The Activity context (e.g., an Activity object) that references the state of that Activity. Again, this roughly corresponds to the Java objects created out of the &lt;activity&gt; elements from the Manifest. Each of these Context objects exist for the life of its respective component: that is, an Activity Context is available as long as the Activity exists (disappearing after onDestroy()), whereas Application Contexts survive as long as the application does. We’ll almost always use the Activity context, as it’s safer and less likely to cause memory leaks. Inside an Activity object (e.g., in a lifecycle callback function), you can refer to the current Activity using this. And since Activity is a Context, you can also use this to refer to the current Activity context. You’ll often see Context methods—like getResources()—called as undecorated methods (without an explicit this). You’ll need to refer to the Context whenever you want to do something beyond the Activity you’re working with: whether that’s accessing resources, showing a Toast (the first parameter to Toast.makeText() is a Context), or opening another Activity. 3.4 Multiple Activities The whole point of interfacing with the Activity Lifecycle is to handle the fact that Android applications can have multiple activities and interact with multiple other applications. In this section we’ll briefly discuss how to include multiple Activities within an app (in order to sense how the lifecycle may affect them). Note that working with multiple Activities will be discussed in more detail in a later lecture. We can easily create a New Activity through Android Studio by using File &gt; New &gt; Activity. We could also just add a new .java file with the Activity class in it, but using Android Studio will also provide the onCreate() method stub as well as a layout resource. For practice, make a new Empty Activity called SecondActivity. You should edit this Activity’s layout resource so that the &lt;TextView&gt; displays an appropriate message. Importantly, for every Activity you make, an entry gets added to the Manifest file AndroidManifest.xml. This file acts like the “table of contents” for our application, giving information about what your app looks (that is, what Activities it has) like so that the OS can open appropriate Activities as needed. (If you create an Activity’s .java file manually, you will need to add this entry manually as well). Activities are listed as &lt;activity&gt; elements nested in the &lt;application&gt; element. If you inspect the file you will be able to see an element representing the first MainActivity; that entry’s child elements will be discussed later. We can add android:label attributes to these &lt;activity&gt; elements in order to give the Activities nicer display names (e.g., in the ActionBar). Intents In Android, we don’t start new Activities by instantiating them (remember, we never instantiate Activities!). Instead, we send the operating system a message requesting that the Activity perform a particular action (i.e., start up and display on the screen). These messages are called Intents, and are used to communicate between app components like Activities. The Intent system allows Activities to communicate, even though they don’t have references to each other (we can’t just call a method on that other Activity). I don’t have a good justification for the name, other than Intents announce an “intention” for the OS to do something (like start an Activity) You can think of Intents as like letters you’d send through the mail: they are addressed to a particular target (e.g., another Activity—or more properly a Context), and contain a brief message about what to do. An Intent is an object we can instantiate: for example, we can create a new Intent in the event handler for when we click the button on MainActivity. The Intent class has a number of different constructors, but the one we’ll start with looks like: Intent intent = new Intent(MainActivity.this, SecondActivity.class); The first parameter is the Context by which this Intent will be delivered (e.g., this). Note that we use the fully qualified MainActivity.this to indicate that we’re not talking about the anonymous event handler class. The second parameter to this constructor is the Class we want to send the Intent to (the .class property fetches a reference to the class type; this is metaprogramming!). Effectively, it is the “address” on the envelop for the message we’re sending. After having instantiated the Intent, we can use that message to start an Activity by calling the startActivity() method (inherited from Activity), and passing it the Intent: startActivity(intent); This method will “send” the message to the operating system, which will deliver the Intent to the appropriate Activity, telling that Activity to start as soon as it receives the message. With this interaction in place, we can now click a button to start a second activity, (and see how that impacts our lifecycle callbacks). And we can use the back button to go backwards! There are actually a couple of different kinds of Intents (this is an Explicit Intent, because it is explicit about what Activity it’s sent to), and a lot more we can do with them. We’ll dive into Intents in more detail in a later lecture; for now we’re going to focus on mostly Single Activities. For example, if you look back at the Manifest, you can see that the MainActivity has an &lt;intent-filter&gt; child element that allows it to receive particular kinds of Intents—including ones for when an App is launched for the first time! Back &amp; Tasks We’ve shown that we can have lots of Activities (and of course many more can exist across multiple apps), and we are able to move between them by sending Intents and clicking the “Back” button. But how exactly is that “Back” button able to keep track of where to go to? The abstract data type normally associated with “back” or “undo” functionality is a stack, and that is exactly what Android uses. Every time you start a new Activity, Android instantiates that object and puts it on the top of a stack. Then when you hit the back button, that activity is “popped” off the stack and you’re taken to the Activity that is now at the top. An example of the Activity stack, from Google11. However, you might have different “sequences” of actions you’re working on: maybe you start writing an email, and then go to check your Twitter feed through a different set of Activities. Android breaks up these sequences into groups called Tasks. A Task is a collection of Activities arranged in a Stack, and there can be multiple Tasks in the background of your device. Tasks usually start from the Android “Home Screen”—then launching an application starts a new Task. Starting new Activities from that application will add them to the Stack of the Task. If you go back to the Home Screen, the Task you’re currently on is moved to the background, so the “back” button won’t let you navigate that Stack. It’s useful to think of Tasks as being like different tabs in a web browser, with the “back stack” being the history of web pages visited within that tab. As a demonstration, try switching to another (built-in) app and then back to the example app; how does the back button work in each situation? An important caveat: Tasks are distinct from one another, so you can have different copies of the same Activity on multiple stacks (e.g., the Camera activity could be part of both Facebook and Twitter app Tasks if you are on a selfie binge). It is possible to modify this behavior though, see Managing Tasks Up Navigation We can make this “back” navigation a little more intuitive for users by providing explicit up navigation, rather than just forcing users to go back through Activities in the order they viewed them (e.g., if you’re swiping through emails and want to go back to the home list). To do this, we just need to add a little bit of configuration to our Activities: In the Java code, we want to add more functionality to the ActionBar. Think: which lifecycle callback should this specification be put in? //specify that the ActionBar should have an &quot;home&quot; button getSupportActionBar().setHomeButtonEnabled(true); Then in the Manifest, add an android:parentActivityName attribute to the SecondActivity, with a value set to the full class name (including package and appname!) of your MainActivity. This will let you be able to use the “back” visual elements (e.g., of the ActionBar) to move back to the “parent” activity. See Up Navigation for details. &lt;activity android:name=&quot;.SecondActivity&quot; android:label=&quot;Second Activity&quot; android:parentActivityName=&quot;edu.uw.activitydemo.MainActivity&quot;&gt; &lt;meta-data android:name=&quot;android.support.PARENT_ACTIVITY&quot; android:value=&quot;edu.uw.activitydemo.MainActivity&quot; /&gt; &lt;/activity&gt; The &lt;meta-data&gt; element is to provide backwards compatibility for API level 15 (since the android:parentActivityName attribute is only defined for API level 16+). https://developer.android.com/reference/android/app/Activity.html↩ http://developer.android.com/images/activity_lifecycle.png↩ https://developer.android.com/reference/android/content/Context.html↩ http://developer.android.com/images/fundamentals/diagram_backstack.png↩ "],
["data-views.html", "Lecture 4 Data-Driven Views 4.1 ListViews and Adapters 4.2 Networking with Volley", " Lecture 4 Data-Driven Views Lecture 3 discussed how to use Views to display content and support user interaction. This lecture extends those concepts and presents techniques for creating data-driven views—views that can dynamically present a data model in the form of a scrollable list. It also explains how to access data on the web using the Volley library. Overall, this process demonstrates a common way to connect the user interface for the app (defined as XML) with logic and data controls (defined in Java), following the Model-View-Controller architecture found throughout the Android framework. This lecture references code found at https://github.com/info448/lecture04-lists. 4.1 ListViews and Adapters In particular, this lecture discussed how to utilize a ListView12, which is a ViewGroup that displays a scrollable list of items! A ListView is basically a LinearLayout inside of a ScrollView (which is a ViewGroup that can be scrolled). Each element within the LinearLayout is another View (usually a Layout) representing a particular item in a list. But the ListView does extra work beyond just nesting Views: it keeps track of what items are already displayed on the screen, inflating only the visible items (plus a few extra on the top and bottom as buffers). Then as the user scrolls, the ListView takes the disappearing views and recycles them (altering their content, but not re-inflating from scratch) in order to reuse them for the new items that appear. This lets it save memory, provide better performance, and overall work more smoothly. See this tutorial for diagrams and further explanation of this recycling behavior. Note that a more advanced and flexible version of this behavior is offered by the RecyclerView class, which works in mostly the same way but requires a few extra steps to set up. See also this guide for more details. The ListView control uses a Model-View-Controller (MVC) architecture. This is a design pattern common to UI systems which organizes programs into three parts: The Model, which is the data or information in the system The View, which is the display or representation of that data The Controller, which acts as an intermediary between the Model and View and hooks them together. The MVC pattern can be found all over Android. At a high level, the resources provide models and views (separately), while the Java Activities act as controllers. Fun fact: The Model-View-Controller pattern was originally developed as part of the Smalltalk language, which was the first Object-Oriented language! Thus in order to utilize a ListView, we’ll have some data to be displayed (the model), the views (layouts) to be shown, and the ListView itself will connect these together act as the controller. Specifically, the ListView is a subclass of AdapterView, which is a View backed by a data source—the AdapterView exists to hook the View and the data together (just as a controller should). There are other AdapterViews as well. For example, GridView works exactly the same way as a ListView, but lays out items in a scrollable grid rather than a scrollable list. In order to use a ListView, we need to get the pieces in place: First we specify the model: some raw data. We will start with a simple String[], filling it with placeholder data: String[] data = new String[99]; for(int i=99; i&gt;0; i--){ data[99-i] = i+ &quot; bottles of beer on the wall&quot;; } While we normally should define such hard-coded data as an XML resource, we’ll create it dynamically for testing (and to make it changeable later!) Next we specify the view: a View to show for each datum in the list. Define an XML layout resource for that (list_item is a good name and a common idiom). We don’t really need to specify a full Layout (though we could if we wanted): just a basic TextView will suffice. Have the width match_parent and the height wrap_content. Don’t forget an id! &lt;!-- need to include the XML namespace (xmlns) so the `android` namespace validates --&gt; &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/txtItem&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; To make it look better, you can specify android:minHeight=&quot;?android:attr/listPreferredItemHeight&quot; (using the framework’s preferred height for lists), and some center_vertical gravity. The android:lines property is also useful if you need more space. Finally, we specify the controller: the ListView itself. Add that item to the Activity’s Layout resource (practice: what should its dimensions be?) To finish the controller ListView, we ned to provide it with an Adapter13 which will connect the model to the view. The Adapter does the “translation” work between model and view, performing a mapping from data types (e.g., a String) and View types (e.g., a TextView). Specifically, we will use an ArrayAdapter, which is one of the simplest Adapters to use (and because we have an array of data!) An ArrayAdapter creates Views by calling .toString() on each item in the array, and setting that String as the content of a TextView! ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.list_item_layout, R.layout.list_item_txtView, myStringArray); Note the parameters of the constructor: a Context to access resources, the layout resource to use for each item, the TextView within that layout (the target of the mapping), and the data array (the source of the mapping). Also note that this instance utilizes generics: we’re using an array of Strings (as opposed to an array of Dogs or some other type). We acquire a reference to the ListView with findViewById(), and call ListView#setAdapter() to attach the adapter to that controller. ListView listView = (ListView)findViewById(R.id.list_view); listView.setAdapter(adapter); And that’s all that is needed to create a scrollable list of data! To track the process: the Adapter will go through each item in the model, and “translate” that item into the contents of a View. These Views will then be displayed in a scrollable list. Each item in this list is selectable (can be given an onClick callback). This allows us to click on any item in order to (for example) get more details about the item. Utilize the AdapterView#setOnItemClickListener(OnItemClickListener) function to register the callback. The position parameter in the onItemClick() callback is the index of the item which was clicked. Use (Type)parent.getItemAtPosition(position) to access the data value associated with that View. Additionally, each item does have an individual layout, so you can customize these appearances (e.g., if our layout also wanted to include pictures). See this tutorial for an example on making a custom adapter to fill in multiple Views with data from a list! And remember, a GridView is basically the same thing (in fact, we can just change over that and have everything work, if we use polymorphism!) 4.2 Networking with Volley A list with hard-coded data isn’t very useful. It would be better if that data could be accessed dynamically, such as downloaded from the Internet! There are a couple of different ways to programmatically send network requests from an Android application. The “lowest level” is to utilize the HttpURLConnection API. With this API, you call methods to open a connection to a URL and then to send an HTTP Request to that location. The response is returned as an InputStream, which you need to “read” byte by byte in order to reconstruct the received data (e.g., to make it back into a String). See this example for details. While this technique is effective, it can be tedious to implement. Moreover, downloading network data can take a while—and these network method calls are synchronous and blocking, so will prevent other code from running while it downloads—including code that enables the user interface! Such block will lead to the infamous “Application not responding” (ANR) error. While it is possible to send such requests asynchronously on a background thread to avoid blocking, that requires additional overhead work. See the Services Lecture for more details. To solve these problems with less work, it can be be more effective to utilize an external library that lets us abstract away this process and just talk about making network requests and getting data back from them. (This is similar to how in web programming the fetch API abstracts the opaque XMLHttpRequest object). In particular, this lecture will introduce the Volley library, which is an external library developed and maintained by Google. It provides a number of benefits over a more “manual” approach, including handling multiple concurrent requests and enabling the caching of downloaded data. It also causes network requests to be handled asynchronously on a background thread without any additional effort! Volley’s main “competitor” is the Retrofit library produced by Square. While Retrofit is usually faster at processing downloaded data, Volley has built-in support for handling images (which will be useful in the future), and has a slightly more straightforward interface. Using Volley Because Volley is an external library (it isn’t built into the Android framework), you need to explicitly download and include it in your project. Luckily, we can use the Gradle build system to do this for us by listing Volley as a dependency for the project. Inside the app-level build.gradle file, add the following line inside the dependencies list: compile &#39;com.android.volley:volley:1.0.0&#39; This will tell Android that it should download and include version 1.0.0 of the Volley library when it builds the app. Hit the “Sync” button to update and rebuild the project. External libraries will be built into your app, increasing the file size of the compiled .apk (there is more code!). Though this won’t cause any problems for us, it’s worth keeping in mind as you design new apps. Once you have included Volley as a dependency, you will have access to the classes and API to use in your code. In order to request data with Volley, you will need to instantiate a Request object based on the type of data you will be downloading: a StringRequest for downloading text data, a JsonRequest for downloading JSON formatted data, or an ImageRequest for downloading images. The constructor for StringRequest, for example, takes 4 arguments: A constant representing the HTTP method (verb) to use. E.g., Request.Method.GET The URL to send the request to (as a String) A Response.Listener object, which defines a callback function to be executed when the response is received. A Response.ErrorListener object, which defines a callback function to be executed in case of an error. Because the last two listener objects are usually defined with anonymous classes, this can make the Request constructor look more complicated than it is: //silly example: get 20 random dinosaur names String url = &quot;http://dinoipsum.herokuapp.com/api/?format=text&amp;words=20&amp;paragraphs=1&quot;; Request myRequest = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() { public void onResponse(String response) { Log.v(TAG, response); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { Log.e(TAG, error.toString()); } }); (Also note that the Response.Listener is a generic class, in which we specify the format we’re expecting the response to come back in. This is String for a StringRequest, but would be e.g., JSONObject for a JsonObjectRequest). In order to actually send this Request, you need a RequestQueue, which acts like a “dispatcher” and handles sending out the Requests on background threads and otherwise managing the network operations. We create a dispatcher with default parameters (for networking and caching) using the Volley.newRequestQueue() factory method: RequestQueue requestQueue = Volley.newRequestQueue(getApplicationContext()); The factory method takes in a Context for managing the cache; the best practice is to use the application’s Context so it isn’t dependent on a single Activity. Once you have a RequestQueue, you can add your request to that in order to “send” it: requestQueue.add(myRequest); If you test this code, you’ll notice that it doesn’t work! The program will crash with a SecurityException. As a security feature, Android apps by default have very limited access to the overall operating system (e.g., to do anything other than show a layout). An app can’t use the Internet (which might consume people’s data plans!) without explicit permission from the user. This permission is given by the user at install time. In order to get permission, the app needs to ask for it (“Mother may I…?”). We do that by declaring that the app uses the Internet in the AndroidManifest.xml file (which has all the details of our app!) &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;!-- put this ABOVE the &lt;application&gt; tag --&gt; Note that Marshmallow introduced a new security model in which users grant permissions at run-time, not install time, and can revoke permissions whenever they want. To handle this, you need to add code to request “dangerous” permissions (like Location, Phone, or SMS access) each time you use it. This process is discussed in the Files and Permissions Lecture. Using the Internet is not a dangerous permission, so only requires the permission declaration in the Manifest. Once we’ve requested permission (and have been granted that permission by virtue of the user installing our application), we can finally connect to the Internet to download data. We can log out the request results to prove we got it! Of course, we’d like to display that data on the screen (rather than just log it out). That is, we want to put it into the ListView, meaning that we need to feed it back into the Adapter (which works to populate the Views). First, clear out any previous data items in the adapter using adapter.clear(). Then use adapter.add() or (adapter.addAll()) to add each of the new data items to the Adapter’s model! Note that you may need to do data parsing on the response body, such as splitting a String or constructing an array or ArrayList out of JSON data. You can call notifyDataSetChanged() on the Adapter to make sure that the View knows the data has changed, but this method is already called by the .add() method so isn’t necessary in this situation. You can use the JsonObjectRequest class to download data as a JSON Object rather than a raw String. JSON Objects and Arrays can be converted into Java Objects/Arrays using two classes: JSONObject and JSONArray. The constructors for each of these classes take a JSON String, and you can call the getJSONArray(key) and getJSONObject(key) in order to get nested objects and arrays from inside a JSONObject or JSONArray. RequestQueue Singletons If you are going to make multiple network requests for your application (which you usually will for anything of a reasonable size), it is wasteful to repeatedly instantiate new RequestQueue objects—these can take up significant memory and step on each others toes. Instead, the best practice is to use the Singleton Design Pattern to ensure that your entire application only uses a single RequestQueue. To do this, you will want to create an entire class (e.g., RequestSingleton) that will only ever be instantiated once (it will be a “singleton”). Since the Volley RequestQueue is controlled by this singleton, it means there will only ever be one RequestQueue. public class RequestSingleton { //make static if an inner class! //the single instance of this singleton private static RequestSingleton instance; private RequestQueue requestQueue = null; //the singleton&#39;s RequestQueue //private constructor; cannot instantiate directly private RequestSingleton(Context ctx){ //create the requestQueue this.requestQueue = Volley.newRequestQueue(ctx.getApplicationContext()); } //call this &quot;factory&quot; method to access the Singleton public static RequestSingleton getInstance(Context ctx) { //only create the singleton if it doesn&#39;t exist yet if(instance == null){ instance = new RequestSingleton(ctx); } return instance; //return the singleton object } //get queue from singleton for direct action public RequestQueue getRequestQueue() { return this.requestQueue; } //convenience wrapper method public &lt;T&gt; void add(Request&lt;T&gt; req) { requestQueue.add(req); } } This structure will let you make multiple network requests from multiple components of your app, but without trying to have multiple “dispatchers” taking up memory. Downloading Images In addition to downloading text or JSON data via HTTP requests, Volley is also able to support downloading images to be shown in your app. In general, handling images in Android is a difficult task. Images are large files (often multiple megabytes in size) that may require extensive and lingering data transfer to download and require processor-intensive decoding in order to be displayed. Since mobile devices are resource constrained (particularly in memory), trying to download and display lots of images—say in a scrollable list—can quickly cause problems. See Handling Bitmaps and Loading Large Bitmaps Efficiently for some examples of the complexity needed to work with images. Volley provides some support to make downloading and processing images easier. In particular, it provides built-in support for network management (so that data transfers are most efficiently optimized), caching (so you don’t try to download the same image twice), and for easily displaying network-loaded images. The other popular image-management libraries are Glide, Square’s Picasso, and Facebook’s Fresco. Google recommends using Glide for doing complex image work. However, if Volley’s image loading is sufficient for your task, that allows you to only need to work with a single library and networking queue. In order to effectively download images with Volley, you need to set up an ImageLoader. This object will handling downloading remote images as well as caching them for the future. To instantiate an ImageLoader, you need to provide a RequestQueue as well as an ImageCache object that represents how image data should be cached (e.g., in memory, on disk, etc.). The Volley documentation suggests using a LruCache object for caching to memory (though you can use a DiskBasedCache as well): //instantiate the image loader //params are the requestQueue and the Cache ImageLoader imageLoader = new ImageLoader(requestQueue, new ImageLoader.ImageCache() { //define an anonymous Cache object //the cache instance variable private final LruCache&lt;String, Bitmap&gt; cache = new LruCache&lt;String, Bitmap&gt;(20); //method for accessing the cache @Override public Bitmap getBitmap(String url) { return cache.get(url); } //method for storing to the cache @Override public void putBitmap(String url, Bitmap bitmap) { cache.put(url, bitmap); } }); It’s a good idea to make this ImageLoader an instance variable of the RequestSingleton. Once you have the ImageLoader, you can use it to download an image by calling it’s get() method, specifying a callback listener that will be executed when the image is finished downloading. However, you almost always want to download an image in order to display it. Volley makes this easy by providing a customized View called NetworkImageView. A NetworkImageView is able to handle the downloading of its source image on its own, integrating that process into the Activity’s lifecycle (e.g., so it won’t download when the View isn’t displayed). You declare a NetworkImageView in the layout XML in the same way you would specify an ImageView: &lt;com.android.volley.toolbox.NetworkImageView android:id=&quot;@+id/img_remote&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;fitXY&quot; /&gt; The android:scaleType attribute indicates how the image should be scaled to fit the View. In order to download an image into this View, you call the setImageUrl() method on the View from within your Java, specify the image url to load into the View and the ImageLoader to use for this network access: NetworkImageView netView = (NetworkImageView)findViewById(R.id.img_remote); netView.setImageUrl(&quot;https://ischool.uw.edu/fb-300x300.png&quot;, imageLoader); And that will let you download and show images from the Internet (without needing to make them into a drawable resource)! https://developer.android.com/guide/topics/ui/layout/listview.html↩ https://developer.android.com/reference/android/widget/Adapter.html↩ "],
["material-design.html", "Lecture 5 Material Design 5.1 The Material Design Language 5.2 Material Styles &amp; Icons 5.3 Design Support Libraries 5.4 Animations Resources", " Lecture 5 Material Design This lecture discusses Material design: the design language created by Google to support mobile user interfaces. The design language focuses on mobile designs (e.g., for Android), but can also be used across platforms (e.g., on the web through css frameworks). This lecture references code found at https://github.com/info448/lecture05-material. Material Design support was introduced in API 21 Lollipop, and so a device running that version of Android or later is required to access all the Material features supported by Android. However, most functionality is also available via compatibility libraries (i.e., AppCompat), and so can be utilized on older devices as well. 5.1 The Material Design Language Material design is a design language: a “vocabulary” of visual and interactive patterns that are shared across systems. Material forms both a “look and feel” for Google applications and modern (API 21+) Android apps in general, as well as providing a A video explanation of the Material language (via https://developer.android.com/design/material/index.html) In summary, the Material Design language is based around three main principles: Material is the metaphor. The Material design language is built around presenting user interfaces as being made of virtual materials, which ara paper-like surfaces floating in space. Each surface has a uniform thickness (1dp), but different elevation (conveyed primarily through shadows and perspective). This physical metaphor helps to indicate different affordances and user interactions: for example, a button is “raised” and can be “pushed down”. Motion provides meaning. Material also places great emphasis on the use of motion of these materials in order to help describe the relationships between components as well as make design overall more “delightful”. Material applications include lots of animations and flourishes, making the app’s usage continuous and connected. Surfaces are able to change shape, size, and position (as long as they stay in their plane—they cannot fold, but they can split and rejoin) in response to user input. Bold, graphic, intentional. Material applications follow a particular aesthetic in terms of things such as color (not muted), imagery (usually lots of it). Material applications look like material applications, though they can still be customized to meet your particular needs. For more information on the Material design language, see the official guidelines (click the hamburger button on the left to navigate). This documentation contains extensive examples and instructions, ranging from suggested font sizes to widget usage advice. This lecture focuses on ways to implement specific aspects of the Material Design language in Android applications, rather than on specifics of how to obey the language guidelines. 5.2 Material Styles &amp; Icons The first and easiest step towards making a Material-based application is to utilize the provided Material Themes in order to “skin” your application. These themes are available on API 21 Lollipop and later; for earlier operating system, you can instead use equivalent themes in AppCompat (which are in fact the default themes for new Android apps!) Applying themes (including Material themes) are discussed in more detail in the Styles &amp; Themes lab. You can see what specific properties are applied by these styles and themes by browsing the source code for the Android framework—check out the styles_material.xml and themes_material.xml (these will also reference values defined in the variable color and dimens resources). The AppCompat styles and themes can be source code for the v7 support library. In practice, the biggest part of utilizing a Material Theme is defining the color palette for your app. The Material design specification describes a broad color palette (with available swatches); however, it is often more useful to pick your colors using the provided color picker tool14, which allows you to easily experiment with different color combinations. Pick your primary and secondary color, and then assign the resource values colorPrimary, colorPrimaryDark, and colorAccent in res/values/colors.xml. This will let you easily “brand” your application. Material-specific attributes such as android:elevation are also available in API 21+, though making shadows visible on arbitrary elements requires some additional work. In addition to styles, Material also includes a large set of icons for use in applications. These icons supplement the built in ic_* drawables that are built into the platform and are available for use (and show up as auto-complete options in the IDE). Instead these icons are available as vector drawables—rather than being a .png file, images are defined as using an XML schema similar to that used in Scalable Vector Graphics (SVG). SVG is used to represent vector graphics—that is, pictures defined in terms of the connection between points (lines and other shapes), rather than in terms of the pixels being displayed (called a raster image). In order to be shown on a screen, these lines are converted (rastered) into grids of pixels based on the size and resolution of the display. This allows SVG images to “scale” or “zoom” independent of the size of the display or the image—you never need to worry about things getting blurry as you make them larger! In order to include a Material icon, you will need to generate the XML code for that particular image. Luckily, Android Studio includes XML definitions for all the Material icons (though you can also define your own vector drawables). To create a vector drawable, select File &gt; New &gt; Vector Asset from the Android Studio menu. You can then click on the icon to browse for which Material icon you want to create. By default the icon will be colored black. If you wish to change the color of the icon when included in your layout, specify the color through the android:tint attribute of the View in your XML (e.g., on the ImageButton). It is also possible to define arbitrary vector shapes in API 21+. For example, the starter code includes a resource for a &lt;shape&gt; element that is shaped like an oval. 5.3 Design Support Libraries In addition to the styling and resource properties available as part of the Android framework, there are also additional components available through extra support libraries. Similar to Volley, these libraries are not built into Android and so need to be explicitly listed as dependencies in your app’s build.gradle file. For example: compile &#39;com.android.support:design:26.1.0&#39; will include the latest version (as of this writing) of the design support library, which includes elements such as the Floating Action Button and Coordinator Layouts (described below). Note that if you have issues installing the dependency, the setup for including support libraries was changed in July 2017 to support downloading dependency libraries through maven rather than directly from Android Studio. To support this, you will need to change the project’s build.gradle repository declaration to look like: allprojects { repositories { jcenter() maven { url &quot;https://maven.google.com&quot; } } } Widgets The support libraries support a number of useful widgets (specialized Views) for creating Material-styled apps. RecyclerView The RecyclerView is a more advanced version of a ListView, providing a more robust system for support interactive Views within the list as well as providing animations for things like adding and removing list items. This class is part of the v7 support library (and not the Material Design library specifically), and so you will need to include it specifically in your app’s build.gradle file (the same way you included Volley): compile &#39;com.android.support:cardview-v7:26.1.0&#39; Implementing a RecyclerView is very similar to implementing a ListView (with the addition of the ViewHolder pattern), though you also need to declare a LayoutManager to specific if your RecyclerView should use a List or a Grid. The best way to understand the RecyclerView is to look at the example and modify that to fit your particular item view. For example, you can change a ListView into a RecyclerView by adapting the sample code provided by Google’s official documentation15: First, you will need to replace the XML View declaration with a &lt;android.support.v7.widget.RecyclerView&gt; element. In effect, we’re just modifying the controller for the list. There are a few extra steps when setting up the RecyclerView in the Java code. In particular, you will also need to associate a LayoutManager object to with the View—for example, a LinearLayoutManager to show items in a line (a la a ListView), or a GridLayoutManager to show items in a grid (a la a GridView). All RecyclerViews require custom adapters: we cannot just use a built-in adapter such as ArrayAdapter. To do this, create a class that extends RecyclerView.Adapter&lt;VH&gt;. The generic in this class is a class representing a View Holder. This is a pattern by which each individual Views that will be inflated and references are stored as individual objects with the particular Views to be modified (e.g., TextView) saved as instance variables. This avoids the need for the adapter to repeatedly use findViewById(), which is an expensive operation (since it involves crawling the View hierarchy tree!) The ViewHolder will be another class—usually an inner class of the adapter. It acts as a simple “container” object (similar to a struct in C). You can assign these instance variables the results of the findViewById() calls in the ViewHolder’s constructor. The RecyclerView (not the ViewHolder) requires you to override the onCreateViewHolder() method, which will inflate() the View and instantiate a ViewHolder for each item when that item needs to be displayed for the first time. In the overridden onBindViewHolder() you can do the actual work of assigning model content to the particular View (e.g., called setText()). You don’t need to use findViewById() here, because you’ve already saved a reference to that View in the ViewHolder! The getItemCount() is used internally for the RecyclerView to determine when you’ve gotten to the “end” of the list. Finally, you can assign the custom adapter to the RecyclerView in order to associate the model and the View. And that’s about it! While it is more code and more complex than a basic ListView, as soon as you’ve added in the ViewHolder pattern or done any other kinds of customizations, you’re basically at the same level. Additionally Note that unlike with a ListView, we usually modify the items shown in a RecyclerView by modifying the data model (e.g., the array or ArrayList) directly. But we will need to notify the RecyclerView’s adapter of these changes by calling one of the various .notify() methods on the adapter (e.g., adapter.notifyItemInserted(position)). This will cause the adapter to “refresh” the display, and it will actually animate the changes to the list by default! Using a RecyclerView instead of a ListView also enables common user actions such as “drag-to-order” or “swipe-to-dismiss”. See this guide for a walkthrough on adding these capabilities. Cards The v7 support library also provides a View for easily styling content as Cards. A CardView is basically a FrameLayout (a ViewGroup that contains one child View), but include borders and shadows that make the group look like a card. You will need to load the CardView class as a gradle dependency using compile 'com.android.support:cardview-v7:26.1.0'. To utilize a CardView, simply include it in your layout as you would any other ViewGroup: &lt;android.support.v7.widget.CardView xmlns:card_view=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;@dimen/card_width&quot; android:layout_height=&quot;@dimen/card_height&quot; android:layout_gravity=&quot;center&quot; card_view:cardCornerRadius=&quot;4dp&quot;&gt; &lt;!-- A single TextView in the card --&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/card_text&quot; /&gt; &lt;/android.support.v7.widget.CardView&gt; Notice the card_view:cardCornerRadius attribute; this is an example of how specific Views may have their own custom properties (sometimes available via a different schema). Since Cards are FrameLayouts, they should only contain a single child. If you want to include multiple elements inside a Card (e.g., an image, some text, and a button), you will need to nest another ViewGroup (such as a LinearLayout) inside the Card. For design suggestions on using Cards, including spacing information, see the Material Design guidelines. If you want to include a circular image in your card (or anywhere else in your app), the easiest solution is to include an external library that provides such a View, the most popular of which is de.hdodenhof.circleimageview. Floating Action Buttons (FAB) While RecyclerViews and Cards are found in the v7 support library, the most noticeable and interesting components come from the Design Support Library, which specifically includes components for supporting Material Design. This library should be includes in gradle as com.android.support:design:26.1.0, as in the above example. The most common element from this library is the Floating Action Button (FAB). This is a circular button that “floats” above the content of the screen (at a higher elevation), and represents the primary action of the UI. A screen should only ever have one FAB, and only if there is a single main action that should be performed. See the design guidelines for more examples on how to use (and not use) FABS. Like a Card, you can include a FAB in your application by specifying it as an element in your XML: &lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;end|bottom&quot; android:layout_margin=&quot;@dimen/fab_margin&quot; android:src=&quot;@drawable/ic_my_icon&quot; /&gt; Because FABs are a subclass of ImageButton, we can just replace an existing button with a FAB without breaking anything. Fabs support a number of additional effects. For example, if you make the FAB clickable (via android:clickable), you can specify an app:rippleColor to give it a rippling effect when pressed. Further details will be presented below. Snackbars The Design Support Library also includes an alternative to Toast messages called Snackbars. This is a user-facing pop-up message that appears at the bottom of the screen (similar to a Toast). Snackbars are shown using a similar structure to Toasts: Snackbar snack = Snackbar.make(view, &quot;Let&#39;s go out to the lobby!&quot;, Snackbar.LENGTH_LONG).show(); Instead of calling the Toast.makeText() factory method, we call the Snackbar.make() factory method. The first parameter in this case needs to be a View that the Snackbar will be “attached” to (so shown with)—however, it doesn’t really matter which View is given, since the method will search up the view heirarchy until it gets to the root content view or a CoordinatorLayout. You’ll notice that the Snackbar overlays the content (including the FAB). This will be addressed below by introducing a CoordinatorLayout. Additionally, it is possible to give Snackbar’s their own action that the user can activate by clicking on the Snackbar. This allows the bar to, for example, show a delete confirmation but providing an “undo” action. The action is specified by calling the .setAction() method on the Snackbar, and passing in a title for the action as well as an OnClickListener: mySnackbar.setAction(&quot;Click&quot;, new View.OnClickListener() { @Override public void onClick(View view) { //... } }); For practice, make the Snackbar .hide() the FAB, but provide an “undo” action that will .show() it! Again, see the design guidelines for more examples on how to use (and not use) Snackbars. Coordinator Layout In order to fix the Snackbar and Fab overlap, we’ll need to utilize one of the most powerful but complex classes in the Material support library: the CoordinatorLayout. This layout is described as “a super-powered Framelayout”, and provides support for a number of interactive and animated behaviors involves other classes. A lot of the “whizbang” effects in Material are built on top of the CoordinatorLayout (or other classes that rely on it). To start our exploration of CoordinatorLayout, let’s begin by fixing the Snackbar overlap. To do this, we’ll take the existing layout for the activity and “wrap” it in a &lt;android.support.design.widget.CoordinatorLayout&gt; element: &lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!-- Previous layout elements --&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!-- etc --&gt; &lt;/RelativeLayout&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; We will also need to move the FAB definition so that it is a direct child of the CoordinatorLayout. Once we have done so, we should be able to click the button and watch it move up to make room for the Snackbar! How this works is that the CoordinatorLayout allows you to give Behaviors to its child views; these Behaviors will then be executed when the state of the CoordinatorLayout (or its children) changes. For example, the built-in FloatingActionButton.Behavior defines how the button should move in response to it’s parent changing size, but Behaviors can also be defined in response to use interactions such as swipes or other gestures. Scrolling Layouts Indeed, the built-in behaviors can be quite complex (and wordy to implement), and the best way to understand them is to see them in action. To see an example of this, create a new Activity for your application (e.g., File &gt; New &gt; Activity). But instead of creating an Empty Activity as you’ve done before, you should instead create a new ScrollingActivity. Modify the FAB action so that when you click on it, you send an Intent for to open up this new Activity: startActivity(new Intent(MainActivity.this, ScrollingActivity.class)); And once you’ve opened up the Activity… try scrolling! You should see the ActionBar collapse while the FAB moves up and disappears. This is an example of a collection of behaviors built into CoordinatorLayout and other classes in the Design Support library. To get a sense for how they work, open up the newly created activity_scrolling.xml layout resource and see how this layout was constructed! At the root of the layout we find the CoordinatorLayout, ready to “coordinate” all of its children and allow them to interact. The first child is an AppBarLayout. This layout specifically supports responding to scroll events produced from within the CoordinatorLayout (e.g., when the user scrolls through the text content). You can control the visibility of this element based on scrolling using the app:layout_scrollFlags attribute. The AppBarLayout works together with its child CollapsingToolbarLayout, which does just what it says on the tin. It shows a larger title, but then shrinks down in response to scrolling. Here the scrollFlags are declared: scroll|exitUntilCollapse indicates two flags (combined with a bitwise OR |): that the content should scroll, and that it should shrink to its minimum height until it collapses. The Toolbar itself is finally defined as a child of CollapsingToolbarLayout, though other children could be added here as well. For example, an ImageView could be included as a child of the CollapsingToolbarLayout in order to create a collapsing image! (Check the documentation for details about all of the specific attributes). After the collapsing AppBar, the CoordinatorLayout includes a NestedScrollView (declared in a separate file for organization). This is a scrollable view (similar to what is used in a ListView), but both include and be included within scrollable layouts. Notice that this element includes an app:layout_behavior attribute, which refers to a particular class: AppBarLayout$ScrollingViewBehavior (the $ is used to refer to a compiled nested class). This Behavior will “automatically scroll any AppBarLayout siblings”, allowing the scrolling of the page content to also cuase the AppBarLayout to scroll! Finally, we have the FAB for this screen. The biggest piece to note here is how the FAB includes the app:layout_anchor attribute assigned a reference to the AppBarLayout. This indicates that the FAB should follow (scroll with) the AppBarLayout; the app:anchorGravity property indicates where it should be relative to its anchor. Moreover, the FAB’s default behavior will cause it to disappear when then is no room… and since the AppBarLayout exits on collapse, the FAB disappears as well! In sum: the NestedScrollingView has a Behavior that will cause the AppBarLayout to scroll with it. The AppBarLayout has Behaviors that allow it to collapse, and the FAB is connected to that layout to moves up with it and eventually disappear. Custom Behaviors We can also create our own custom behaviors if we want to change the way elements interact with the CoordinatorLayout. For example, we can create a Behavior so that the FAB on the MainActivity shrinks and disappears when the Snackbar is shown, rather than moving up out of the way! First, we will create a new Java class to represent our ShrinkBehavior. This class will need to extend CoordinatorLayout.Behavior&lt;FloatingActionButton&gt; (because it is a CoordinatorLayout.Behavior and it will be applied to a FloatingActionButton). We will need also need to override the constructor so that we can declare/instantiate this class from the XML: public ShrinkBehavior(Context context, AttributeSet attrs) { super(context, attrs); } The next step is to make sure the Behavior is able to react to changes in the Snackbar. To do this we have to make the Behavior report that is has the Snackbar as a dependency. This way when the CoordinatorLayout is propagating events and changes to all of its children, it will know that it should also inform the FAB about changes to the Snackbar. We do this by overriding the layoutDependsOn() method: public boolean layoutDependsOn(CoordinatorLayout parent, FloatingActionButton child, View dependency) { //add SnackbarLayout to the dependency list (if any) return dependency instanceof Snackbar.SnackbarLayout || super.layoutDependsOn(parent, child, dependency); } (Technically the super class doesn’t have any other dependencies, but it’s still good practice to call up the tree). Finally, we can specify what should happen when one of the dependency’s Views change by overriding the onDependentViewChange() callback: public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child, View dependency) { if(dependency instanceof Snackbar.SnackbarLayout){ //calculate how much Snackbar we see float snackbarOffset = 0; if(parent.doViewsOverlap(child, dependency)){ snackbarOffset = Math.min(snackbarOffset, dependency.getTranslationY() - dependency.getHeight()); } float scaleFactor = 1 - (-snackbarOffset/dependency.getHeight()); child.setScaleX(scaleFactor); child.setScaleY(scaleFactor); return true; }else { return super.onDependentViewChanged(parent, child, dependency); } } This method will be passed a reference to the CoordinatorLayout that is managing the changes, the FloatingActionButton who is receiving the change, and which dependency had it’s View changed. We check that the dependency is actually a Snackbar (since we might have multiple dependencies and want to respond differently to each one), and then call some getters on that dependency to figure out how tall it is (and thus how much we should shrink by). Finally, we use setters to change the scaling of the child (the FAB), thereby having it scale! And because this scale is dependent on the Snackbar’s height, the FAB will also “grow back” when the Snackbar goes away! This is about the simplest form of Behavior we can have: more complex behaviors can be based on scroll or fling events, utilizing different state attributes for different dependencies! Custom behaviors are very tricky to write and design; the overridden functions are not very well documented, and by definition these behaviors involve coordinating lots of different classes! Most custom behaviors are designed by reading the Android source code (e.g., for FloatingActionButton.Behavior) and modifying that as an example. My suggestion is to search online for behaviors similar to the one you’re trying to achieve, and work from there. 5.4 Animations One of the key principles of Material Design was the use of motion: many of the previous examples have involved adding animated changes to elements (e.g., moving or scrolling). The Material theme available in API 21+ provides a number of different techniques for including animations in your application—in particular, using animation to give user feedback and provide connections between elements when the display changes. As a final example, this section will cover how to add simple Activity Transitions so that Views “morph” from one Activity to the next. In order to utilize Activity Transitions, you will need to enable them in your application’s theme by adding an addition &lt;item&gt; in the theme declaration (in res/values/styles.xml): &lt;!-- in style: enable window content transitions --&gt; &lt;item name=&quot;android:windowActivityTransitions&quot;&gt;true&lt;/item&gt; There are three different kinds of Activity Transitions we can specify: enter transitions, or how Views in an Activity enter the screen exit transitions, or how Views in an Activity leave the screen shared element transitions, or how Views that are shared between Activities change We’ll talk about the later, though the previous two follow a similar process. In order to animate a shared element between two Activities, we need to give them matching identifiers so that the transition framework knows to animate them. We do this by giving each of the shared elements an android:transitionName attribute, making sure that they have the same value. For example, we can give the FAB in each activity an android:transitionName=&quot;fab&quot;. Because the FAB is anchored, we actually need to do some extra work (because FAB will morph to the “unanchored” point and then get moved once the anchorage is calculated). The easiest workaround for this is to wrap the anchored FAB inside an anchored FrameLayout—the FAB just then becomes a normal element with the FrameLayout handling the scrolling behavior. &lt;FrameLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:layout_anchor=&quot;@id/app_bar&quot; app:layout_anchorGravity=&quot;bottom|end&quot; android:elevation=&quot;12dp&quot; &gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:transitionName=&quot;same_fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;@dimen/fab_margin&quot; app:srcCompat=&quot;@android:drawable/ic_dialog_email&quot; /&gt; &lt;/FrameLayout&gt; Finally, we need to make sure that the Intent used to start the Activity also starts up the transition animation. We do this be including an additional argument to the startActivity() method: an options Bundle containing details about the animation: //transition this single item ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(MainActivity.this, button, &quot;fab&quot;); // start the new activity startActivity(new Intent(MainActivity.this, ScrollingActivity.class), options.toBundle()); This should cause the FAB to “morph” between Activties (and even morph back when you hit the “back” button)! For more about what makes effective animation, see the Material deisgn guidelines. I find Activity Transitions to be slick, but finicky: getting them to work properly takes a lot of effort and practice. Most professional apps that utilize Material Design use extensive custom animations for generating these transitions. For examples of more complex Material Design animations and patterns, check out sample applications such as cheesesquare or plaid. Resources Material Design Guidelines check the whole document (via the hamburger menu on the left). Material Design for Developers (Google) official documentation for implementing material design Material Design Primer (CodePath) excellent compiled documentation and examples for implementing Material patterns (CodePath in general is an excellent resource). Android Design Support Library (Google Blog) an introduction to the support library features Mastering the Coordinator Layout (Blog) a great set of examples of how to use CoordinatorLayout. Using CoordinatorLayout in Android Apps (Blog) another good explanation of CoordinatorLayout https://lab.getbase.com/introduction-to-coordinator-layout-on-android/ https://material.io/color/#!/↩ https://developer.android.com/training/material/lists-cards.html#RecyclerView↩ "],
["fragments.html", "Lecture 6 Fragments 6.1 Creating a Fragment 6.2 Dynamic Fragments 6.3 Dialogs", " Lecture 6 Fragments This lecture discusses Android Fragments. A Fragment is “a behavior or a portion of user interface in Activity.” You can think of them as “mini-activities” or “sub-activities”. Fragments are designed to be reusable and composable, so you can mix and match them within a single screen of a user interface. While XML resource provide reusable and composable views, Fragments provide reusable and composable controllers. Fragments allow us to make re-usable pieces of Activities that can have their own layouts, data models, event callbacks, etc. This lecture references code found at https://github.com/info448/lecture06-fragments. Fragments were introduced in API 11 (Honeycomb), which provided the first “tablet” version of Android. Fragments were designed to provide a UI component that would allow for side-by-side activity displays appropriate to larger screens: Fragment example, from Google16. Instead of needing to navigate between two related views (particularly for this “master and detail” setup), the user can see both views within the same Activity… but those “views” could also be easily split between two Activities for smaller screens, because their required controller logic has been isolated into a Fragment. Fragments are intended to be modular, reusable components. They should not depend on the Activity they are inside, so that you can be flexible about when and where they are displayed! Although Fragments are like “mini-Activities”, they are always embedded inside an Activity; they cannot exist independently. While it’s possible to have Fragments that are not visible or that don’t have a UI, they still are part of an Activity. Because of this, a Fragment’s lifecycle is directly tied to its containing Activity’s lifecycle. (e.g., if the Activity is paused, the Fragment is too. If the Activity is destroyed, the Fragment is too). However, Fragments also have their own lifecycle with corresponding lifecycle callbacks functions. Fragment lifecycle state diagram,from Google17. The Fragment lifecycle is very similar to the Activity lifecycle, with a couple of additional steps: onAttach(): called when the Fragment is first associated with (“added to”) an Activity, and thus gains a Context. This callback is generally used for initializing communication between the Fragment and its Activity. This callback is mirrored by onDetach(), for when the Fragment is removed from an Activity. onCreateView(): called when the View (the user interface) is about to be drawn. This callback is used to establish any details dependent on the View (including adding event listeners, etc). Note that code initializing data models, or anything that needs to be persisted across configuration changes, should instead be done in the onCreate() callback. onCreate() is not called if the fragment is retained (see below). This callback is mirrored by onDestroyView(), for when the Fragment’s UI View hierarchy is being removed from the screen. onActivityCreated(): called when the containing Activity’s onCreate() method has returned, and thus indicates that the Activity is fully created. This is useful for retained Fragments. This callback has no mirror! 6.1 Creating a Fragment In order to illustrate how to make a Fragment, we will refactor the MainActivity to use Fragments for displaying the list of movies. This will help to illustrate the relationship between Activities and Fragments. To create a Fragment, you subclass the Fragment class. Let’s make one called MovieListFragment (in a MovieListFragment.java file). You can use Android Studio to do this work: via the File &gt; New &gt; Fragment &gt; Fragment (blank) menu option. (DO NOT select any of the other options for in the wizard for now; they provide template code that can distract from the core principles). There are two versions of the Fragment class: one in the framework’s android.app package and one in the android.support.v4 package. The later package refers to the Support Library. As discussed in the previous chapter, these are libraries of classes designed to make Android applications backwards compatible: for example, Fragment and its related classes came out in API 11 so aren’t in the android.app package for earlier devices. By including the support library, we can include those classes on older devices as well! Support libraries also include additional convenience and helper classes that are not part of the core Android package. These include interface elements (e.g., ConstraintLayout, RecyclerView, or ViewPager) and accessibility classes. See the features list for details. Thus it is often useful to include and utilize support library versions of classes even when targeting later devies so that you don’t need to “roll your own” versions of these convenience classes. The main disadvantage to using support libraries is that they need to be included in your application, so will make the final .apk file larger (and may potentially require workarounds for method count limitations). You will also run into problems if you try and mix and match versions of the classes (e.g., from different versions of the support library). But as always, you should avoid premature optimization. Thus in this course you should default to using the support library version of a class when given a choice! After we’ve created the MovieListFragment.java file, we’ll want to specify a layout for that Fragment (so it can be shown on the screen). As part of using the New Fragment Wizard we were provided with a fragment_movie_list layout that we can use. Since we want the Movie list to live in that Fragment, we can move (copy) the View definitions from activity_main into fragment_movie_list. We will then adjust activity_main so that it instead contains an empty FrameLayout. This will act as a simple “container” for our Fragment (similar to an empty &lt;div&gt; in HTML). Be sure to give it an id so we can refer to it later!. It is possible to include the Fragment directly through the XML, using the XML to instantiate the Fragment (the same way that we have the XML instantiate Buttons). We do this by specifying a &lt;fragment&gt; element, with an android:name attribute assigned a reference to the Fragment class: &lt;fragment android:id=&quot;@+id/fragment&quot; android:name=&quot;edu.uw.fragmentdemo.MovieListFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; Defining the Fragment in the XML works (and will be fine to start with), but in practice it is much more common and worthwhile to instantiate the Fragments dynamically at runtime in the Java code—thereby allowing the Fragments to be dynamically determined and changed. We will start with the XML version to built the Fragment, and then shift to the Java version. We can next begin filling in the Java logic for the Fragment. Android Studio provides a little starter code: a constructor and the onCreateView() callback—the later is more relevant since we will use that to set up the layout (similar to in the onCreate() function of MainActivity). But the MainActivity#onCreate() method specifies a layout by calling setContentView() and passing a resource id. With Fragments, we can’t just “set” the View because the Fragment belongs to an Activity, and so will exist inside its View hierarchy! Instead, we need to figure out which ViewGroup the Fragment is inside of, and then inflate the Fragment’s View inside that ViewGroup. This “inflated” View is referred to as the root view: it is the “root” of the Fragment’s View tree (the View that all the Views inside the Fragment’s layout will be attached to). We access the root view by inflating the fragment’s layout, and saving a reference to the inflated View: View rootView = inflater.inflate(R.layout.fragment_layout, container, false); Note that the inflater object we are calling inflate() on was passed as a parameter to the onCreateView() callback. The parameters to the inflate() method are: the layout to inflate, the ViewGroup (container) into which the layout should be inflated (also passed as a parameter to the callback), and whether or not to “attach” the inflated layout to the container (false in this case because the Fragment system already handles the attachment, so the inflate method doesn’t need to). The onCreateView() callback must return the inflated root view, so that the system can perform this attachment. With the Fragment’s layout defined, we can start moving functionality from the Activity into the Fragment. The ListView and adapter setup will need to be moved over. The UI setup (including initializing the Adapter) will be moved from the Activity’s onCreate() to the Fragment’s onCreateView(). However, you will need to make a few changes during this refactoring: The findViewById() method is a method of the Activity class, and thus can’t be called on an implicit this inside the Fragment. Instead, the method can be called on the root view, searching just that View and its children. The Adapter’s constructor requires a Context as its first parameter; while an Activity is a Context, a Fragment is not—Fragments operate in the Context of their containing Activity! Fragments can refer to the Activity that they are inside (and the Context it represents) by using the getActivity() method. Note that this method is used primarily for getting a reference to a Context, not for arbitrary communication with the Activity (see below for details) The downloadMovieData() helper method can be moved over, so that it belongs to the Fragment instead of the Activity. It will be the Fragment’s responsibility to handle data downloading. Activity-to-Fragment Communication This example has intentionally left the input controls (the search field and button) in the Activity, rather than making them part of the Fragment. Apart from being a useful demonstration, this allows the Fragment to have a single purpose (showing the list of movies) and would let us change the search UI independent of the displayed results. But since the the button is in the Activity while the downloading functionality is in the Fragment, we need a way for the Activity to “talk” to the Fragment. We thus need a reference to the contained Fragment—access to the XML similar to that provided by findViewById. We can get a reference to a contained Fragment from an Activity by using a FragmentManager. This is an object responsible for (ahem) managing Fragment. It allows us to “look up” Fragments, as well as to manipulate which Fragments are shown. We access this FragmentManager by calling the getSupportFragmentManager() method on the Activity, and then can use findFragmentById() to look up an XML-defined Fragment by its id: //MovieListFragment example MovieListFragment fragment = (MovieListFragment)getSupportFragmentManager().findFragmentById(R.id.fragment); Note that we’re using a method to explicit access the support FragmentManager. The Activity class (API level 15+) is able to work with both the platform and support FragmentManager classes. But because these classes don’t have a shared interface, the Activity needs to provide different Java methods which can return the correct type. Once you have a reference to the Fragment, this acts just like any other object—you can call any public methods it has! For example, if you give the Fragment a public method (e.g., searchMovies()), then this method can be called from the Activity: //called from Activity on the referenced fragment fragment.searchMovies(searchTerm) (The parameter to this public method allows the Activity to provide information to the Fragment!) At this point, the program should be able to be executed… and continue to function in exactly the same way! The program has just been refactored, so that all the movie downloading and listing work is encapsulated inside a Fragment that can be used in different Activities. In effect, we’ve created our own “widget” that can be included in any other screen, such as if we repeatedly wanted the list of movies to be available alongside some other user interface components. 6.2 Dynamic Fragments The real benefit from encapsulating behavior in a Fragment is to be able to support multiple Fragments within a single Activity. For example, in the the archetypal “master/detail” navigation flow, one screen (Fragment) holds the “master list” and another screen (Fragment) holds details about a particular item. This is a very common navigation pattern for Android apps, and can be seen in most email or news apps. On large screens, Fragments allow these two Views to be placed side by side! In this section, we will continue to refine the Movie app so that when the user clicks on a Movie in the list, the app shows a screen (Fragment) with details about the selected movie. Instantiating Fragments To do this, we will need to instantiate the desired Fragment dynamically (in Java code), rather than statically in the XML using the &lt;fragment&gt; element. This is because we need to be able to dynamically change which Fragment is currently being shown, which is not possibly for Fragments that are “hard-coded” in the XML. Unlike Activities, Fragments (such as MovieListFragment) do have constructor methods that can be called. In fact, Android requires that every Fragment include a default (no-argument) constructor that is called when Fragments are created by the system! While we are have access to the constructor, it is considered best practice to not call this constructor directly when you want to instantiate a Fragment, and to in fact leave the method empty. This is because we do not have full control over when the constructor is executed: the Android system may call the no-argument constructor whenever it needs to recreate the Activity (or just the Fragment), which can happen at arbitrary times. Since only this default constructor is called, we can’t add an additional constructor with any arguments we may want the Fragment to have (e.g., the searchTerm)… and thus it’s best to not use it at all. Instead, we specify a simple factory method (by convention called newInstance()) which is able to “create” an instance of the Fragment for us. This factory method can take as many arguments as we want, and then does the work of passing these arguments into the Fragment instantiated with the default constructor: public static MyFragment newInstance(String argument) { MyFragment fragment = new MyFragment(); //instantiate the Fragment Bundle args = new Bundle(); //an (empty) Bundle for the arguments args.putString(ARG_PARAM_KEY, argument); //add the argument to the Bundle fragment.setArguments(args); //add the Bundle to the Fragment return fragment; //return the Fragment } In order to pass the arguments into the new Fragment, we wrap them up in a Bundle (an object containing basic key-value pairs). Values can be added to a Bundle using an appropriate putType() method; note that these do need to be primitive types (int, String, etc.). The Bundle of arguments can then be assignment to the Fragment by calling the setArguments() method. We will be able to access this Bundle from inside the Fragment (e.g., in the onCreateView() callback) by using the getArguments() method (and getType() to retrieve the values from it). This allows us to dynamically adjust the content of the Fragment’s Views! For example, we can run the downloadMovieData() function using this argument, fetching movie results as soon as the Fragment is created (e.g., on a button press)… allowing the downloadMovieData() function to again be made private, for example. Since the Bundle is a set of key-value pairs, each value needs to have a particular key. These keys are usually defined as private constants (e.g., ARG_PARAM_KEY in the above example) to make storage and retrieval easier. We will then be able to instantiate the Fragment (e.g., in the Activity class), passing it any arguments we wish: MyFragment fragment = MyFragment.newInstance(&quot;My Argument&quot;); Transactions Once we’ve instantiated a Fragment in the Java, we need to attach it to the view hierarchy: since we’re no longer using the XML &lt;fragment&gt; element, we need some other way to load the Fragment into the &lt;FrameLayout&gt; container. We do this loading using a FragmentTransaction18. A transaction represents a change in the Fragment that is being displayed. You can think of this like a bank (or database) transaction: they allow you to add or remove Fragments like we would add or remove money from a bank account. We instantiate new transactions representing the change we wish to make, and then “run” that transaction in order to apply the change. To create a transaction, we utilize the FragmentManager again; the FragmentManager#beginTransaction() method is used to instantiate a new FragmentTransaction. Transactions represent a set of Fragment changes that are all “applied” at the same time (similar to depositing and withdrawing money from multiple accounts all at once). We specify these transactions using by calling the add(), remove(), or .replace() methods on the FragmentTransaction. The add() method lets you specify which View container you want to add a particular Fragment to. The remove() method lets you remove a Fragment you have a reference to. The replace() method removes any Fragments in the container and then adds the specified Fragment instead. Each of these methods returns the modified FragmentTransaction, so they can be “chained” together. Finally, we call the commit() method on the transaction in order to “submit” it and have all of the changes go into effect. We can do this work in the Activity’s search click handler to add a Fragment, rather than specifying the Fragment in the XML: FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); //params: container to add to, Fragment to add, (optional) tag transaction.add(R.id.container, myFragment, MOVIE_LIST_FRAGMENT_TAG); transaction.commit(); The third argument for the add() method is a “tag” we apply to the Fragment being added. This gives it a “name” that we can use to find a reference to this Fragment later if we want (via FragmentManager#findFragmentByTag(tag)). Alternatively, we can save a reference to the Fragment as an instance variable; this is faster but more memory intensive (and can cause possible leaks, since the reference keeps the Fragment from being reclaimed by the system). Inter-Fragment Communication We can this transaction-based structure to instantiate and load a second Fragment (e.g., a “detail” view for a selected Movie). We can add functionality (e.g., in the onClick() handler) so that when the user clicks on a movie in the list, we replace() the currently displayed Fragment with this new details Fragment. However, remember that Fragments are supposed to be modular—each Fragment should be self-contained, and not know about any other Fragments that may exist (after all, what if we wanted the master/detail views to be side-by-side on a large screen?) Using getActivity() to reference the Activity and getSupportFragmentManager() to access the manager is a violation of the Law of Demeter—don’t do it! Instead, we have Fragments communicate by passing messages through their contained Activity: the MovieFragment should tell its Activity that a particular movie has been selected, and then that Activity can determine what to do about it (e.g., creating a DetailFragment to display that information). The recommended way to provide Fragment-to-Activity communication is to define an interface. The Fragment class should specify an interface (for one or more public methods) that its containing Activity must support—and since the Fragment can only exist within an Activity that implements that interface, it knows the Activity has the specified public methods that it can call to pass information to that Activity. As an example of this process: Create a new interface inside the Fragment (e.g., OnMovieSelectedListener). This interface needs a public method (e.g., onMovieSelected(Movie movie)) that the Fragment can call to give instructions or messages to the Activity. In the Fragment’s onAttach() callback (called when the Fragment is first associated with an Activity), we can check that the Activity actually implements the interface by trying to cast it to that interface. We can also save a reference to this Activity for later, to save some time: public void onAttach(Context context) { super.onAttach(context); try { callback = (OnMovieSelectedListener)context; //attempt to cast } catch (ClassCastException e) { throw new ClassCastException(context.toString() + &quot; must implement OnMovieSelectedListener&quot;); } } Then when an action occurs in the Fragment (e.g., a movie is selected), you call the interface’s method on the callback reference. Finally, you will need to make sure that the Activity implements this callback. Remember that a class can implement multiple interfaces! In the Activity’s implementation of the interface, you can handle the information provided. For example, use the FragmentManager to create a replace() transaction to load a new DetailFragment for the appropriate data. In the end, this will allow you to have one Fragment cause the application to switch to another! This is not the only way for Fragments to communicate. It is also possible to have a Fragment send an Intent to the Activity, who then responds to that as appropriate. But using the Intent system is more resource-intensive than using interfaces. Parcelable It’s not uncommon to want to pass multiple or complex data values as arguments to a new Fragment, such as a Movie object. However, the arguments for a new Fragment must be passed in through a Bundle, which are only able to store primitive values (e.g., int, float, String)… and a special data type called Parcelable. An object that implements the Parcelable interface includes methods that allow it to be serialized into a value that is simple enough to place in a Bundle—in effect, it’s values are converted into a formatted String (similar in concept to JSON.stringify() in JavaScript). Implementing the Parcelable interface involves the following steps: 1. provide a writeToParcel() method that adds the object’s fields to a given Parcel object 2. provide a constructor that can re-create the object from a Parcel by reading the values from it (in the EXACT SAME order they were added!) 3. provide a describeContents() that returns whether the parcel includes a file descriptor (usually 0, meaning not) 4. provide a Parcelable.Creator constant that can be used to create the Parcelable. These steps seem complex but are fairly rote: as such, it’s possible to “automate” making a class into a Parcelable. My favorite strategy is to use http://www.parcelabler.com/, a website that allows you to copy and paste a class and provides you a version of that class with the Parcelable interface implemented! Bundles are only supposed to store small amounts of information (a few variables); and by extension Parcelable objects should also only include a few attributes. Never make an object that contains an array of a list into a Parcelable! Complex or variable-length data should instead be persisted separate from the Activity (e.g., in a database), with identifiers passed in Bundles instead. The Back Stack But what happens when we hit the “back” button? The Activity exits! Why? Because “back” normally says to “leave the Activity”—we only had one Activity, just multiple fragments. Recall that the Android system may have lots of Activities (even across multiple apps!) with the user moving back and forth between them. As described in Lecture 3, each new Activity is associated with a “task” and placed on a stack19. When the “back” button is pressed, that Activity is popped off the stack, and the user is taken to the Activity that is now at the top. Fragments by default are not part of this “back-stack”, since they are just components of Activities. However, you can specify that a transaction should include the Fragment change as part of the stack navigation by calling FragmentTransaction#addToBackStack() as part of your transaction (e.g., right before you commit()): getSupportFragmentManager().beginTransaction() .add(detailFragment, &quot;detail&quot;) // Add this transaction to the back stack .addToBackStack(null) .commit(); Note that the “back” button will cause the entire transaction to “reverse”. Thus if you performed a remove() then an add() (e.g., via a replace()), then hitting “back” will cause the the previously added Fragment to be removed and the previously removed Fragment to be added. FragmentManager also includes numerous methods for manually manipulating the back-stack (e.g., “popping” off transactions) if you want to include custom navigation elements such as extra “back” buttons. 6.3 Dialogs We have previously provided feedback to users via simple pop-ups such as Toasts or Snackbars. However, sometimes you would like to show a more complex “pop-up” View—perhaps one that requires additional interaction. A Dialog20 is a “pop-up” modal (a view which doesn’t fill the screen) that either asks the user to make a decision or provides some additional information. At it’s most basic, Dialogs are similar to the window.alert() function and its variants used in JavaScript. There is a base Dialog class, but almost always we use a pre-defined subclass instead (similar to how we’ve use AppCompatActivity). AlertDialog21 is the most common version: a simple message with buttons you can respond with (confirm, cancel, etc). We don’t actually instantiate an AlertDialog directly (in fact, it’s constructors are protected so inaccessible to us). Instead we use a helper factory class called an AlertDialog.Builder. There are a number of steps to use a builder to create a Dialog: Instantiate a new builder for this particular dialog. The constructor takes in a Context under which to create the Dialog. Note that once the builder is initialized, you can create and recreate the same dialog with a single method call—that’s the benefits of using a factory. Call “setter” methods on the builder in order to specify the title, message, etc. for the dialog that will appear. This can be hard-coded text or a reference to an XML String resource (as a user-facing String, the later is more appropriate for published applications). Each setter method will return a reference to the builder, making it easy to chain them. Use appropriate setter methods to specify callbacks (via a DialogInterface.OnClickListener) for individual buttons. Note that the “positive” button normally has the text &quot;OK&quot;, but this can be customized. Finally, actually instantiate the AlertDialog with the builder.create() method, using the show() method to make the dialog appear on the screen! AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(&quot;Alert!&quot;) .setMessage(&quot;Danger Will Robinson!&quot;); builder.setPositiveButton(&quot;I see it!&quot;, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int id) { // User clicked OK button } }); AlertDialog dialog = builder.create(); dialog.show(); An important part of learning to develop Android applications is being able to read the API to discover effective options. For example, can you read the AlertDialog.Builder API and determine how to add a “cancel” button to the alert? While AlertDialog is the most common Dialog, Android supports other subclasses as well. For example, DatePickerDialog and TimePickerDialog provide pre-defined user interfaces for picking a date or a time respectively. See the Pickers guide for details about how to utilize these. DialogFragments The process described above will create and show a Dialog, but that dialog has a few problems in how it interacts with the rest of the Android framework—namely with the lifecycle of the Activity in which it is embedded. For example, if the device changes configurations (e.g., is rotated from portrait to landscape) then the Activity is destroyed and re-created (it’s onCreate() method will be called again). But if this happens while a Dialog is being shown, then a android.view.WindowLeaked error will occur and the Dialog is lost! To avoid these problems, we need to have a way of giving that Dialog its own lifecycle which can interact with the the Activity’s lifecycle… sort of like making it a modular piece of an Activity… that’s right, we need to make it a Fragment! Specifically, we will use a subclass of Fragment called DialogFragment, which is a Fragment that displays as a modal dialog floating above the Activity (no extra work needed). Just like with the previous Fragment examples, we’ll need to create our own subclass of DialogFragment. It’s often easiest to make this a nested class if the Dialog won’t be doing a lot of work (e.g., shows a simple confirmation). Rather than specifying a Fragment layout through onCreateView(), we can instead override the onCreateDialog() callback to specify a Dialog object that will provide the view hierarchy for the Fragment. This Dialog can be created with the AlertDialog.Builder class as before! public static class MyDialogFragment extends DialogFragment { public static HelloDialogFragment newInstance() { Bundle args = new Bundle(); HelloDialogFragment fragment = new HelloDialogFragment(); fragment.setArguments(args); return fragment; } public Dialog onCreateDialog(Bundle savedInstanceState) { AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); //... AlertDialog dialog = builder.create(); return dialog; } } Finally, we can actually show this DialogFragment by instantiating it (remember to use a newInstance() factory method!) and then calling the show() method on it to make it show as a Dialog. The show() method takes in a FragmentManager used to manage this transaction. By using a DialogFragment, it is possible to change the device configuration (rotate the phone) and the Dialog is retained. Here’s the other neat trick: a DialogFragment is just a Fragment. That means we can use it anywhere we normally used Fragments… including embedding them into layouts! For example if you made the DetailsFragment subclass DialogFragment instead of Fragment, it would be able to be used in the exact same as before. It’s still a Fragment, just with extra features—one of which is a show() method that will show it as a Dialog! Use setStyle(DialogFragment.STYLE_NO_TITLE, android.R.style.Theme_Holo_Light_Dialog) to make the Fragment look a little more like a dialog. The truth is that Dialogs are not very commonly used in Android (compare to other GU systems). Apps are more likely to just dynamically change the Fragment or Activity being shown, rather than interrupt the user flow by creating a pop-up modal. And 80% of the Dialogs that are used are AlertDialogs. Nevertheless, it is worth being familiar with this process and the patterns it draws upon! https://developer.android.com/images/fundamentals/fragments.png↩ https://developer.android.com/images/fragment_lifecycle.png↩ https://developer.android.com/reference/android/support/v4/app/FragmentTransaction.html↩ http://developer.android.com/images/fundamentals/diagram_backstack.png↩ https://developer.android.com/guide/topics/ui/dialogs.html↩ https://developer.android.com/reference/android/support/v7/app/AlertDialog.html↩ "],
["intents.html", "Lecture 7 Intents 7.1 Intents for Another Activity (Explicit) 7.2 Intents for Another App (Implicit) 7.3 Intents for a Response 7.4 Listening for Intents 7.5 Broadcasts and Receivers 7.6 Menus 7.7 An Intent Example: SMS", " Lecture 7 Intents This lecture discusses how to use Intents to communicate between different Activities and Applications. The Intent system allows Activities to communicate, even though they don’t have references to each other (and thus we can’t just call a method on them). This lecture references code found at https://github.com/info448/lecture07-intents. Note that you will need to have a working camera on your device for this demo. To enable the camera in the emulator, use the Tools &gt; Android &gt; AVD menu to modify the emulator, and select “webcam” for the front camera option. Confirm that it is enabled by launching the Camera app. An Intent is a message that is sent between app components, allowing them to communicate! Most object communication we do is via direct method call; you have a reference to an Object and then you call a method on it. We’ve also seen event callbacks, where on an event one of our callbacks gets executed by the system—but this is really just a wrapper around direct method call via the Observer pattern. Intents work a bit differently: they allow us to create an object that can be “given” to another component (read: Activity), who can then respond upon receiving it. This is similar to an event callback, but working at a slightly higher system level. Intents were previously introduced in Lecture 3. But to reiterate: you can think of Intents as like letters you’d send through the mail: they are addressed to a particular target (e.g., another Activity—more properly a Context), and have room for some data called extras to go inside (held in a Bundle). When the envelope arrives, the recipient can get that data out and do something with it… and possibly send a response back. Note that there are couple of different kinds of Intents; we’ll go through examples of each. 7.1 Intents for Another Activity (Explicit) The most basic kind of Intent is an Intent sent to a specific Activity/Context, such as for telling that Activity to open. This was the same type of Intent introduced in Lecture 3. // context, target Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivity(intent); We instantiate the Intent (specifying the Contextit should be delivered from and the Class it should be delivered to), and then use that message to start an Activity by delivering the intent via startActivity(). The startActivity() method effectively means “this is an Intent used to launch an Activity: whoever receives this Intent should start!” You can almost think of it as saying that the letters should be delivered to the “start activity” mailbox. This type of Intent is called an Explicit Intent because we’re explicit about what target we want to receive it. It’s a letter to a specific Activity. Extras We can also specify some extra data inside our envelope. These data are referred to as Extras. This is a Bundle (a set of primitive key-value pairs) that we can use to pass limited information around! intent.putExtra(&quot;package.name.key&quot;,&quot;value&quot;); The Android documentation notes that best practice is to include the full package name in Bundle keys, so avoid any collisions or misreading of data (since Intents can move outside of the Application). There are also some pre-defined key values (constants) that you can and will use in the Intent class. We can then get the extras from the Intent in the Activity that receives it: //in onCreate() Bundle extras = getIntent().getExtras(); //All activities are started with an Intent! String value = extras.getString(&quot;key&quot;); So we can have Activities communicate, and even share information between them! Yay! 7.2 Intents for Another App (Implicit) We can send Intents to our own Activities, but we can even address them to other applications. When calling on other apps, we usually use Implicit Intents. This is a little bit like letters that have weird addresses, but still get delivered. “For that guy at the end of the block with the red mailbox.” An Implicit Intent includes an Action and some Data. The Action says what the target should do with the intent (a Command), and the Data gives more detail about what to run that action on. Actions can be things like ACTION_VIEW to view some data, or ACTION_PICK to choose an item from a list. See a full list under “Standard Action Activities”. ACTION_MAIN is the most common (just start the Activity as if it were a “main” launching point). So when we don’t specify anything else, this is used! Data gives detail about what to do with the action (e.g., the Uri to VIEW or the Contact to DIAL). Extras then support this data! For example, if we specify a DIAL action, then we’re saying that we want our Intent to be delivered to an application that is capable of dialing a telephone number. If there is more than one app that supports this action, the user will pick one! This is key: we’re not saying exactly what app to use, just what kind of functionality we need to be supported! It’s a kind of abstraction! Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(&quot;tel:206-685-1622&quot;)); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } Here we’ve specified the Action (ACTION_DIAL) for our Intent, as well as some Data (a phone number, converted into a Uri). The resolveActivity() method looks up what Activity is going to receive our action—we check that it’s not null before trying to start it up. This should allow us to “dial out” ! Note that we can open up all sorts of apps. See Common Intents22 for a list of common implicit events (with useful examples!). 7.3 Intents for a Response We’ve been using Intents to start Activities, but what if we’d like to get a result back from the Activity? That is, what if we want to look up a Contact or take a Picture, and then be able to use the Contact’s number or show the Picture? To do this, we’re going to create Intents in the same way, but use a different method to launch them: startActivityForResult(). This will launch the resolved Activity. But once that Action is finished, the launched Activity will send another Intent back to us, which we can then react to in order to handle the result. This is a bit like including an “RSVP” note in a letter! For fun, let’s do it with the Camera—we’ll launch the Camera to take a picture, and then get the picture and show it in an ImageView we have. Note that your Emulator will need to have Camera emulation on! static final int REQUEST_IMAGE_CAPTURE = 1; private void dispatchTakePictureIntent() { Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(getPackageManager()) != null) { startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE); } } We start by specifying an Intent that uses the MediaStore.ACTION_IMAGE_CAPTURE action (the action for “take a still picture and return it”). We will then send this Intent for a result, similar to other ImplicitIntents. We also include a second argument: a “request code”. A request code is used to distinguish this Intent from others we may send (kind of like a tag). It let’s us know that the Result Intent (the “RSVP”) is for our “took a picture” letter, and not for some other Intent we sent. Note that we could pass an Extra for where we want to save the large picture file to. However, we’re going to leave that off and just work with the thumbnail for this demonstration. See the guide23 for details; if time we can walk through it! In order to handle the “response” Intent, we need to provide a callback that will get executed when that Intent arrives. This callback is called onActivityResult(). @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) { Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get(&quot;data&quot;); ImageView imageView = (ImageView) findViewById(R.id.img_thumbnail); imageView.setImageBitmap(imageBitmap); } } We can get information about the Intent we’re receiving from the params, including which Intent let to the result (the requestCode and the status of that request (the responseCode). We can get access to the returned data (e.g., the image) by getting the &quot;data&quot; value from the extras. Note that this is a Bitmap, which is the Android class representing a raster image. We’ll play with Bitmaps more in a couple weeks, because I like graphics. 7.4 Listening for Intents We’re able to send implicit Intents that can be heard by other Apps, but what if we wanted to receive Implicit Intents ourselves? What if we want to be able to handle phone dialing?! In order to receive an Implicit Intent, we need to declare that our Activity is able to handle that request. Since we’re specifying an aspect of our application, we’ll do this in the Manifest using what is called an &lt;intent-filter&gt;. The idea is that we’re “hearing” all the intents, and we’re “filtering” for the ones that are relevant to us. Like sorting out the junk mail. An &lt;intent-filter&gt; tag is nested inside the element that it applies to (e.g., the &lt;activity&gt;). In fact, you can see there is already one there: that responds to the MAIN action sent with the LAUNCHER category (meaning that it responds to Intents from the app launcher). Similarly, we can specify three “parts” of the filter: a &lt;action android:name=&quot;action&quot;&gt; filter, which describes the Action we can respond to. a &lt;data ...&gt; filter, which specifies aspects of the data we accept (e.g., only respond to Uri’s that look like telephone numbers) a &lt;category android:name=&quot;category&quot;&gt; filter, which is basically a “more information” piece. You can see the “Standard Categories” in the documentation. Note that you must include the DEFAULT category to receive Implicit Intents. This is the category used by startActivity() and startActivityForResult(). Note that you can include multiple actions, data, and category tags. You just need to make sure that you can handle all possible combinations selected from each type (they are “or” not “and” filters!) Responding to that dial command: &lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.DIAL&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;tel&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; You can see many more examples in the Intent documentation. 7.5 Broadcasts and Receivers There is one other kind of Intent I want to talk about today: Broadcasts. A broadcast is a message that any app can receive. Unlike Explicit and Implicit Intents, broadcasts are heard by the entire system—anything you “shout” with a broadcast is publicly available (so think about security concerns when using these!) To extend the snail mail metaphor, these are mass mailings perhaps. Other than who receives them, broadcasts work the same as normal Implicit Intents! We create an Intent with an Action and Data (and Category and Extras…). But instead of using the startActivity() method, we use the sendBroadcast() method. That intent can now be heard by all Activities on the phone. We’ll skip a demo for lack of time and motivation… but we will generate broadcasts later in the course. Indeed, more common than sending broadcasts will be receiving broadcasts; that is, we want to listen and respond to System broadcasts that are produced (things like power events, wifi status, etc). This would also include listening for things like incoming phone calls or text messages! We can receive broadcasts by using a BroadcastReceiver. This is a base class that is used by any class that can receive broadcast Intents. We subclass it and implement the onReceive(Context, Intent) callback in order to handle when broadcasts are received. public void onReceive(Context context, Intent intent) { Log.v(&quot;TAG&quot;, &quot;received! &quot;+intent.toString()); else if(intent.getAction() == Intent.ACTION_BATTERY_LOW){ Toast.makeText(context, &quot;Battery is low!&quot;, Toast.LENGTH_SHORT).show(); } } While we can use Android Studio to produce this; we’re going to make it by hand to see all the steps. But in order to register our receiver (so that intents go past its desk), we also need to specify it in the Manifest. We do this by including a &lt;receiver&gt; attribute inside our &lt;application&gt;. Note that this is not an Activity, but a separate component! We can put an &lt;intent-filter&gt; inside of this to filter for broadcasts we care about. &lt;receiver android:name=&quot;.PowerReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.ACTION_POWER_CONNECTED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.ACTION_POWER_DISCONNECTED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.BATTERY_CHANGED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.BATTERY_OKAY&quot; /&gt; &lt;!-- no category because not for an activity! --&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; We can test these power events easily using the latest version of the emulator. In the “extra options” button (the three dots at the bottom) in the emulator’s toolbar, we can get to the Battery tab where we can effectively change the battery status of the device (which our app can respond to!). Remember to “disconnect” from the AC Charger! We can also register these receivers in code (rather than in the manifest). This is good for if we only want to temporarily listen for some kind of events, or if we want to determine the intent-filter on the fly: IntentFilter batteryFilter = new IntentFilter(); batteryFilter.addAction(Intent.ACTION_BATTERY_LOW); batteryFilter.addAction(Intent.ACTION_BATTERY_OKAY); batteryFilter.addAction(Intent.ACTION_POWER_CONNECTED); batteryFilter.addAction(Intent.ACTION_POWER_DISCONNECTED); this.registerReceiver(new PowerReceiver(), batteryFilter); We’re dynamically declaring an intent-filter as well! This can be used not just for BroadcastReceivers, but Activities too, if you dynamically want to change if an Activity can receive an Intent. 7.6 Menus Intents let us perform all kinds of communications and actions. But to manage all these options, it would help to introduce some more user interface components—and so in this section we’ll talk about Menus. Menus are primarily accessed through the App Bar a.k.a. the Action Bar. This acts as the sort of “header” for your app, providing a dedicated space for navigation and interaction (e.g., through menus). The ActionBar24 is a specific type of Toolbar that is most frequently used as the App Bar, offering a particular “look and feel” common to Android applications. For this reason “App Bar” and “Action Bar” are often use interchangeably. However, it is possible to include Toolbars (and by extension, menus) wherever you want in a layout. See Setting up the App Bar for details. The main use for the Action Bar is a place to hold Menus. A Menu (specifically, an options menu) is a set of items (think: buttons) that appear in the Action Bar. Menus can be specified both in the Activity and in a Fragment; if declared in both places, they are combined into a single menu in the Action Bar. This allows you to easily make “context-specific” options menus that are only available for an appropriate Fragment, while keeping Fragments modular and self-contained. To give a Fragment a menu, call setHasOptionsMenu(true) in the Fragment’s onCreate() method. Fun fact: before API 11, options menus appeared as buttons at the bottom of the screen! Menus, like all other user-facing elements, are defined as XML resources, specifically of type menu. You can create a new menu resource through Android studio using File &gt; New &gt; Android resource file and then choosing the Menu Resource type. This will create an XML file with a main &lt;menu&gt; element. Options can be added to the menu by specifying child XML elements, particularly &lt;item&gt; elements. Common &lt;item&gt; attributes include: android:id: a unique id used to refer to the specific option in the Java code android:title (required attribute): the text to display for the option. As user-facing text, the content should ideally be defined as an XML String resource. app:showAsAction: whether or not the option should be listed in the Action Bar, or collapsed under a “three-dots” button. Note when working with the appcompat library, this option uses the app namespace (instead of android); you will need to include this namespace in the &lt;menu&gt; with the attribute xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;. android:icon: an image to use when showing the option as a button on the menu. You can use one of the many icons built into the Android, referenced as &quot;@android:drawable/ic_*&quot;. Android Drawables25 includes the full list, though not all drawables are publicly available through Android Studio. android:orderInCategory: used to order the item in the menu (or in a group). This acts as a “priority” (default 0; low comes first). Such prioritizing can be useful if you want to add suggestions about whether Fragment options should come before or after the Activity options. See the Menu resources guide26 for the full list of options! It is possible to include one level of sub-menus (a &lt;menu&gt; element inside an &lt;item&gt; element). Menu items can also be grouped together by placing them inside of a &lt;group&gt; element. All items in a group will be shown or hidden together, and can be further ordered within that group. Grouped icons can also be made checkable. In order to show the menu in the running application, we need to tell the Action Bar which menu resource it should use (there may be a lot of resources). To do this, we override the onCreateOptionsMenu() callback in the Activity or Fragment, and then use the component’s MenuInflater object to expand the menu: public boolean onCreateOptionsMenu(Menu menu) { MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.main_menu, menu); //inflate into this menu return true; } This procedure is similar in concept to how a Fragment’s onViewCreated() method would inflate the Fragment into the Activity. In this case, the Menu is being inflated into the Action Bar. We can respond to the menu items being selected by overriding the onOptionsItemSelected() callback. By convention, we use a switch on the item.getItemId() to determine what item was selected, and then act accordingly. public boolean onOptionsItemSelected(MenuItem item) { switch(item.getItemId()){ case R.id.menu_item1 : //do thing; return true; default: return super.onOptionsItemSelected(item); } } On default (if the item selected isn’t handled by any cases), we pass the callback up to super for “higher-level” components to check. For example, if a the menu option isn’t handled by the Fragment (because the Fragment didn’t add it), the event can be passed up through the Framework for eventually handling by the Activity (who did add it). This method should return true if the selection even has been handled (and thus should not be considered by anyone else). Return false if you want other components (e.g., other Fragments) to be able to respond to this option as well. There are many other menu items that can be placed on Action Bar as well. We can also add Action Views that provide more complex interactions than just clicking buttons (for example, including a search bar). An Action Provider (like ShareActionProvider) is an action with its own customized layout, expanding into a separate View when clicked. We wil discuss how to utilize these features in a future lecture. Action Views In addition to these simple buttons, we can also include more complex expandable widgets called Action Views. The most common of these is a SearchView, which puts a “search field” in the App Bar! However, as a slightly simpler demo, we’ll set up a ShareActionProvider, which automatically provides a drop-down menu item with a complete list of apps that we can share our data with (e.g., the “quick share with these social media sites” button)y. For reference, I recommend looking at the class documentation for how to set this up (it’s much clearer than the training docs). We’ll start by adding another item to our menu’s XML. This will look like other items, except it will have an extra field app:actionProviderClass indicating that this item is an Action Provider (a widget that provides some actions) &lt;item android:id=&quot;@+id/menu_item_share&quot; android:title=&quot;Share&quot; app:showAsAction=&quot;ifRoom&quot; app:actionProviderClass=&quot;android.support.v7.widget.ShareActionProvider&quot; /&gt; We’ll then add the item to our menu in onCreateOptionsMenu() MenuItem item = menu.findItem(R.id.menu_item_share); ShareActionProvider shareProvider = (ShareActionProvider)MenuItemCompat.getActionProvider(item); Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(&quot;tel:206-685-1622&quot;)); shareProvider.setShareIntent(intent); We get access to the item using findItem() (similar to findViewById()), and then cast it to a ShareActonProvider (make sure you’re using the support version!) We can then specify an Implicit Intent that we want that “Share Button” to be able to perform. This would commonly use the ACTION_SEND action (like for sharing a picture or text), but we’ll use the DIAL action because we have a couple of dialers but don’t actually have many SEND responders on the emulator. The Menu item will then list a dropdown with all of the different Activities that resolve to handling that implicit intent! And we’ve now deeply combined Intents and Menus! Context Menus In addition to options menus available in the Action Bar, we can also specify contextual menus that pop up when the user long-presses on an element. This works similarly to using an options menu, but with a different set off callbacks: When setting up the the View layout (e.g., in an Activity’s onCreate()), we specify that an element has a context menu using the registerForContextMenu() method, passing it the View we want to be able to create the menu for. Specify the context menu to use through the onCreateContextMenu() callback. This works exactly like setting up an options menu. In fact, a context menu can even use the same menu as an options menu! This reuse is one of the advantages of defining the user interface as XML. And mirroring the options menu, respond to context menu items being selected with the onContextItemSelected() callback. This section has provided a very brief introduction to menus, but there are many more complex interactions that they support. I highly recommend that you read through the guide in order to learn what features may be available. If you ever are using an app and wonder “how did they add this interface feature?”, look it up! There is almost always a documented procedure and example for providing that kind of component. 7.7 An Intent Example: SMS An optional extra example, for the curious. One specific use of Intents is when working with text messages (SMS, Short Messaging Service, the most popular form of data communication in the world). In particular, Intents are used to send and receive SMS messages (you can get a list of messages already received using a ContentProvided, described in a later lecture). Important note: the SMS APIs changed drastically in KitKat (API 19). So we’re going to make sure that is our minimum so we can get all the helpful methods and support newer stuff (check gradle to confirm!). The main thing to note about sending SMS is that as of KitKat, each system has a default messaging client—which is the only app that can actually send messages. Luckily, the API lets you get access to that messaging client’s services in order to send a message through it: SmsManager smsManager = SmsManager.getDefault(); smsManager.sendTextMessage(&quot;5554&quot;, null, &quot;This is a test message!&quot;, null, null); // target, message 5554 is the default “phone number” of the emulator (the port it is running on). We will also need permission: &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot; /&gt; (in the Manifest) You can see that this works by looking at the inbox in the Messages app… but there is another way as well! If you look at the documentation for this method27, you can see that the last two parameters are for PendingIntents: one for when messages are sent and one for when messages are delivered. What’s a PendingIntent? The details are not super readable… It’s basically a wrapper around an Intent that we give to another class. Then when that class receives our PendingIntent and reacts to it, it can run the Intent (command) we sent it with as if that Activity were us (whew). This is like when you ask a professor for a letter of recommendation, and you give them the stamped envelope (which you should always do!). When they get the packet, then can then send their letter using your envelop and stamp! Alternatively: “I am mailing you my car keys, when you get them you can come pick me up”. So the idea is we specify what Intent should be delivered when the message is finished being sent (that Intent becomes “pending”). Effectively, this let’s us send Intents in response to some other kind of event. Let’s go ahead and set one up: public static final String ACTION_SMS_STATUS = &quot;edu.uw.intentdemo.ACTION_SMS_STATUS&quot;; //... Intent intent = new Intent(ACTION_SMS_STATUS); PendingIntent pendingIntent = PendingIntent.getBroadcast(MainActivity.this, 0, intent, 0); smsManager.sendTextMessage(&quot;5554&quot;, null, &quot;This is a test message!&quot;, pendingIntent, null); We’re doing a couple of steps here: We’re defining our own custom Action. It’s just a String, but name-spaced to avoid conflicts We then create an Implicit Intent for this action And then create a PendingIntent. We’re using the getBroadcast() method to specify that the Intent should be sent via a Broadcast (c.f. getActivity() for startActivity()). First param is the Context that should send the Intent, then a request code (e.g., for result callbacks if we wanted), then the Intent we want to be pending, and finally any extra flags (none for now). We can then have our BroadcastReceiver respond to this Intent just like any other one! if(intent.getAction() == MainActivity.ACTION_SMS_STATUS) { if (getResultCode() == Activity.RESULT_OK) { Toast.makeText(context, &quot;Message sent!&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(context, &quot;Error sending message&quot;, Toast.LENGTH_SHORT).show(); } } Don’t forget to add our custom intent to the &lt;intent-filter&gt;! We’ll see more with PendingIntents in the next chapter when we talk about notifications. https://developer.android.com/guide/components/intents-common.html↩ http://developer.android.com/training/camera/photobasics.html#TaskPath↩ http://developer.android.com/reference/android/support/v7/app/ActionBar.html↩ http://androiddrawables.com/↩ https://developer.android.com/guide/topics/resources/menu-resource.html↩ https://developer.android.com/reference/android/telephony/SmsManager.html↩ "],
["notifications-settings.html", "Lecture 8 Notifications &amp; Settings 8.1 Dialogs 8.2 Notifications 8.3 Settings", " Lecture 8 Notifications &amp; Settings This lecture discusses some additional user interface components common to Android applications: Notifications, Settings Menus. and Dialogs This lecture aims to provide exposure rather than complete coverage to these concepts; for more options and examples, see the official Android documentation. This lecture references code found at https://github.com/info448/lecture08-notifications-settings. 8.1 Dialogs We have previously provided feedback to users via simple pop-ups such as Toasts or Snackbars. However, sometimes you would like to show a more complex “pop-up” View—perhaps one that requires additional interaction. A Dialog28 is a “pop-up” modal (a view which doesn’t fill the screen) that either asks the user to make a decision or provides some additional information. At their most basic, Dialogs are similar to the window.alert() function and its variants used in JavaScript. There is a base Dialog class, but almost always we use a pre-defined subclass instead (similar to how we’ve use AppCompatActivity). AlertDialog29 is the most common version: a simple message that includes buttons you can respond with (confirm, cancel, etc). We don’t actually instantiate an AlertDialog directly (in fact, it’s constructors are protected so inaccessible to us). Instead we use a helper factory class called an AlertDialog.Builder. There are a number of steps to use a builder to create a Dialog: Instantiate a new builder for this particular dialog. The constructor takes in a Context under which to create the Dialog. Note that once the builder is initialized, you can create and recreate the same dialog with a single method call—that’s the benefit of using a factory. Call “setter” methods on the builder in order to specify the title, message, etc. for the dialog that will appear. This can be hard-coded text or a reference to an XML String resource (as a user-facing String, the later is more appropriate for published applications). Each setter method will return a reference to the builder, making it easy to chain them. Use appropriate setter methods to specify callbacks (via a DialogInterface.OnClickListener) for individual buttons. Note that the “positive” button normally has the text &quot;OK&quot;, but this can be customized. Finally, actually instantiate the AlertDialog with the builder.create() method, using the show() method to make the dialog appear on the screen! AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(&quot;Alert!&quot;) .setMessage(&quot;Danger Will Robinson!&quot;); builder.setPositiveButton(&quot;I see it!&quot;, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int id) { // User clicked OK button } }); AlertDialog dialog = builder.create(); dialog.show(); An important part of learning to develop Android applications is being able to read the API to discover effective options. For example, can you read the AlertDialog.Builder API and determine how to add a “cancel” button to the alert? While AlertDialog is the most common Dialog, Android supports other subclasses as well. For example, DatePickerDialog and TimePickerDialog provide pre-defined user interfaces for picking a date or a time respectively. See the Pickers guide for details about how to utilize these. DialogFragments The process described above will create and show a Dialog, but that dialog has a few problems in how it interacts with the rest of the Android framework—namely with the lifecycle of the Activity in which it is embedded. For example, if the device changes configurations (e.g., is rotated from portrait to landscape) then the Activity is destroyed and re-created (it’s onCreate() method will be called again). But if this happens while a Dialog is being shown, then a android.view.WindowLeaked error will occur and the Dialog is lost! To avoid these problems, we need to have a way of giving that Dialog its own lifecycle which can interact with the the Activity’s lifecycle… sort of like making it a modular piece of an Activity… That’s right, we need to make it a Fragment! Specifically, we will use a subclass of Fragment called DialogFragment, which is a Fragment that displays as a modal dialog floating above the Activity (no extra work needed). Just like with previous Fragment examples, we’ll need to create our own subclass of DialogFragment. It’s often easiest to make this a nested class if the Dialog won’t be doing a lot of work (e.g., shows a simple confirmation). Rather than specifying a Fragment layout through onCreateView(), we can instead override the onCreateDialog() callback to specify a Dialog object that will provide the view hierarchy for the Fragment. This Dialog can be created with the AlertDialog.Builder class as before! public static class MyDialogFragment extends DialogFragment { public static MyDialogFragment newInstance() { Bundle args = new Bundle(); MyDialogFragment fragment = new MyDialogFragment(); fragment.setArguments(args); return fragment; } public Dialog onCreateDialog(Bundle savedInstanceState) { AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); //... AlertDialog dialog = builder.create(); return dialog; } } Finally, we can actually show this DialogFragment by instantiating it (remember to use a newInstance() factory method!) and then calling the show() method on it to make it show as a Dialog. The show() method takes in a FragmentManager used to manage this transaction. By using a DialogFragment, it is possible to change the device configuration (rotate the phone) and the Dialog is retained. Here’s the other neat trick: a DialogFragment is just a Fragment. That means we can use it anywhere we normally used Fragments… including embedding them into layouts! For example if you made a “DetailsFragment” subclass DialogFragment instead of Fragment, it would be able to be used in the exact same as before. It’s still a Fragment, just with extra features—one of which is a show() method that will show it as a Dialog! Use setStyle(DialogFragment.STYLE_NO_TITLE, android.R.style.Theme_Holo_Light_Dialog) to make the Fragment look a little more like a dialog. The truth is that Dialogs are not very commonly used in Android (compare to other GU systems). Apps are more likely to just dynamically change the Fragment or Activity being shown, rather than interrupt the user flow by creating a pop-up modal. And 80% of the Dialogs that are used are AlertDialogs. Nevertheless, it is worth being familiar with this process and the patterns it draws upon! 8.2 Notifications We can let the user know what is going on with the app by popping up a Toast or Dialog, but often we want to notify the user of something outside of the normal Activity UI (e.g., when the app isn’t running, or without getting in the way of other interactions). To do this, we can use Notifications30. These are specialized views that show up in the notification area (the icons at the top of the operating system display) and in the system’s notification drawer, which the user can get to at any point—even when outside the app—by swiping down on the screen. Android’s documentation for UI components is overall quite thorough and usable (after all, Google wants to make sure that developers can build effective apps, thereby making the platform worthwhile). And because there are so many different UI elements and they change all the time, in order to do real-world Android development you need to be able to read, synthesize, and apply this documentation. As such, this lecture will demonstrate how to utilize that documentation and apply it to create notifications. We will follow through the documentation to add a feature that when we click on the “notify” button, a notification will appear that reports how many times we’ve clicked that button. To follow along this, open up the Notifications documentation at https://developer.android.com/guide/topics/ui/notifiers/notifications.html. Looking at the documentation we see an overview to start. There is also a link to the Notification Design Guide, which is a good place to go to figure out how to design effective notifications. There is a lot of text about how to make a Notification… I personally prefer to work off of sample code, modifying it until I have something that does what I want. So I suggest scrolling down slowly until you find an example you can copy/paste in, or at least reference. Then you can scroll back up later to get more detail about how that code works. The table of contents is also useful for this. Eventually you’ll find a subsection “Creating a Simple Notification”, which sounds like a great place to start! The first part of creating this Notification is using NotificationCompat.Builder (use the v4 support version; the v7 is now deprecated). We saw this kind of Builder class with AlertBuilder, and the same concept applies here: it is a class used to construct the Notification for us. We call setters to specify the properties of the Notification. Going through those settings: I don’t have a drawable resource to use for an icon, which makes me want to not include the icon specification. However, scrolling back up will reveal that a notification icon is required, so we will need to make one. We can produce an new Image Asset for the notification icon (File &gt; New &gt; Image Asset), just as we did previously with launcher icons and Material icons. Specify the “type” as Notification, give it an appropriate name, and pick a clipart of your choosing. We set the “title” and the content for the notification. Starting in API 26 (Oreo), we also are required to specify a notification channel (called a “notification category” in the user interface). These are used to help users manage notifications by grouping them together and allowing users to control the settings of that group—such as whether they are shown, what sounds they play, etc. Notification channels are identified by a String ID that is unique within the package. TODO…. The next line makes an Intent. We’ve done that too… but why create an Intent for a Notification? If we scroll up and look where Intent is referenced, we can find out about Notification Actions, which specify what happens when the user clicks on the Notification. Usually this opens the relevant application, and since Intents are messages to open Activities, it makes sense that clicking a Notification would send an Intent. The example Notification is also using the a TaskStackBuilder to construct an “artificial” backstack. This is used to specify, for example, that if the user clicks on the Notification and jumps to a “detail” view (say), they can still hit the back button to return to the “master” view, as if they had navigated to the “detail” view from a normal usage of the application. We build this backstack not just with methods, but by integrating with the “parent-child” relationship we’ve otherwise set up between Activities (e.g., in the Manifest). In the Manifest, we had specified that SecondActivity's parent is MainActivity. This is what gave us the nice back button in the ActionBar. These sequence of parentActivityName attributes form a hierarchy that will be the “back navigation hierarchy.” We add the “endpoint” of the hierarchy to the builder using addParentStack(MyResultActivity.class), and then finally put the Intent we actually want to use “on top” of the stack with addNextIntent(resultIntent). The TaskStackBuilder is then used to produce a [PendingIntent]((http://developer.android.com/reference/android/app/PendingIntent.html). What’s a PendingIntent? The details are not super readable… It’s basically a wrapper around an Intent that we give to another class. Then when that class receives our PendingIntent and reacts to it, it can run the Intent (command) we sent with it as if that Activity were us (whew). The Intent is “pending” delivery/activation by another service. This is like when you ask a professor for a letter of recommendation, and you give them the stamped envelope (which you should always do!). When they get the packet, then can then send their letter using your envelop and stamp! Alternatively: “I am mailing you my car keys, when you get them you should come pick me up”. The TaskStackBuilder produces a PendingIntent that “wraps” around the Intent we actually want to send when the notification is clicked. So when we select the notification, the Notification Drawer service can open up that PendingIntent packet, pull out the Intent we want to send, and then mail it off. And this Intent that the Notification Drawer sends is to wake up our Activity, and it is sent with our permissions (rather than the Drawer’s permissions), as if we had sent it ourselves! While it is possible to instantiate a PendingIntent directly, we instead get the PendingIntent by calling the TaskStackBuilder#getPendingIntent() method to build an appropriate object. Pass the method an ID to refer to that request (like we’ve done when sending Intents for Results), and a flag PendingIntent.FLAG_CURRENT_UPDATE so that if we re-issue the PendingIntent it update the existing one instead of replacing it with a new pending action. We can then assign that PendingIntent to the Notification builder (with setContentIntent()). Finally, we can use the NotificationManager (similar to the FragmentManager, SmsManager, etc.) to fetch the notification service (the “application” that handles all the notifications for the OS). We tell this manager to actually issue the built Notification object. We also pass the notify() method an ID number to refer to the particular Notification (not to the PendingIntent this time, but the Notification itself). Again, this will allow us to refer to and update that Notification later (as opposed to updating the PendingIntent for the Notification later). This allows us to have working Notifications! We can click the button to launch a Notification, and then click on the Notification to be taken to our app, which has a working back stack! We can also update this notification later, and it’s really straightforward: we simply re-issue a Notification with the same ID number, and it will “replace” the previous one! For example, we can have our text be based on some instance variable, and have the Notification track the number of clicks! You may notice that this notification doesn’t “pop up” in a way you might expect. In order for a notification to visually intrude upon the user, its priority must be high enough (it needs to be NotificationCompat.PRIORITY_HIGH or higher) and because it needs to use either sound or vibration (it needs to be really important to get a heads-up pop). We can make the Notification vibrate by using the setVibrate() method, passing it an array of times (in milliseconds) at which to turn vibration on and off. Pattern is [delay, vibrate, sleep, vibrate, sleep, ...] We can also assign a default sound with (e.g.) builder.setSound(Settings.System.DEFAULT_NOTIFICATION_URI); See the design guide for best practices on specifying Notification priority. As of API 26 (Oreo), the concept of “priority” has been deprecated in favor of “importance”. Importance is specified on a per-channel basis. See Creating a Notification Channel. (Note that you can use an if statement to check which API version the phone is running to determine which code to run!) As always, there are a number of other pieces/details we can specify, but I leave those to you to look up in the documentation. As the course focuses on development, this lecture references but does not discuss the UI Design guidelines. For example: what kind of text should you put in your Notification? When should you choose to use a notification? Android has lots of guidance on these questions in their design documentation. Major HCI and Mobile Design guidelines apply here as well (e.g., make actions obvious, give feedback, avoid irreversible actions, etc.). 8.3 Settings The last topic of this lecture is to support letting the user decide whether clicking the button should create notifications or not. For example, maybe sometimes the user just want to see Toasts! The cleanest way to support this kind of user preference is to create some Settings using Preferences. SharedPreferences Shared Preferences31 are one way that we can persist data in an application across application launches—that is, the data is stored on disk rather than just in memory, so will not be lost if the application is destroyed. SharedPreferences store key-value pairs of primitives (Strings, ints, etc), similar to what we’ve been putting in Bundles. This data will be stored across application sessions: if I save some data to the Preferences and close the app, it will be there when I come back. Preferences are stored in an XML File in the file system. Basically we save lists of key-value pairs as a basic XML tree in a plain-text file (similar to the values resource files we’ve created). Note that this is not a resource, rather it is a file that happens to also be structured as XML. SharedPreferences are not great for intricate or extensive structured data (since it only stores key-value pairs, and only primitives at that). Use other options for more complex data persistence, such as putting the data into a database or using the file system—both of which are discussed in later lectures. Even though they are called “Preferences”, they not just for “user preferences”! We can persist any small bits of primitive data in a SharedPreferences file. We can get access to a SharedPreferences file using the .getSharedPreferences(String, int) method. The first parameter String is the name of the SharedPreference file we want to access (we can have multiple XML files; just use getPreferences() to use a single default). The second parameter int is a flag about whether other apps should have access to that file. MODE_PRIVATE (0) is the default, MODE_WORLD_READABLE and MODE_WORLD_WRITEABLE are the other options. We can edit this XML file by calling .edit() on the SharedPreferences object to get a SharedPreferences.Editor, which is a Bundle-esque object we can put values into. We need to call .commit() on the editor to save our changes to the file system! Finally, we can just call get() methods on the SharedPreferences object in order to fetch data out of it! The second parameter of these methods is a default value for if a preference doesn’t exist yet, making it easy to avoid null errors. For practice, try saving the notification count in the Activity’s onStop() function, and retrieving it in onCreate(). This will allow you to persist the count even when the Activity is destroyed. Preference Settings While a SharedPreferences file acts a generic data store, it is called Shared Preferences because it’s most commonly used for “user preferences”—e.g., the “Settings” for an app. Yes, the term “preferences” can be used to mean either “shared preferences” or “user preferences” (or both if they are the same thing!) depending on the context. A “User Preference Menu” is a user-facing element, so we’ll want to define it as an XML resource. But we’re not going to try and create our own layout and interaction: instead we’re just going to define the list of Preferences32 themselves as a resource! We can create a new resource using Android Studio’s New Resource wizard. The “type” for this is actually just XML (generic), though our “root element” will be a &lt;PreferenceScreen&gt; (thanks intelligent defaults!). By convention, the preferences resource is named preferences.xml. Inside the &lt;PreferenceScreen&gt;, we add more elements: one to represent each preference we want to let the user adjust (or each “line” of the Settings screen). We can define different types of Preference objects, such as &lt;CheckBoxPreference&gt;, &lt;EditTextPreference&gt;, &lt;SwitchPreference&gt;, or &lt;ListPreference&gt; (for a dialog of radio buttons). There are a couple of other options as well; see the Preference base class. These elements should include the following XML attributes (among others): android:key the key to use when storing the preference in the SharedPreferences file android:title a user-visible name for the Preference android:defaultvalue a default value for the preference (use true or false for checkboxes). More options cam be found in the the Preference documentation. We can further divide these Preferences to organize them: we can place them inside a PreferenceCategory tag (with its own title and key) in order to group them together. Finally we can specify that our Preferences have multiple screens by nesting PreferenceScreen elements. This produces “subscreens” (like submenus): when we click on the item it will take us to the next screen. Note that a cleaner (but more labor-intensive) way to do this if you have lots of settings is to use preference-headers which allows for better multi-pane layouts… but since we’re not making any apps with that many settings this process is left as exercise for the reader. Once we have the Preferences all defined in XML, we just need to show them in our application! Since the Settings will be their own screen, we’ll need to make another Activity (though it won’t need a layout!). To actually render the Preferences XML, we’ll use the PreferenceFragment class (a specialized Fragment for showing lists of Preference objects); it’s usually easies to create this as a nested class in the Activity. For the Fragment, we don’t need to specify an onCreateView() method, instead we’re just going to load that Preference resource in the onCreate() method using addPreferencesFromResource(R.xml.preferences). This will cause the PreferenceFragment to create the appropriate layout! For the Activity, we just need to have it load that Fragment via a FragmentTransaction: getFragmentManager().beginTransaction() .replace(android.R.id.content, new SettingsFragment()) .commit(); The Activity doesn’t even need to load a layout: just specify a transaction! But if we want to include other stuff (e.g., an ActionBar), we’d need to structure the Activity and its layout in more detail. Note that the container for our Fragment is android.R.id.content. This refers to the “root element” of the current View—basically what setContentView() is normally inflating into. There is a PreferenceActivity class as well, but the official recommendation is do not use it. Many of its methods are deprecated, and since we’re using Fragments via the support library, we should stick with the Fragment process. Finally, how do we interact with these settings? Here’s the trick: a preferences XML resource is automatically associated with a SharedPreferences file! And in fact, every time we adjust a setting in the PreferenceFragment, the values in that file are edited as well! In effect, the PreferenceFragment automatically edits the SharedPreferences based on the user interaction. We never need to write to the file ourselves, just read from it (and we read from it in the exact same way we read any other SharedPreferences file, as described above). The preference XML corresponds to the “default” SharedPreferences file, which we’ll access via: SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this); And then we have this object we can fetch data from with getString(), getBoolean(), etc. This will allow us to check the preferences before we show a notification! That’s the basics of using Settings. For more details see the documentation, as well as the design guide for best practices on how to organize your Settings. https://developer.android.com/guide/topics/ui/dialogs.html↩ https://developer.android.com/reference/android/support/v7/app/AlertDialog.html↩ https://developer.android.com/guide/topics/ui/notifiers/notifications.html↩ https://developer.android.com/guide/topics/data/data-storage.html#pref↩ https://developer.android.com/reference/android/preference/Preference.html↩ "],
["loaders.html", "Lecture 9 Providers and Loaders 9.1 Content Providers 9.2 Cursors 9.3 Loaders 9.4 Other Provider Actions", " Lecture 9 Providers and Loaders This lecture discusses how to access data from a Content Provider using a Loader. A Content Provider is an abstraction of a database or other data store, allowing us easily and systematically work with that data in Java (rather than in a separate data manipulation language such as SQL). A Loader is then used to efficiently perform this data access in the background (off the UI Thread), while also easily connecting that data to Views. This lecture discusses how to use a Loader to access the data in an existing Content Provider; a later lecture details how to create Content Providers from scratch. This lecture references code found at https://github.com/info448/lecture09-loaders. Note that this demo accesses the device’s User Dictionary, which is only available to general apps on API 22 (Lollipop) or earlier. This tutorial thus does not support all versions of Android. You can instead use an emulator running API 22 or earlier. 9.1 Content Providers The example starter code uses a ListView that shows a list of words. Recall that a ListView utilizes the model-view-controller architecture… and in this case, the “model” (data) is a hard-coded list of array of words. But there are other lists of words as well! Entire databases of words! Previous lectures have discussed how to use network requests to access online data APIs, but there are also databases (of words no less) built into your Android phone. For example, Android keeps track of the list of the spellings of “non-standard” words in what is called the User Dictionary. You can view this list on the device at Settings &gt; Language &amp; Input &gt; Personal Dictionary. You can even use this Settings interface to add new words to the dictionary (e.g., “embiggen”, “cromulent”, “covfefe”). Note that the User Dictionary keeps track of a database of words. You can think of this database as being like a single SQL table: it’s a set of entries (rows) each of which have some values (columns). The primary key of the table is named (by convention) ID. Since this data is stored in (essentially) a simple SQL table, it is possible for us to access and modify it programmatically&amp;mash;moreover, the Android framework allows us to do this without needing to know or write SQL! For example, we can access this list of words in order to show them in the ListView. While you don’t need to know SQL to utilize a built-in database like the User Dictionary, it helps to have a passing familiarity with relational databases and their terminology to intuit about the organization of the data. To do this, we’ll need to request permission to access the database, just as we asked permission to access the Internet. Include the following in the Manifest: &lt;uses-permission android:name=&quot;android.permission.READ_USER_DICTIONARY&quot;/&gt; Although the words are stored in a database, we don’t know the exact format of this database (e.g., the exact table or column names, or even whether it is an SQL database or just a .csv file!). We want to avoid having to write code that only works with a specific format, especially as the words may be stored in different kinds of databases on different devices or across different versions of Android. (The Android framework does include support for working directly with a local SQLite database, as discussed in the next chapter). In order to avoid relying on the specific format of how some data is stored, Android offers an abstraction in the form of a Content Provider33. A Content Provider offers an interface to interact with structured data, whether that data is stored in a database, in a file, in multiple files, online, or somewhere else. You can thus think of “a Content Provider” as meaning “a data source” (e.g., the source/provider of content)! It is possible to create your own Content Providers (described in a later chapter), but this lecture focuses purely on utilizing existing Providers. All Content Providers (data sources) have a URI (Universal Resource Identifier, a generalization of a URL used for resources not necessarily on the Internet). It is possible to query this URI, similar in concept to how web APIs are accessed via queries to their URI endpoints. In particular, Content Provider URIs utilize the content:// protocol (instead of https://), since the their data is accessed as via “content requests” rather than “HTTP requests”. The URI for the Dictionary’s content is defined by the constant UserDictionary.Words.CONTENT_URI. We utilize constants to refer to URIs and paths to make it easier to refer to them and to generalize across devices that may have different directory structures. We are able to access this Content Provider via a ContentResolver. This class provides methods for accessing the data in a provider (represented as a ContentProvider object). Each Context has a singleton ContentResolver, which is accessed via the getContentResolver() method (note that for a Fragment, the Context is the containing Activity). The ContentResolver’s methods support the basic CRUD operations: insert() (create), query() (read), update(), and delete(). ContentResolver resolver = getContentResolver(); ContentResolver methods take multiple parameters, supporting the different options available in a generic SQL query. For example, consider the the query() method: getContentResolver().query( uri, // The content URI projection, // The an array of columns to return for each row selectionClause // Selection criteria (as an SQL WHERE clause) selectionArgs, // An array of values that can be injected into the selection clause sortOrder); // The sort order for the returned rows (as an SQL ORDER BY clause) This is basically a wrapper around an SQL SELECT statement! But each “part” of that statement are specified as parameter to this method. The projection is a String[] of all the “columns” (attributes) we want to fetch from the data source. This is what you’d put after SELECT in SQL. (Note we can pass in null to represent SELECT *, but that’s inefficient—better to give a list of everything). We can see what column names are available for the User Dictionary in UserDictionary.Words. Again, these are defined as constants! Be sure to always select the _ID primary key: it will be needed later! The other parameters can be used to customize the SELECT statement. The “selection” (WHERE) clause needs to parameters: the second are values that will be escaped against SQL injection attacks. Passing null for any of these parameters will cause the clause to be ignored: String[] projection = new String[] { UserDictionary.Words.WORD, UserDictionary.Words.FREQUENCY, UserDictionary.Words._ID }; resolver.query(UserDictionary.Words.CONTENT_URI, projection, null, null, null); So overall, the query is breaking apart the components SQL SELECT statement into different pieces as parameters to a method, so you don’t quite have to write the selection yourself. Moreover, this method abstracts the specific query language, allowing the same queries to be used on different formats of database (SQLite, PostgreSQL, files, etc). 9.2 Cursors The ContentResolver#query() method returns a Cursor. A Cursor provides an interface to the list of records in a database (e.g., those returned by the query). A Cursor also behaves like an Iterator in Java: it keeps track of which record is currently being accessed (e.g., what the i would be in a for loop). You can think of it as a “pointer” to a particular record, like the cursor on a screen. We call methods on the Cursor to specify which record we want it to “point” to, as well as to fetch values from the record object at that spot in the list. For example: cursor.moveToFirst(); //move to the first item String field0 = cursor.getString(0); //get the first field (column you specified) as a String String word = cursor.getString(cursor.getColumnIndexOrThrow(&quot;word&quot;)); //get the &quot;word&quot; field as a String cursor.moveToNext(); //go to the next item The nice thing about Cursors though is that they can easily be fed into AdapterViews by using a CursorAdapter (as opposed to the ArrayAdapter we’ve used previously). The SimpleCursorAdapter is a concrete implementation that is almost as easy to use as an ArrayAdapter: You instantiate a new SimpleCursorAdapter, passing it: A Context for loading resources A layout resource to inflate for each record A Cursor (which can be null) An array of column names to fetch from each entry in the Cursor (the projection, similar to before) A matching list of View resource ids (which should all be TextViews) to assign each column’s value to. This is the “mapping” that the Adapter will perform (from projection columns to TextView contents). Any additional option flags (0 means no flags, and is the correct option for us). adapter = new SimpleCursorAdapter( this, R.layout.list_item_layout, //item to inflate cursor, //cursor to show new String[] {UserDictionary.Words.WORD, UserDictionary.Words.FREQUENCY}, //fields to display new int[] {R.id.txt_list_item, R.id.txt_item_freq}, //where to display them 0); //flags Then we can use this adapter for the ListView in place of the ArrayAdapter! 9.3 Loaders In order to get the Cursor to pass into the adapter, we need to .query() the database. But we want to do this a lot in fact, every time the database updates, we’d like to be able to query it again so we can update the Adapter and have the changes show up! Additionally, accessing a database can be slow (it requires disk access, structuring and submitting SQL calls, and depending on the complexity of the database those queries can take time). Thus, as with network requests, we’d like to perform this query on a background thread so that it doesn’t block our application and cause it to stall. In order to automatically update your list with new data loaded on a background thread, we’re going to use a class called a Loader. This is basically a wrapper around ASyncTask (described in a later chapter), but one that lets you execute a background task repeatedly whenever the data source changes. In particular, Android provides a CursorLoader specifically used to load data from ContentProviders through Cursors—whenever the content changes, a new Cursor is produced which can be “swapped” into the adapter. To use a CursorLoader, we need to specify that our Activity implements the LoaderManager.LoaderCallbacks&lt;Cursor&gt; interface—basically saying that this fragment can react to Loader events. We will need to fill in the interfaces callback functions in order to use the CursorLoader: In onCreateLoader() we specify what the Loader should do. Here we will instantiate and return a new CursorLoader(...) that queries the ContentProvider. This looks a lot like the .query() method we wrote earlier, but will run on a background thread! In the onLoadFinished() callback, we can use swapCursor() to swap passed in Cursor into our SimpleCursorAdapter in order to feed that model data into our controller (for display in the view). The framework handles any cleanup around the old Cursor. In the onLoaderReset() callback, we can just swap in null for our Cursor, since there now is no content to show (the loaded data has been “reset”). Finally, in order to actually start our background loading, we’ll use the getLoaderManager().initLoader(...) method. This will cause the Android framework to request the creation of a new Loader (by our onCreateLoader() method), as well as start that Loader loading! (This uses a manager similar to FragmentManager, and is similar in flavor to AsyncTask.execute()). getSupportLoaderManager().initLoader(0, null, this); Use getSupportLoaderManager() if you’re using the support library (and calling from an Activity; a support library Fragment like we’ve been using only has the one manager, so you can just use getLoaderManager()). The first parameter to the initLoader() method is an id number for which cursor you want to load—what is passed in as the first param to onCreateLoader() (or is accessible via Loader#getId()). This allows you to have multiple Loaders using the same callback function (e.g., to handle multiple Loaders for multiple data sources). The second param is a Bundle of args, and the third is the LoaderCallbacks (e.g., who handles the results)! Note that you can use the .restartLoader() method to “recreate” the CursorLoader (without losing other references), such as if you want to change the arguments passed to it. And with that, we can fetch the words from our database on a background thread—and if we update the words (e.g., through the Language Settings) it will automatically update! 9.4 Other Provider Actions The Content Resolver of course allows us to do more than just query and load the data: we can also add, update, or remove entries from the database. If we want to modify the contents of the User Dictionary, we will need permission: &lt;uses-permission android:name=&quot;android.permission.WRITE_USER_DICTIONARY&quot;/&gt; To insert (create) a new Word into the ContentProvider, we call the .insert() method on the ContentResolver. It is passed a ContentValues object, which is a HashMap almost exactly like a Bundle (but it only supports values that can be entered into Content Providers, e.g., no Parcelables). ContentValues newValues = new ContentValues(); newValues.put(UserDictionary.Words.WORD, inputText.getText().toString()); newValues.put(UserDictionary.Words.FREQUENCY, 100); newValues.put(UserDictionary.Words.APP_ID, &quot;edu.uw.loaderdemo&quot;); newValues.put(UserDictionary.Words.LOCALE, &quot;en_US&quot;); Uri newUri = getContentResolver().insert( UserDictionary.Words.CONTENT_URI, // the user dictionary content URI! newValues // the values to insert ); The insert() function returns the URI for the newly inserted row, e.g. if you want to be able to query and display that content later. A similar approach is used to update and modify an entry in the Content Provider: call the .update() method and pass in a ContentValues bundle of values to change: ContentValues newValues = new ContentValues(); newValues.put(UserDictionary.Words.FREQUENCY, newFrequency); getContentResolver().update( ContentUris.withAppendedId(UserDictionary.Words.CONTENT_URI, id), newValues, null, null); //no selection Note that we make sure to update only that particular item by specifying the URI of that item. We do this by constructing a new URI representing/identifying that item, effectively by appending &quot;/:id&quot; to the URI. This means that we don’t need to use the selection criteria (though we could do that as well). That covers how to utilize and interact with a Content Provider (as a client of that Provider). A later lecture will cover how to implement a Provider for a custom database. https://developer.android.com/guide/topics/providers/content-providers.html↩ "],
["files-and-permissions.html", "Lecture 10 Files and Permissions 10.1 File Storage Locations 10.2 Permissions 10.3 External Storage 10.4 Internal Storage &amp; Cache 10.5 Example: Saving Pictures 10.6 Sharing Files", " Lecture 10 Files and Permissions This lecture discusses how to working with files in Android. Using the file system allows us to have persistent data storage in a more expansive and flexible manner than using the SharedPreferences discussed in the previous lecture (and as a supplement to ContentProvider databases). This lecture references code found at https://github.com/info448/lecture10-files. In order to demonstrate all of the features discussed in this lecture, your device or emulator will need to be running API 23 (6.0 Marshmallow) or later. 10.1 File Storage Locations Android devices split file storage into two types: Internal storage and External storage. These names come from when devices had built-in memory as well as external SD cards, each of which may have had different interactions. However, with modern systems the “external storage” can refer to a section of a phone’s built-in memory as well; the distinctions are instead used for specifying access rather than physical data location. Internal storage is always accessible, and by default files saved internally are only accessible to your app. Similarly, when the user uninstalls your app, the internal files are deleted. This is usually the best place for “private” file data, or files that will only be used by your application. External storage is not always accessible (e.g., if the physical storage is removed), and is usually (but not always) world-readable. Normally files stored in External storage persist even if an app is uninstalled, unless certain options are used. This is usually used for “public” files that may be shared between applications. When do we use each?34 Basically, you should use Internal storage for “private” files that you don’t want to be available outside of the app, and use External storage otherwise. Note however that there are publicly-hidden External files—the big distinction between the storage locations is less visibility and more about access. In addition, both of these storage systems also have a “cache” location (i.e., an Internal Cache and an External Cache). A cache is “(secret) storage for the future”, but in computing tends to refer to “temporary storage”. The Caches are different from other file storage, in that Android has the ability to automatically delete cached files if storage space is getting low. However, you can’t rely on the operating system to do that on its own in an efficient way, so you should still delete your own Cache files when you’re done with them! In short, use the Caches for temporary files, and try to keep them small (less than 1MB recommended). The user can easily clear an application’s cache as well through the operating system’s UI. In code, using all of these storage locations involve working with the File35 class. This class represents a “file” (or a “directory”) object, and is the same class you may be familiar with from Java SE. We can instantiate a File by passing it a directory (which is another File) and a filename (a String). Instantiating the file will create the file on disk (but empty, size 0) if it doesn’t already exist. We can test if a File is a folder with the .isDirectory() method, and create new directories by taking a File and calling .mkdir() on it. We can get a list of Files inside the directory with the listFiles() method. See the API documentation for more details and options. The difference between saving files to Internal and External storage, in practice, simply involves which directory you put the file in! This lecture will focus on working with External storage, since that code ends up being a kind of “super-set” of implementation details needed for the file system in general. It will indicate what changes need to be made for interacting with Internal storage. In particular, this lecture will walk through implementing an application that will save whatever the user types into an text field to a file. Because a device’s External storage may be on removable media, in order to interact with it in any way we first need to check whether it is available (e.g., that the SD card is mounted). This can be done with the following check (written as a helper method so it can be reused): public static boolean isExternalStorageWritable() { String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state)) { return true; } return false; } 10.2 Permissions Directly accessing the file system of any computer can be a significant security risk, so there are substantial protections in place to make sure that a malicious app doesn’t run roughshod over a user’s data. In order to work with the file system, we first need to discuss how Android handles permissions in more detail. One of the most import aspect of the Android operating system’s design is the idea of sandboxing: each application gets its own “sandbox” to play in (where all its toys are kept), but isn’t able to go outside the box and play with someone else’s toys. In Android, the “toys” (components) that are outside of the sandbox are things that would be impactful to the user, such as network or file access. Apps are not 100% locked into their sandbox, but we need to do extra work to step outside. Sandboxing also occurs at a package level, where packages (applications) are isolated from packages from other developers; you can use certificate signing (which occurs as part of the build process automatically) to mark two packages as from the same developer if you want them to interact. Additionally, Android’s underlying OS is Linux-based, so it actually uses Linux’s permission system under the hood (with user and group ids that grant access to particular files or processes). In order for an app to go outside of its sandbox (and use different components), it needs to request permission to leave. We ask for this permission (“Mother may I?”) by declaring out-of-sandbox usages explicitly in the Manifest, as we’ve done before with getting permission to access the Internet, send SMS messages, or access the User Dictionary. However, the Android permissions we can ask for are divided into two categories: normal and dangerous: Normal permissions are those that may impact the user (so require permission), but don’t pose any serious risk. They are granted by the user at install time; if the user chooses to install the app, permission is granted to that app. See this list36 for examples of normal permissions. INTERNET is a normal permission. Dangerous permissions, on the other hand, have the risk of violating a user’s privacy, or otherwise messing with the user’s device or other apps. These permissions also need to be granted at install time. But IN ADDITION, since API 23 (Android 6.0 Marshmallow), users additionally need to grant dangerous permission access at runtime, when the app tries to actually invoke the “permitted” dangerous action. The user grants permission via a system-generated pop-up dialog. Note that permissions are granted in “groups”, so if the user agrees to give you RECEIVE_SMS permission, you get SEND_SMS permission as well. See the list of permission groups. When the user grants permission at runtime, that permission stays granted as long as the app is installed. But the big caveat is that the user can choose to revoke or deny privileges at any time (they do this though System settings)! Thus you have to check each time you want to access the feature if the user has granted the privileges or not—you don’t know if the user has currently given you permission, even if they had in the past. Writing to external storage is a dangerous permission, and thus we will need to do extra work to support the Marshmallow runtime permission system. In order to support runtime permissions, we need to specify our app’s target SDK to be 23 or higher AND execute the app on a device running Android 6.0 (Marshmallow) or higher. Runtime permissions are only considered if the OS supports and the app is targeted that high. For lower-API devices or apps, permission is only granted at install time. First we still need to request permission in the Manifest; if we haven’t announced that we might ask for permission, we won’t be allowed to ask for it in the future. In particular, saving files to External storage requires android.permission.WRITE_EXTERNAL_STORAGE permission (which will also grant us READ_EXTERNAL_STORAGE access). Before we perform a dangerous action, we can check that we currently have permission: int permissionCheck = ContextCompat.checkSelfPermission(activity, Manifest.permission.PERMISSION_NAME); This function basically “looks up” whether the app has currently been granted a particular permission or not. It will return either PackageManager.PERMISSION_GRANTED or PackageManager.PERMISSION_DENIED. If permission has been granted, great! We can go about our business (e.g., saving a file to external storage). But if permission has NOT been explicitly granted (at runtime), then we have to ask for it. We do this by calling: ActivityCompat.requestPermissions(activity, new String[]{Manifest.permission.PERMISSION_NAME}, REQUEST_CODE); This method takes a Context and an array of permissions that we need access to (in case we need more than one). We also provide a request ID code (an int), which we can use to identify that particular request for permission in a callback that will be executed when the user chooses whether to give us access or not. This is the same pattern as when we sent an Intent for a result; asking for permission is conceptually like sending an Intent to the permission system! We can then provide the callback that will be executed when the user decides whether to grant us permission or not: public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) { switch (requestCode) { case REQUEST_CODE: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { //have permission! Do stuff! } default: super.onRequestPermissionsResult(requestCode, permissions, grantResults); } } We check which request we’re hearing the results for, what permissions were granted (if any—the user can piece-wise grant permissions!), and then we can react if everything is good… like by finally saving our file! Note that if the user deny us permission once, we might want to try and explain why we’re asking permission (see best practices) and ask again. Google offers a utility method (ActivityCompat#shouldShowRequestPermissionRationale()) which we can use to show a rationale dialog if they’ve denied us once. And if that’s true, we might show a Dialog or something to explain ourselves—and if they OK that dialog, then we can ask to perform the dangerous action again. 10.3 External Storage Once we have permission to write to an external file, we can actually do so! Since we’ve verified that the External storage is available, we now need to pick what directory in that storage to save the file in. With External storage, we have two options: We can save the file publicly. We use the getExternalStoragePublicDirectory() method to access a public directory, passing in what type of directory we want (e.g., DIRECTORY_MUSIC, DIRECTORY_PICTURES, DIRECTORY_DOWNLOADS etc). This basically drops files into the same folders that every other app is using, and is great for shared data and common formats like pictures, music, etc.. Files in the public directories can be easily accessed by other apps, assuming the app has permission to read/write from External storage! DIRECTORY_DOCUMENTS was added in API 19, and is a nice place to use. Alternatively starting from API 18, we can save the file privately, but still on External storage (these files are world-readable, but are hidden from the user as media, so they don’t “look” like public files). We access this directory with the getExternalFilesDir() method, again passing it a type (since we’re basically making our own version of the public folders). We can also use null for the type, giving us the root directory. Since API 19 (4.4 KitKat), you don’t need permission to write to private External storage. If that’s all you’re doing, you can only specify in the Manifest that you need External storage access for versions lower than that: &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; android:maxSdkVersion=&quot;18&quot; /&gt; We can actually look at the emulator’s file-system and see our files be created using adb. Connect to the emulator from the terminal using adb -s emulator-5554 shell (note: adb needs to be on your PATH). Public external files can usually be found in /storage/sdcard/Folder, while private external files can be found in /storage/sdcard/Android/data/package.name/files (these paths may vary on different devices). Once we’ve opened up the file, we can write content to it by using the same IO classes we’ve used in Java: The “low-level” way to do this is to create a a FileOutputStream object (or a FileInputStream for reading). We just pass this constructor the File to write to. We write bytes to this stream… but can get the bytes from a String by calling myString.getBytes(). For reading, we’ll need to read in all the lines/characters, and probably build a String out of them to show. However, we can also use the same decorators as in Java (e.g., BufferedReader, PrintWriter, etc.) if we want those capabilities; it makes reading and writing to file a little easier. In either case, remember to .close() the stream when done (to avoid memory leaks)! //writing try { //saving in public Documents directory File dir = getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS); if (!dir.exists()) { dir.mkdirs(); } //make dir if doesn&#39;t otherwise exist (pre-19) File file = new File(dir, FILE_NAME); Log.v(TAG, &quot;Saving to &quot; + file.getAbsolutePath()); PrintWriter out = new PrintWriter(new FileWriter(file, true)); out.println(textEntry.getText().toString()); out.close(); } catch (IOException ioe) { Log.d(TAG, Log.getStackTraceString(ioe)); } //reading try { File dir = getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS); File file = new File(dir, FILE_NAME); if(!file.exists()) return; //e.g., if file doesn&#39;t exist yet BufferedReader reader = new BufferedReader(new FileReader(file)); StringBuilder text = new StringBuilder(); //read the file String line = reader.readLine(); while (line != null) { text.append(line + &quot;\\n&quot;); line = reader.readLine(); } textDisplay.setText(text.toString()); reader.close(); } catch (IOException ioe) { Log.d(TAG, Log.getStackTraceString(ioe)); } This will allow us to have our “save” button write the message to the file, and have our “read” button load the message from the file (and display it on the screen)! 10.4 Internal Storage &amp; Cache Internal storage works pretty much the same way as External storage. Remember that Internal storage is always private to the app. So we also don’t need permission to access Internal storage! For Internal storage, we can use the getFilesDir() method to access to the files directory (just like we did with External storage). This method normally returns the folder at /data/data/package.name/files. Alternatively, we can use Context#openFileOutput() (or Context#openFileInput()) and pass it the name of the file to open. This gives us back the Stream object for that file in the Internal storage file directory, without us needing to do any extra work (cutting out the middle-man!) These methods take a second parameter: MODE_PRIVATE will create the file (or replace a file of the same name). Other modes available are: MODE_APPEND (which adds to the end of the file if it exists instead of erasing). MODE_WORLD_READABLE, and MODE_WORLD_WRITEABLE are deprecated. Note that you can wrap a FileInputStream in a InputStreamReader in a BufferedReader. We can access the Internal Cache directory with getCacheDir(), or the External Cache directory with getExternalCacheDir(). We almost always use the Internal Cache, because why would you want temporary files to be world-readable (other than maybe temporary images…) Recommended practice is to make temporary Cache files by using the createTempFile() utility method. And again, once you have the file, you use the same process for reading and writing as External storage. For practice make the provided toggle support reading and writing to an Internal file as well. This will of course be different file than that used with the External switch. Ideally this code could be refactored to avoid duplication, but it gets tricky with the need for checked exception handling. To sum up: Private Internal storage: getFilesDir() or openFileOutput() Public External storage: getExternalStoragePublicDirectory() Private External storage: getExternalFilesDir() Internal Cache: getCacheDir() and createTempFile() External Cache: getExternalCacheDir() 10.5 Example: Saving Pictures As another example of how we might use the storage system, consider the “take a selfie” system from Lecture 7. The code for taking a picture can be found in a separate PhotoActivity (which you can navigate to from the options menu). To review: we sent an Intent with the MediaStore.ACTION_IMAGE_CAPTURE action, and the result of that Intent included an Extra that was a BitMap of a low-quality thumbnail for the image. But if we want to save a higher resolution version of that picture, we’ll need to store that image in the file system! To do this, we’re actually going to modify the Intent we send so it includes an additional Extra: a file in which the picture data can be saved. Effectively, we’ll have our Activity allocate some memory for the picture, and then tell the Camera where it can put the picture data that it captures. (Intent envelops are too small to carry entire photos around!) Before we send the Intent, we’re going to go ahead and create an (empty) file: File file = null; try { String timestamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(new Date()); //include timestamp //ideally should check for permission here, skipping for time File dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); file = new File(dir, &quot;PIC_&quot;+timestamp+&quot;.jpg&quot;); boolean created = file.createNewFile(); //actually make the file! Log.v(TAG, &quot;File created: &quot;+created); } catch (IOException ioe) { Log.d(TAG, Log.getStackTraceString(ioe)); } We will then specify an additional Extra to give that file’s location to the camera: if we use MediaStore.EXTRA_OUTPUT as our Extra’s key, the camera will know what to do with that! However, the extra won’t actually be the File but a Uri (recall: the “url” or location of a file). We’re not sending the file itself, but the location of that file (because it’s smaller data to fit in the Intent envelope). We can get this Uri with the Uri.fromFile(File) method: //save as instance variable to access later when picture comes back this.pictureFileUri = Uri.fromFile(file); Then when we get the picture result back from the Camera (in our onActivityResult callback), we can access that file at the saved Uri and use it to display the image! The ImageView.setImageUri() is a fast way of showing an image file. Note that when working with images, we can very quickly run out of memory (because images can be huge). So we’ll often want to “scale down” the images as we load them into memory. Additionally, image processing can take a while so we’d like to do it off the main thread (e.g., in an AsyncTask). This can become complicated; the recommended solution is to use a third-party library such as Glide, Picasso, or Fresco. 10.6 Sharing Files Once we have a file storing the image, we can also share that image with other apps! As always, in order to interact with other apps, we use an Intent. We can craft an implicit intent for ACTION_SEND, sending a message to any apps that are able to send (share) pictures. We’ll set the data type as image/* to mark this as an image. We will also attach the file as an extra (specifically an EXTRA_STREAM). Again note that we don’t actually put the file in the extra, but rather the Uri for the file! Intent intent = new Intent(Intent.ACTION_SEND); intent.setType(&quot;image/*&quot;); intent.putExtra(Intent.EXTRA_STREAM, this.pictureFileUri); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } There is one complication though: because we’re saving files in External storage, the app who is executing the ACTION_SEND will need to have permission to read the file (e.g., to access External storage). The Messenger app on the emulator appears to lack this permission by default, so we need to take a slightly different approach: Rather than putting the file:// Uri in the Intent’s extra, we’ll need to create a content:// Uri for a ContentProvider who is able to provide files to anyone who requests them regardless of permissions (the provider grants permission to access its content). Luckily, each image stored in the public directories is automatically tracked by a ContentProvider known as the MediaStore. It easy to fetch a content:// Uri for a particular image file from this provider: MediaScannerConnection.scanFile(this, new String[] { file.toString(); }, null, new MediaScannerConnection.OnScanCompletedListener() { public void onScanCompleted(String path, Uri uri) { mediaStoreUri = uri; //save the content:// Uri for later Log.v(TAG, &quot;MediaStore Uri: &quot;+uri); } }); The scanFile() method provides a Uri that can be given to the Intent, and that the Messenger app will be able to access! We can generate this Uri as soon as we have a file for the image to be saved in. Bonus: Sharing with a FileProvider This section may be out of date and needs further testing for accuracy. What happens if we try and share an Internal file? You’ll get an error (at the user level!), because the other app (Messenger) doesn’t have permission to read that file! There is a way around this though, and it’s by using a ContentProvider again (haha!). A ContentProvider explicitly is about making content available outside of a package (that’s why we declare them in the Manifest). Specifically, a ContentProvider can convert a set of Files into a set of data contents (e.g., accessible with the content:// protocol) that can be used and returned and understood by other apps! It’s kind of like a “File Server” in that respect! This is what the MediaStore provider is doing for us with images. The question is: how do we do this for generic file types? Luckily, Android includes a FileProvider class in the support library that does exactly this work. Setting up a FileProvider is luckily not too complex, though it has a couple of steps. You will need to declare the &lt;provider&gt; inside the Manifest (see the guide link for an example). &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;edu.uw.myapp.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/fileprovider&quot; /&gt; &lt;/provider&gt; The attributes you will need to specify are: android:authority should be your package name followed by .fileprovider (e.g., edu.uw.myapp.fileprovider). This says what source/domain is granting permission for others to use the file. The child &lt;meta-data&gt; tag includes an androd:resource attribute that should point to an XML resource, of type xml (the same as used for your SharedPreferences). You will need to create this file! The contents of this file will be a list of what subdirectories you want the FileProvider to be able to provide. It will look something like: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;files-path name=&quot;my_file&quot; path=&quot;files/&quot; /&gt; &lt;/paths&gt; The &lt;files-path&gt; entry refers to a subdirectory inside the Internal Storage files (the same place that .getFilesDir() points to), with the path specifying the name of the subdirectory. Once you have the provider specified, you can use it to get a Uri to the “shared” version of the file using: Uri fileUri = FileProvider.getUriForFile(context, &quot;edu.uw.myapp.fileprovider&quot;, fileToShare); (note that the second parameter is the “authority” you specified in your &lt;provider&gt; in the Manifest). You can then use this Uri as the EXTRA_STREAM extra in the Intent that you want to share! https://developer.android.com/training/basics/data-storage/files.html#InternalVsExternalStorage↩ https://developer.android.com/reference/java/io/File.html↩ https://developer.android.com/guide/topics/permissions/normal-permissions.html↩ "],
["databases.html", "Lecture 11 Providers and Databases 11.1 Review: Providers and Loaders 11.2 SQLite Databases 11.3 Implementing a ContentProvider", " Lecture 11 Providers and Databases This lecture provides an in-depth discussion of working with Databases and Content Providers in Android. Accessing Content Providers (via a Loader) was discussed in a previous lecture. This lecture will instead talk about how to make your own database and a Provider for it. Databases are appropriate when you want to store structured data locally on the device (e.g., not on the cloud, which may require expensive network transactions as well as user accounts), but that data has greater scale or complexity than is appropriate for a SharedPreferences XML file—that is, you need to store more than just key-value pairs. This lecture references code found at https://github.com/info448/lecture11-databases. Note that while the starter code accesses the device’s User Dictionary, which is only available on API 22 (Lollipop) or earlier, the rest of the tutorial replaces that provider and will work on any version of Android. 11.1 Review: Providers and Loaders As discussed previously, a Content Provider is an abstraction for a source of structured data (like a database, but also possibly files, internet resources, etc). It acts as an interface for interacting with that data, supporting the developing in reading, adding to, updating, or deleting data from the source (e.g., the basic CRUD operations). We previously demonstrated how to access structure data—specifically the User Dictionary—via a Content Provider using a Loader. You can read this example to review how to utilize an existing Provider: The application displays a ListView, which is backed by a SimpleCursorAdapter. This adapter takes a “Cursor” (think: a “pointer” or an Iterator—also a list of data that has been loaded into memory) and connects each item to a View on the screen. This View shows the word (WORD) and the “frequency”/prominence (FREQUENCY) of that word. In order to get this list of items into memory from data store itself (to perform the read operation), we set up a Loader. The Loader fetches 3 “columns” (attributes) from the data store: _ID, WORD, and FREQUENCY; the _ID field is not shown on the View, but the Loader needs that to keep track of the displayed items). We do not utilize any selection or sorting criteria, though we could add them in if we wanted. The loader fetches (queries) data from the data store to load it into memory. It then tells the Adapter to take that loaded data and display it in the View. By using a Loader for this process, we gain two benefits: (1) the data is loaded into memory on a background thread (not the UI Thread), and (2) the data is automatically reloaded when the data store’s content changes. The example also supports the create and update operations (by clicking the “Add Word” button and the individual word entries, respectively). These operations work by constructing a ContentValues object (similar to a Bundle, but for Content Providers) that contains the attribute values for the new provider entry. We then use the ContentResolver to insert() or update() these values into the Provider (indicated by its URI). To review: the Content Provider acts as the data store, abstracting information at some location (e.g., in a database). The Loader grabs a bunch of rows and columns from that database, and hands it to the Adapter. The Adapter takes a subset of those rows and columns and puts them in the ListView so that they display to the user. User interaction allows us to add or modify the data in that database. 11.2 SQLite Databases Content Providers can abstract all kinds of data stores (files, urls, etc.). They abstract these as a structured information similar to a database… and in fact the most common kind of store they represent is a relational database (specifically, an SQLite database). Android comes with an API for creating an querying a database; these databases are stored on internal storage meaning that each application can have its own private database (or multiple databases, in fact)! If you have worked with SQL or another relational database system (e.g., in the iSchool’s INFO 340 course), this interaction will seem familiar. If you’ve never worked with a database, the simplest explanation is to think of them as a spreadsheet (like in an Excel file) where you manipulate rows of data given a set of pre-defined columns. SQL (Structured Query Language) is its own command language for working with these spreadsheets; we’ll see some samples of those queries in this lecture. SQLite is a “flavor” (version) of SQL; the full SQLite spec can be found here. A short tutorial (borrowed from Google) is also available in the code repository. In this lecture, we will build our own database of words (separate from the User Dictionary—and so which will work on API 23+) that we can access through a Content Provider. We will simply change which “data store” is being accessed; the rest of the application’s interface will remain the same. This will let us demonstrate how to put together a Content Provider from scratch. We will start by setting up the database, and then implementing the ContentProvider that abstracts it. Setting up a database is somewhat wordy and round-about, though it does not involve many new concepts. The step to effectively utilizing a database in Android is to create a class (e.g., WordDatabase) to act as a “namespace” for the various pieces of our database. This class will not be instantiated (and so can even have a private default constructor). For time considerations, the beginnings of the class are included in the lecture starter code. The WordDatabase class will contain a number of constants: DATABASE_NAME to refer to the name of the database file stored on the device (e.g., words.db) DATABASE_VERSION to refer to the current version number of our database’s schema. This is used more for supporting migrations like if we want to update our database later. The class also includes constants that define the database’s schema or contract. This is so that other classes (e.g., the ContentProvider and the MainActivity) can refer to column names consistently without having to remember or even know the specific text we utilize in the database. This is similar to how we used the variable UserDictionary.Words.WORD rather than the String value &quot;word&quot;. By convention, we define this schema as a separate static nested class (e.g., WordEntry), to keep things organized. This class contains the constants to hold the column names: static class WordEntry implements BaseColumns { //class cannot be instantiated private WordEntry(){} public static final String TABLE_NAME = &quot;words&quot;; public static final String COL_WORD = &quot;word&quot;; public static final String COL_COUNT = &quot;count&quot;; } The class implements BaseColumns, which lets it inherit a few framework specific constants for free—in particular, the _ID variable which Content Providers rely on the database to have as a primary key. We create a different nested class for each table in the database (sheet in a spreadsheet). This allows us to use Java-style namespacing (dot notation) to refer to different tables in a single database. Once we have defined the schema, we are ready to create and work with the database. In order to help us do this, we’re going to use a class called SQLiteOpenHelper37. This class offers a set of methods to help manage the database being created and upgraded (e.g., for migrations). Specifically, we will will subclass SQLiteOpenHelper, creating another nested class that represents the specific helper for our database. The subclass has a constructor that takes in a Context, and then “passes up” the database name and version to the parent class. public DatabaseHelper(Context context){ super(context, DATABASE_NAME, null, DATABASE_VERSION); } SQLiteOpenHelper also has two abstract methods (event callbacks) that we need to implement: what happens when the database is created, and what happens when the database is upgraded. When the database is first created, we’ll need to actually create the table to hold our words. This involves sending it an SQL command to create the table! This has been provided as a constant in the starter code. private static final String CREATE_TASKS_TABLE = &quot;CREATE TABLE &quot; + WordEntry.TABLE_NAME + &quot;(&quot; + WordEntry._ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;, &quot;+ WordEntry.COL_WORD + &quot; TEXT&quot; + &quot;,&quot;+ WordEntry.COL_COUNT + &quot; INTEGER&quot; + &quot;)&quot;; private static final String DROP_TASKS_TABLE = &quot;DROP TABLE IF EXISTS &quot;+ WordEntry.TABLE_NAME; We can do the same for dropping (deleting) the table as well. This is the only SQL you will need in this tutorial! We can run these SQL statements by using the execSQL() method, called on the SQLiteDatabase object that is passed to these callbacks. Note that this method runs a “raw” SQL query (one that doesn’t return anything, so not SELECT), without any kind of checks against SQL injection attacks. But since we’re hard-coding the information to run, it’s not a problem. Aside from this situation, you should never use this method. We can also use the insert() method to add some sample words to the database (similar to how we used the Content Provider), for clarity when testing: ContentValues sample1 = new ContentValues(); sample1.put(WordEntry.COL_WORD, &quot;Embiggen&quot;); sample1.put(WordEntry.COL_COUNT, 0); db.insert(WordEntry.TABLE_NAME, null, sample1); The second parameter to .insert() is a nullColumnHack, which is a column to explicitly put a NULL value into if you don’t provide any other values (since you can’t insert an empty row). In the onUpdate() callback, we’ll just “drop” the table and recreate it (by calling onCreate()). In a production system, this would involve migration logic. If we want to interact with this database in MainActivity, we can initialize the DatabaseHelper object (which will create the database if needed) and then use that helper to fetch the database we want to query (using getReadableDatabase()). Note that querying a database could take a long time, and so we should not be doing it on the UI Thread… this example is simply for testing. We can check that our database is set up correctly in one of two ways: We can directly explore the SQLite database that is on your device by using adb and the sqlite3 tool. See this link for more details. $ adb -s emulator-5554 shell # sqlite3 /data/data/edu.uw.package.name/databases/words.db # sqlite&gt; select * from words; # sqlite&gt; .exit We can call a query() method on our SQLiteDatabase, and log out the results. A SQLiteQueryBuilder can offer some help if our query is going to be complex (e.g,. with JOIN): SQLiteQueryBuilder builder = new SQLiteQueryBuilder(); builder.setTables(WordDatabase.WordEntry.TABLE_NAME); //set the table to use Cursor results = builder.query( db, new String[] {WordDatabase.WordEntry.COL_WORD, WordDatabase.WordEntry.COL_COUNT}, null, null, null, null, null); //5 nulls! while(results.moveToNext()) { String word = results.getString(results.getColumnIndexOrThrow(WordDatabase.WordEntry.COL_WORD)); int freq = results.getInt(results.getColumnIndexOrThrow(WordDatabase.WordEntry.COL_COUNT)); Log.v(TAG, &quot;&#39;&quot;+word+&quot;&#39; (&quot;+freq+&quot;)&quot;); } This is the exact same Cursor processing work used when logging out the clicked item, but using our column names instead! We could even remove the Loader call and just pass in this query directly to the Adapter, if we wanted to display our database in the list. Voila, we have a database that we can call methods on to access! 11.3 Implementing a ContentProvider We don’t want to do this database creation and querying on the main thread (because it may take a while). And since we also want to easily let our ListView update when the database changes, we we like to be able to use a Loader to access this database. In order to use a Loader, we need to wrap the database in a ContentProvider. There are a lot of steps and a lot of code involved in making a ContentProvider, and most of them are “boilerplate” for most databases. So much so that there is thorough example code in the Google documentation, which you can copy-and-paste from as needed. We’ll start by creating another class that extends ContentProvider (can you understand why?). Since this will have a lot of abstract methods we’ll need to fill in, so we can actually use one of Android Studio’s generators via New &gt; Other &gt; Content Provider to help us along (I normally say not to use these, but with the ContentProvider it’s not too messy). We will have to specify an authority for the Provider. This acts as a unique, Android-internal “name” for the database (to indicate which it is, or who “owns” it). This is the “name” by which others will be able to refer to our particular Provider. This is thus sort of like a package name—and in fact, we usually use the package name with an extra .provider attached as the authority name. Also notice that an entry for this &lt;provider&gt; has been added to the Manifest, including the authority name. android:enabled means the Provider can be instantiated, and android:exported means it is available to other applications. URIs and Types The most important piece of a ContentProvider (that makes it more than just helper methods for a database) is how it can be accessed at a particular URI. So the first thing we need to do is specify this URI for our provider. We’ll actually want to specify multiple URIs. This is because each piece of content we provide (each record in the database!) is itself a distinct resource, and thus should have its own URI. As such, we need to design a schema for the URIs so that we know how to refer to each kind of content offered by our provider. Designing a URI schema is like designing a URL structure for a website; this will feel familiar to specifying routes for a web application. The most common URI approach for Content Providers is to give each resource we provide a URI of the format: content://authority/resource/id This URI indicates that it is an identifier for a particular provider (the authority), which has a particular resource type (think: which database table of information), which may have a particular resource id (think: the ID of the record in the table) Leaving off the id would refer to the entire table, or rather the “list” of resources. So really we have two different “categories” of URIs: the whole list, and an individual resource within that list. Both have the same “base”, but will need to be handled slightly differently. See designing content URIs for more discussion on how to structure these. We will define these URIs piece-wise using constants (of course). One for the authority, one for the resource type (which happens to be the name of the database table, but doesn’t need to be), and finally the overall Content URI (parsed into a Uri object): public static final Uri CONTENT_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/&quot;+WORD_RESOURCE); But we also need to handle both types of resources: the “list” of words, and the individual words themselves. To enable this, we’re going to use a class called a UriMatcher. This class provides a mapping between URIs and the actual “type” of data we’re interested in (either lists or word objects). This will help us do “routing” work, without needing to parse the path of the URI ourselves. We’ll represent the “type” or “kind” with int constants (like enums), allowing us to easily refer to “which” kind of resource we’re talking about. //integer values representing each supported resource Uri private static final int WORD_LIST_URI = 1; // /words private static final int WORD_SINGLE_URI = 2;// /words/:id So if you give me a /words URI, I can tell you that you’re interested in “resource kind #1” We want to make a a static UriMatcher object (like a constant) that we can use to do the mapping… but because it takes more than one line to set this up (we add an entry for each mapping), we need to put it inside a static block so that all this code is run together at the class level (not per instance): private static final UriMatcher sUriMatcher; //for handling Uri requests static { //setup mapping between URIs and IDs sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); sUriMatcher.addURI(AUTHORITY, WORD_RESOURCE, WORD_LIST_URI); sUriMatcher.addURI(AUTHORITY, WORD_RESOURCE + &quot;/#&quot;, WORD_SINGLE_URI); } Note the wildcard #, meaning “any number” (after the slash) will “match” this URI. We can then figure out which “kind” of task by using the UriMatcher#match(uri) method, which will return the “kind” int that matches the given Uri. As an example of this, let’s fill in the getType() method. The purpose of this method is to allow the ContentProvider to let whoever queries it know the MIME Type (media type) of the resource a URI is accessing. This lets the program specify whether the content provided by the Content Provider is an image, text, music, or some other type. The type we’re going to give back is a Cursor (list of rows in a table), so we’ll specify MIME Types for that: public String getType(Uri uri) { switch(sUriMatcher.match(uri)){ case WORD_LIST_URI: return &quot;vnd.android.cursor.dir/&quot;+AUTHORITY+&quot;.&quot;+WORD_RESOURCE; case WORD_SINGLE_URI: return &quot;vnd.android.cursor.item/&quot;+AUTHORITY+&quot;.&quot;+WORD_RESOURCE; default: throw new IllegalArgumentException(&quot;Unknown URI &quot;+uri); } } vnd stands for “vendor specific”—in this case, a format specific to Android. Query Methods Once all of the URIs are specified, we can start responding to requests for content at those URIs. Specifically, when a request for content at a URI comes in, we’re going to fetch data from the database we made earlier and then return that data. We handle these “requests” through 4 different methods: query(), insert(), update(), and delete() (mirroring the CRUD operations, drawing on standard SQL query names). We will fill in those methods to have them fetch and return the database data. First, we need to get access to the database (through a helper), just as we did in the MainActivity. We’ll instantiate the DatabaseHelper in the ContentProvider#onCreate() callback, saving that helper as an instance variable to reference later. Then in the CRUD methods (which will be executed in a background thread), we can call getWriteableDatabase() to get access to that database. We will start with implementing the query() method. Basically, we need to do the same query we used in MainActivity—though can pass in the extra query parameters (e.g., projection, selection, sortOrder) instead of always having them be null or defined manually. However, we also need to be able to handle both types of resources that our Provider serves (lists or single words). We can use the UriMatcher to determine how to adjust our query: for example, by using the UriBuilder#appendWhere() method to add a WHERE clause to our SQL selection: switch(sUriMatcher.match(uri)){ case WORD_LIST_URI: //all words break; //no change case WORD_SINGLE_URI: //single word builder.appendWhere(WordDatabase.WordEntry._ID + &quot;=&quot; + uri.getLastPathSegment()); //restrict to that item default: throw new IllegalArgumentException(&quot;Unknown URI &quot;+uri); } We’ll then just return the Cursor that we get as a result of the query. But there is also one more piece. We want to make sure that the Loader that is reading from our Content Provider (that loaded this Cursor object) is notified of any changes to the results of its query. This will allow the Loader to “automatically” query for new content if any of the data at that URI changes. cursor.setNotificationUri(getContext().getContentResolver(), uri); With this step in place, we can go back to our MainActivity and swap all the column names and URIs for our own custom WordProvider! Rerun the app… and voila, we see our own list of words! We can do basically the same thing to support insert() and update() to enable all of our use cases. Use the UriMatcher to make to only respond to proper Uris—you can’t insert into a single record, and you can’t update the entire list. if(sUriMatcher.match(uri) != WORD_LIST_URI) { throw new IllegalArgumentException(&quot;Unknown URI &quot;+uri); } For insert(), it is also possible to make sure that no “empty” entries are added to the database, and to return the result if the insertion is successful: if(!values.containsKey(WordDatabase.WordEntry.COL_WORD)){ values.put(WordDatabase.WordEntry.COL_WORD, &quot;&quot;); } if(!values.containsKey(WordDatabase.WordEntry.COL_COUNT)){ values.put(WordDatabase.WordEntry.COL_COUNT, 0); } long rowId = db.insert(WordDatabase.WordEntry.TABLE_NAME, null, values); if (rowId &gt; 0) { //if successful Uri wordUri = ContentUris.withAppendedId(CONTENT_URI, rowId); getContext().getContentResolver().notifyChange(wordUri, null); return wordUri; //return the URI for the entry } throw new SQLException(&quot;Failed to insert row into &quot; + uri); The update() method can be somewhat awkward because we need to basically add our id restriction to the user-given selection args: int count; switch (sUriMatcher.match(uri)) { case WORD_LIST_URI: count = db.update(WordDatabase.WordEntry.TABLE_NAME, values, selection, selectionArgs); //just pass in params break; case WORD_SINGLE_URI: String wordId = uri.getLastPathSegment(); count = db.update(WordDatabase.WordEntry.TABLE_NAME, values, WordDatabase.WordEntry._ID + &quot;=&quot; + wordId //select by id + (!TextUtils.isEmpty(selection) ? &quot; AND (&quot; + selection + &#39;)&#39; : &quot;&quot;), selectionArgs); //apply params break; default: throw new IllegalArgumentException(&quot;Unknown URI &quot; + uri); } if (count &gt; 0) { getContext().getContentResolver().notifyChange(uri, null); return count; } throw new SQLException(&quot;Failed to update row &quot; + uri); But in the end, we have a working ContentProvider that supports the same behaviors as the built in User Dictionary (well, except for delete()). We can now store data in our own database and easily access it off the UI Thread for use in things like ListViews. This is great for if you want to track and store any kind of structured information in your apps. https://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html↩ "],
["location.html", "Lecture 12 Location 12.1 Localization Techniques 12.2 Android Location", " Lecture 12 Location This lecture discusses localization: the process for determining location. This is particularly important for Android, which is primarily intended as an operating system for mobile devices. What makes phones and tablets special, and different from desktops, is that they can and do move around. And this mobility makes means that a device’s position and location can matter significantly for how they are used; it’s a major part of what separates the functionality of Android apps from any other computer application. Indeed: localization gives apps the ability to create new kinds of user experiences, and to adjust their functionality to fit the user’s context, supporting context-aware applications. The classic example of context-awareness is having software determine if you are at home, in the office, or on a bus, and change its usage accordingly. In fact, one of the winners of the first Android Developer Challenge (2008) was Ecorio, an app that figured out whether you were driving, walking, or busing and calculated your carbon footprint from that. Note that the emphasis on context-awareness comes out of Ubiquitous Computing, a discipline that considers technology that is ubiquitous or everywhere, to the point that it “blends into the surroundings.” That’s the author’s take on why phone development is important; so that you can compute without thinking about it. I highly recommend you read Mark Weiser’s original 1991 Scientific American article. It’s a neat vision and is foundational for a lot of modern research into mobile systems. It marks the “official” start of the field of Ubicomp. In short: localization can let us know about the user’s situation (though mobile phone location is not necessarily a proxy for user location). 12.1 Localization Techniques Ubicomp researchers have been developing localization systems for years. A classical reference is a survey paper by Jeff Hightower (who was getting his PhD in the CSE department at UW!) As an early example: the Active Badge (AT&amp;T) system had a name-badge emit an infrared message, that was picked up by sensors in a room to determine where the wearer was! This is room-level precision, but improvements and triangulation (calculating angles to what you see) got it down to about 10cm precision. However, this system required a lot of infrastructure to be built into a particular room. With Android, we’re usually interested in more general-purpose localization. Mobile devices use a couple of different kinds of localization (either independently or together). GPS GPS is the most common general-purpose localization technology, and what most people think of when they think of localization. GPS stands for “Global Position System”—and yes, it can work anywhere on the globe. GPS’s functionality depends on satellites: 24 satellites in high orbit (not geo-synchronous) around the Earth. Satellites are distributed so that 4 to 12 are visible from any point on Earth at any time, and their locations are known with high precision. These satellites are each equipped with an atomic, synchronized clock that “ticks” every nanosecond. At every tick, the satellite broadcasts its current time and position. You can almost think of them as really loud alarm clocks. The thing in your phone (or your car, or your watch) that you call a “GPS” or a “GPS device” is actually a GPS receiver. It is able to listen for the messages broadcast by these satellites, and determine its (the device’s) position based on that information. First, the receiver calculates the time of arrival (TOA) based on its own clock and comparing time-codes from the satellites. It then uses the announced time of transmission (TOT; what the satellite was shouting) to calculate the time of flight, or how long it took for the satellite’s message to reach the receiver. Because these messages are sent at (basically) the speed of light, the time of flight is equivalent to the distance from the satellite! There is some other synchronization work that is done to make sure clocks are all the same, but we won’t go into that here. And once it has distances from the satellites, the receiver can use trilateration to determine its position based on the satellites it “sees”. (Trilateration is like Triangulation, but relies on measuring distances rather than measuring angles. Basically, you construct three spheres of given radii, and then look to see where they intersect). GPS precision is generally about 5 meters (15 feet); however, by repeatedly calculating the receiver’s position (since the satellites tick every nanosecond), we can use differential positioning to extrapolate position with even higher precision, increasing precision to less than 1 meter! This is in part how Google can determine where you’re walking. While GPS is ubiquitous, scalable, and sufficiently accurate, it does have some limitations. The biggest problem with GPS is that you need to be able to see the satellites! This means that GPS frequently doesn’t work indoors, as many building walls block the signals. Similarly, in highly urban areas (think downtown Seattle), the buildings can bounce the signal around and throw off the TOF calculations, making it harder to pinpoint position accurately. Additionally, receivers requires a lot of energy to constantly listen for the satellite messages. This means that utilizing the GPS can lead to a big hit on device battery life—which is of particular importance for mobile devices! Cell Tower Localization But your phone can also give you a rough estimate of your location even without GPS. It does this through a couple of techniques, such as relying on the cell phone towers that provide the phone network service. This is also known as GSM localization (Global System for Mobile Communications; the standard for cell phone communication used by many service providers). The location of these towers are known, so we can determine location based off them in a couple of ways: If you’re connected to a tower, you must be within range of it. So that gives you some measure of localization right off the bat. This would not be a very accurate measure though (you might be anywhere within that range). If you can see multiple towers (which is important for “handoff” purposes, so your call doesn’t drop as you move), you can trilaterate the position between them (e.g., finding the possible overlapping area and picking a location in the middle of that). This can give accuracy within 50m in urban areas, with more towers producing better precision. WiFi Localization But wait there’s more! What other kinds of communication antennas do you have in your phone? WiFi! As WiFi has became more popular, efforts have been made to identify the location of WiFi hotspots so that they too can be used for trilateration and localization. This is often done through crowdsourced databases, with information gathered via war driving. War driving involves driving around with a GPS receiver and a laptop, and simply recording what WiFi routers you see at what locations. This then all gets compiled into a database that can be queried—given that you see these routers, where must you be? Google got in hot water for doing this as it was driving around to capture Street-View images. WiFi localization can then be combined with Cell Tower localization to produce a pretty good estimate of your location, even without GPS. And in fact, Google provides the ability to automatically use all of these different techniques, abstracted into a single method call! I want to flag that just like the old Active Badge systems, all of these localizations systems rely on some kind of existing infrastructure: GPS requires satellites; GSM requires cell towers, and WiFi needs the database of routers. All these systems require and react to the world around them, making localization influenced by the actual location as well as both social and computational systems! Representing Location So once we have a location, how do we represent it? First, note that there is a philosophical difference between a “place” and a “space.” A space is a location, but without any social connotations. For example, GPS coordinates, or Cartesian xy-coordinates will all indicate a “space.” A place on the other hand is somewhere that has social meaning: Mary Gates Hall; the University of Washington; my kitchen. Space is a computational construct; place is a human construct. When we talk about localization with a mobile device, we’ll be mostly talking about space. But often place is what we’re really interested in, and we may have to convert between the two (Google does provide a few ways to convert between the two, such as with its Places API). Our space locations will generally be reported as two coordinates: Latitude and Longitude. (Altitude or height can also be reported, but that isn’t very relevant for us). Latitude (“lat”) is the angle between the equatorial plane and a line that passes through a point and the center of the Earth—the angle you have to go up the earth’s surface from the equator. Effectively, it’s a measure of “north/south”. Latitude is usually measured in degrees north, so going south of the equator gives a negative latitude (though this can be expressed positively as “degrees south”). Longitude (“lng”) is the angle between the prime meridian plane and a line that passes through a point and the center of the Earth—the angle you have to go across the earth’s surface from the meridian. Effectively, it’s a measure of “east/west”. Latitude is measured in degrees east, so going east of the meridian. That mean that the western hemisphere has “negative longitude” (though this can be expressed as positive “degrees west”). As an example: UW’s GPS Coordinates38 are N/W, so this would be expressed as N (positive) and E (negative). The distance between degrees and miles depends on where you you are (particularly for longitude—the curvature of the earth means that each degree has less space between it as you get closer to their “joining” at the poles). However, for a very rough sense of scale, in the American Northwest, .01 degrees corresponds with a distance of about a mile (again: this is not an accurate conversion, and is intended only for a sense of the “units”). 12.2 Android Location The remainder of the lecture will discuss how to implement an app that is able to access the device’s location. This location will simply be displayed for now; connecting the location to a visual display (e.g., a map) is left as an exercise to the reader. This lecture references code found at https://github.com/info448/lecture12-location. Google Play Services In order to effectively access location, we first need to make sure we include the Google Play Services. These are a special set of libraries (similar to the support libraries) that provide additional functionality to Android. That functionality will include the location and mapping tools we’re interested in. (Much of this functionality was originally built into core Android, but Google has since been moving it into a separate app that can be more easily distributed and updated!) There are a few steps to including the Play Services library: Modify the project-level build.gradle file to include a reference to Google’s Maven Repository allprojects { repositories { jcenter() // If you&#39;re using a version of Gradle lower than 4.1, you must instead use: maven { url &#39;https://maven.google.com&#39; } } } Make sure you put this under allprojects, and not buildscripts! Make sure the device supports these services (e.g., that it’s a Google device and not an Amazon device). For the emulator, go to the AVD Manager, and confirm the target platform includes the Google APIs. Modify your build.gradle file so that you can get access to the Location classes. In the module-level build.gradle file, under dependencies add compile &#39;com.google.android.gms:play-services-location:11.4.2&#39; This will load in the location services (but not the other play services, which take up extra space and may require additional API keys). Note that you can specify a different version of the services, as long as it is greater than 8.3.0. Additionally, you’ll need to request permission to access the device’s location. There are two permission levels we can ask for: ACCESS_COARSE_LOCATION (for GSM/WiFi level precision), and ACCESS_FINE_LOCATION (for GPS level precision). We’ll use the later because we want GPS-level precision. This is a dangerous permission, so in Marshmallow we need to make sure to ask for permission at run-time! See the lecture on permissions for details. We’re going to use Google Play Services to access the device’s location. The Google APIs provide a nice set of methods for accessing location (without us needing to specify the source of that localization, GPS or GSM), and is the recommended API to use. There is a built-in android.location API (e.g., for non-Google based Android devices), but it’s not recommended practice and is harder to use. The first thing we need to do is get access to the API; we do this with a GoogleApiClient object. We construct this object in the Activity’s onCreate() callback, using a GoogleApiClient.Builder: if (mGoogleApiClient == null) { mGoogleApiClient = new GoogleApiClient.Builder(this) .addConnectionCallbacks(this) .addOnConnectionFailedListener(this) .addApi(LocationServices.API) .build(); } This builder requires us to specify what are called the Connection Callbacks: callbacks that will occur when we connect to the Google Play Services (a Service or separate application managing all of Google’s API work). We do this by implementing the GoogleApiClient.ConnectionCallbacks and GoogleApiClient.OnConnectionFailedListener interfaces. Each require methods that we must fill in; in particular, the onConnected() method is where we can “start” our API usage (like asking for location!) onSuspended and onFailed are for when the connection is stopped (similar to onStop()) or if we fail to connect. See Accessing Google APIs for details. Note we also specify that we want to access the LocationServices API in the builder. Finally, we need to actually connect to the client. We do this in the Activity’s onStart() method (and disconnect in onStop()): protected void onStart() { mGoogleApiClient.connect(); super.onStart(); } This of course, will lead to our onConnected() callback being executed once the connection to the service is established. Accessing Location Once we have the the client connected to the service, we can start getting the location! To access the location, we’re going to use a class called the FusedLocationApi39. This is a “unified” interface for accessing location. It fuses together all of the different ways of getting location, providing whichever one best suits our specified needs. You can think of it as a “wrapper” around more detailed location services. It will let us specify at a high level whether we want to trade accuracy for power consumption, rather than us needing to be explicit about that. And it will make decisions about what how best to fetch location given our stated needs and other contextual information. This particular method for accessing the FusedLocationApi has been deprecated in preparation for Google Play Services v12 (which will be released in early 2018). See FusedLocationProviderClient for the updated API. We’re going to specify this “high level” requirement using a LocationRequest40 object, which represents the details of our request (e.g., how we want to have our phone search for it’s location). LocationRequest request = new LocationRequest(); request.setInterval(10000); request.setFastestInterval(5000); request.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY); We create the object, then specify the “interval” that we want to check for updates. We can also specify the “fastest” interval, which is the maximum rate we want updates (assuming they are available). It’s a bit like a minimum and maximum. 5 to 10 seconds is good for real-time navigation. We also specify the priority, which is the indicator to the FusedLocationApi about what kind of precision we want. HIGH_ACCURACY basically means GPS (trade power for accuracy!) Before actually sending the request, check for run-time permissions! This will introduce another layout of callbacks: first you wait for the GoogleApiClient to connect in one callback, then you wait for permission to be granted in another! Remember to implement onRequestPermissionResult Once we have this request in place, we can send it off through the FusedLocationApi. LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, request, this); The first parameter is going to be the GoogleApiClient object, and the second will be the request we just made. The third parameter for the requestLocationUpdates() method is a LocationListener—an object with a callback that can be executed when the location is updated (i.e., when we move). To provide this listener, we’ll make the Activity into one by implementing the interface and filling in the onLocationChanged() method. Yes, this is a third asynchronous callback after the GoogleApiClient connection has been established and permission has been granted and a location has been received! This listener’s callback will be handed a Location object, which contains the latitude/longitude of the location. We can then use that location (such as display it). We can access the latitude and longitude with getters: textLat.setText(&quot;&quot; + location.getLatitude()); textLng.setText(&quot;&quot; + location.getLongitude()); It is possible to test this out (even when indoors) by using the emulator. Although the emulator doesn’t actually have a GPS receiver, it is possible to give it a “fake” location using the emulator’s options sidebar (where we previously sent SMS messages from). This allows us to “send” the phone a location, almost as if we as humans were the GPS receiver! You can test by giving the emulator UW’s coordinates (47.6550 N, -122.3080 E), and you can watch it update! Note that you may need to start up the Maps application to make sure the devices’s location settings are enabled and correct. See here for how we can prompt for that ourselves (it’s a lot of repetitive code, so leaving it as exercise to the reader). The FusedLocationApi class also has a setMockLocation() method, which can allow you to programmatically define locations (e.g., you can make a button that changes your location). This can be useful for testing and debugging. To review the process: We start by creating and connecting to a GoogleApiClient, which is going to let us talk to the Play Services application running in the background of our phone. This may not be able to connect (or may take a moment), so we have a asynchronous callback for when it does. Once it connects (in that callback), we check to make sure we have permission to get location, asking for it if we don’t. This requires the user to make a decision, which may take some time, so we have another asynchronous callback for when we finally get permission. Once we have permission, we start up a repeated request for location updates. These updates may take some time to arrive, so we have yet another asynchronous callback for when they do! And when we get a location update, we finally update our View. That’s pretty much what is involved in working with location. Lots of pieces (because callbacks all over the place!), but this does the work of tracking location. https://www.google.com/search?q=uw+gps+coordinates↩ https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderApi↩ https://developers.google.com/android/reference/com/google/android/gms/location/LocationRequest↩ "],
["services.html", "Lecture 13 Threads and Services 13.1 Threads and Processes 13.2 IntentServices 13.3 Example: A Music Service 13.4 Foreground Services 13.5 Bound Services", " Lecture 13 Threads and Services This lecture is currently under revision. This lecture discusses a component of Android development that is not immediately visible to users: Services41. Services are sort of like Activities that don’t have a user interface or user interaction directly tied to them. Services can be launched by Activities or Applications, but then do their own thing in the background even after the starting component is closed. Once a Service is started, it keeps running until it is explicitly stopped (Services can be destroyed by the OS to save memory, similar to an Activity, but Services have higher “priority” and so aren’t killed as readily). Some common uses for a Service include: Downloading or uploading data from/to a network in the background even if the app is closed Saving data to a database without crashing if the user leaves the app Running some other kind of long-running, “background” task even after the app is closed, such as playing music! The most common use of Services is to regularly perform a background task in a way that doesn’t block the main UI interaction. This lecture thus begins with a discussion of threads and processes in Android, before detailing how to implement a Service. This lecture references code found at https://github.com/info448/lecture13-services. 13.1 Threads and Processes Concurrency is the process by which we have multiple processes (think: methods) running at the same time. This can be contrasted with processes that run serially, or one after another. For example, if you call two methods one after the other, then the second method execute will “wait” for the first one to finished: public void countUp() { for(int i=0; i&lt;1000; i++){ System.out.println(i); } } public void countDown() { for(int i=0; i&gt; -1000; i--){ System.out.println(i); } } countUp(); //start counting up countDown(); //start counting down (once finished going up) Computers as a general rule do exactly one thing a time: your central processing unit (CPU) just adds two number together over and over again, billions of times a second The standard measure for rate (how many times per second) is the hertz (Hz). So a 2 gigahertz (GHz) processor can do 2 billion operations per second. However, we don’t realize that computers do only one thing at a time! This is because computers are really good at multitasking: they will do a tiny bit of one task, and then jump over to another task and do a little of that, and then jump over to another task and do a little of that, and then back to the first task, and so on. Diagram of thread switching (source unknown) These “tasks” are divided up into two types: processes and threads. Read this brief summary of the difference between them. By breaking up a program into threads (which are “interwoven”), we can in effect cause the computer to do two tasks at once. This is especially useful if one of the “tasks” might take a really long time—rather than blocking the application, we can let other tasks also make some progress while we’re waiting for the long task to finish. Java Threads In Java, we create a Thread by creating a class that implements the Runnable interface. This represents a class that can be “run” in a separate thread! The run() method required by the interface acts a bit like the “main” method for that Thread: when we start the Thread running, that is the method that will get called. If we just instantiate the Runnable() and call its run() method, that won’t actually execute the method on a different thread (remember: an interface is just a “sign”; we could have called the interface and method whatever we wanted and it would still compile). Instead, we execute code on a separate thread by using an instance of the Thread class. This class actually does the work of running code on a separate thread. Thread has a constructor that takes in a Runnable instance as a parameter—you pass an object representing the “code to run” to the Thread object (this is an example of the Strategy Pattern). You then can actually start the Thread by calling its .start() method (not the run method!). Anonymous variables will be useful here; you don’t need to assign a variable name to the Runnable objects or even the Thread objects if you just use them directly. For example, making the above countUp() and countDown() methods run on separate threads can cause the the output to be “interwoven”, showing some positive then some negative numbers (you may need to increase the count or slow down the operation to see it in action, so one thread doesn’t finish before the “switch”). Android Threads Android apps run by default on the Main Thread (also called the UI Thread). This thread is in charge of all user interactions—handling button presses, scrolls, drags, etc.—but also UI output like drawing and displaying text! See Android Threads for more details. As mentioned above, a thread is a piece of a program that is independently scheduled by the processor. Computers do exactly one thing at a time, but make it look like they are doing lots of tasks simultaneously by switching between them (i.e., between processes) really fast. Threads are a way that we can break up a single application or process into little “sub-process” that can be run simultaneously—by switching back and forth periodically so everyone has a chance to work Within a single thread, all method calls are synchronous—that is, one has to finish before the next occurs. You can’t get to step 4 without finishing step 3. With an event-driven system like Android, each method call is fast enough that this isn’t a problem (you’re done handling one click by the time the next occurs). But long, drawn-out processes like network access, processing bitmaps, or accessing a database could cause other tasks to have to wait. It’s like a traffic jam! Tasks such as network access are blocking method calls, which stop the Thread from continuing. A blocked Main Thread will lead to the infamous “Application not responding” (ANR) error! Thus we need to move any “slow” code (such as network access) off the Main Thread, onto a background thread, thereby allowing it to run without blocking the user interaction that occurs on the Main Thread. To do this in Android, we use a class called ASyncTask42 to perform a task (such as network access) asynchronously—without waiting for other Threads. Learning Android Development involves knowing about what classes exist, and can be used to solve problems, but how were we able to learn about the existing of this highly useful (and specialized) ASyncTask class? We started from the official API Guide on Processes and Threads Guide43, which introduces this class! Thus to learn about new Android options, read the docs. Note that an ASyncTask background thread will be tied to the lifecycle of the Activity: if we close the Activity, the network connection will die as well. A better option is often to use a Service, described below. ASyncTask can be fairly complicated, but is a good candidate to practice learning from the API documentation. Looking at that documentation, the first thing you should notice (or would if the API was a little more readable) is that ASyncTask is abstract, meaning you’ll need to subclass it in order to use it. Thus you can subclass it as an inner class inside the Activity that will use it. You should also notice that ASyncTask is a generic class with three (3) generic parameters: the type of the Parameter to the task, the type of the Progress measurement reported by the task, and the type of the task’s Result. We can fill in what types of Parameter and Result we want from our asynchronous method (e.g., take in a String and return a String[]). You can use the Void type for an unspecified type, such as with Progress measurement if you aren’t tracking that. We can actually pass in multiple String arguments using the String... params spread operator syntax (representing an arbitrary number of items of that type). See here for details. The value that the ASyncTask methods actually get is an array of the arguments. When you “run” an AsyncTask, it will do four (4) things, represented by four methods: onPreExecute() is called on the UI thread before it runs the task. This method can be used to perform any setup for the task. doInBackground(Params...) is called on the background thread to do the work you want to be performed asynchronously. You must override this method (it’s abstract!) The params and return type for the method need to match the ASyncTask generic types. onProgressUpdate() can be indirectly called on the UI thread if we want to update our progress (e.g., update a progress bar). Note that UI changes can only be made on the UI thread! onPostExecute(Result) is called on the UI thread to process any task results, which are passed as parameters to this method when doInBackground is finished. The doInBackground() is what occurs on the background thread (and is the heart of the task), so you would put e.g., network or database accessing method calls in there. We can then instantiate a new ASyncTask object in the Activity’s onCreate() callback, and call ASyncTask#execute(params) to start the task running on its own thread. In order to get any results back into the rendered View, you utilize the doPostExecute() method. This method is run on the UI Thread so you can use it to update the View (we can only change the View on the UI Thread, to avoid collisions). It also gets the results returned by doInBackground() passed to it automatically! E.g., you can take a resulting String[] and put that into an Adapter for a ListView. ASyncTask is the simplest, general way to do some work on a background thread. However, it has a few limitations: The lifecycle of an ASyncTask is tied to that of its containing Activity. This means that if the containing Activity is destroyed (e.g., is finished()), then the the ASyncTask is as well—you would lose any data you were downloading or might corrupt your database in some way. To handle lots of different background tasks, you would need to do your own task management. As such, repeated or longer-lasting tasks (such as large file downloads) are often better handled through Services. 13.2 IntentServices As mentioned above, a Service is an application component (like an Activity) that runs in the “background”, even if the user switches to another application. Services do not normally have an associated user interface, but instead are simply was to group and manage large amounts of data processing (e.g., for network downloads, media processing, or database access). An important thing to note about Services: a Service is not a separate process; it runs in the same process as the app that starts it (unless otherwise specified). Similarly, a Service is not a Thread, and in fact doesn’t need to run outside the UI thread! However, we quite often do want to run the service outside of the UI Thread, and so often have it spawn and run a new Runnable Thread. When we say a Service runs “in the background”, we mean from a user’s perspective rather than necessarily on a background thread. To create a Service, we’re going to subclass Service and override some lifecycle callbacks, just like we’ve done with Activity, Fragment, BroadcastReceiver, and most other Android components. In this sense, Services are in fact implemented like Activities that run without a user interface (“in the background”). Because Services will be performing extra background computation, it’s important to also create a separate background thread so that you don’t block the Main Thread. Since making a Service that does some (specific) task in a background thread is so common, Android includes a Service subclass we can use to do exactly this work. This class is called IntentService—a service that responds to Intents and does some work in response to them. An IntentService does a similar job to ASyncTask, but with the advantage that it will keep doing that work even if the Activity is destroyed! IntentService will listen to any incoming “requests” (Intents) and “queue” them up, handling each one at a time. Once the service is out of tasks to do, the service will shut itself down to save memory (though it will restart if more Intents are sent to it). Basically, it handles a lot of the setup and cleanup involved in using a Service on its own! (This lecture will start with IntentService because it’s simpler, and then move into the more generic, complex version of Services). We create an IntentService by defining a new class (e.g., CountingService) that subclasses IntentService. Implement a default constructor that can call super(String nameForDebugging). This allows the class to be instantiated (by the Android framework; again, like an Activity). Also implement the onHandleIntent(Intent) method. Incoming Intents will wait their turn in line, and then each is delivered to this method in turn. Note that all this work (delivery and execution) will happen in a background thread supplied by IntentService. For example, we can have the Service (when started) log out a count, pausing for a few seconds between. This will represent “expensive” logic to perform, a la accessing a network or a database. for(int count=0; count&lt;=10; count++){ Log.v(TAG, &quot;Count: &quot;+count); try { Thread.sleep(2000); //sleep for 2 seconds } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } Just like with Activities, we also need to declare the &lt;service&gt; in the Manifest, as a child of the &lt;application&gt;: &lt;service android:name=&quot;.CountingService&quot; /&gt; Finally, we can send an Intent to the Service by using the startService() method. This is similar to startActivity(), but for Services! We can use explicit intents just like with Activities, and could even include Extras if we wanted to label and track the specific Intents sent to the Service. When the Service starts, we can see it start counting (but without blocking the UI Thread). We can also destroy the Activity and see that the Service keeps running. If we want to have the Service interact with the user interface (e.g., display a Toast), we will need to make sure that occurs on the UI Thread (you cannot change the UI on a separate thread). This requires inter-thread communication: we need to get a message (a function call) from the background thread to the UI Thread. This is what various ASyncTask UI thread methods (such as onProgressUpdate()) do for us. We can perform this communication using a Handler, which is an object used to pass messages between Threads—it “handles” the messages! We instantiate a new Handler() object (e.g., in the Service’s onCreate() callback), calling a method on that object when we want to “send” a message. The easiest way to send a message is to use the post() function, which takes a Runnable() method which will be executed on the Main Thread: mHandler.post(new Runnable() { @Override public void run() { Toast.makeText(CountingService.this, &quot;Count: &quot; + count, Toast.LENGTH_SHORT).show(); } }); The Service Lifecycle Having demonstrated the basic usage of a service, consider what is going on “under the hood”—starting with the Service lifecycle. There are actually two different “types” of Services, with different variations of the lifecycle. Started Services (or “unbound” Services) are those that are initiated via the startService() function, as in the above example. The other option, Bound Services, are Services that have “client” Activities bound to them to interact with; see below for details. Service lifecycle diagram, from Google44 Just like with Activities, Services have an onCreate() method that is called when the Service is first created. Since Services don’t have a user interface to set up, so we don’t often do a lot in here. IntentService already overrides this in order to set up a “message queue” so that it can queue up Intents (tasks) to run one at a time. The most important callback for a Started Service is called onStartCommand(). This method is called when the Service is sent a command by another component (via an Intent). Importantly, onStartCommand() is not only called when the Service is started for the first time, but whenever the Service receives an Intent to start (even if the Service was already running)! These Intents are those sent via startService(). Note that when working with an IntentService specifically, onStartCommand() will “queue” any incoming Intents. When it is the specific Intent’s turn to be “run”, that Intent is automatically passed to the onHandleIntent() method, which executes on a background thread (similar to AsyncTask#doInBackground()). This callback is not part of the normal Service lifecycle, but is a special helper method used by IntentService—similar to how onCreateDialog() is a special method used by DialogFragments. The onBind() and onUnbind() callbacks are used for bound services, and are discussed below. IntentService does have a default onBind() implementation that returns null. Finally, Services have an onDestroy() callback, which is again equivalent to the Activity callback. In general, Services have to be manually told to stop. We stop a Service by using stopService(Intent) to send that Service a “stop” Intent. The Service can also stop itself by calling stopSelf(). Important: When told to stop, an IntentService will finish up handling any Intents that are currently “running”, but any other Intents that are “queued” will be removed. Once there are no more queued Intents, an IntentService will call stopSelf(), thereby causing the onDestroy() callback to be executed. Practice: fill in the callback functions with Log or Toast messages to see how and when they are executed. For example: public int onStartCommand(Intent intent, int flags, int startId) { Toast.makeText(this, &quot;Intent received&quot;, Toast.LENGTH_SHORT).show(); return super.onStartCommand(intent, flags, startId); } As a last point to note about the Service lifecycle consider the int that is returned by onStartCommand(). This int is a flag that indicates how the Service should behave45 when it is “restarted” after having been destroyed: START_NOT_STICKY indicates that if the Service is destroyed by the system, it should not be recreated. This is the “safest option” to avoid extraneous service executions; instead, just have the application restart the Service. START_STICKY indicates that if the Service is destroyed by the system, it should be recreated when possible. At that point, onStartCommand() will be called by delivering a null Intent (unless there were other start Intents waiting to be delivered, in which case those are used). This option works well for media players or similar services that are running indefinitely (rather than executing specific commands). START_REDELIVER_INTENT indicates that if the Service is destroyed by the system, it should be recreated when possible. At that point, onStartCommand() will be called with the last Intent that was delivered to the Service (and any other Intents are delivered in turn). This option is good for Services that actively perform jobs that need to be resumed, such as downloading a file. In other words: services may get killed, but we can specify how they get resurrected! And of course, we can and should return different values for different starting commands (Intents): so the Intent to download a music file might return START_REDELIVER_INTENT, but the Intent to play the music file might return START_STICKY. 13.3 Example: A Music Service One of the classic uses for a background service is to play music, so we will use that as an example. It is possible to play music directly from an Activity, and the music will even keep playing as long as the Activity is alive. But remember that Activities are fragile, and can be destroyed at any moment (whether by us or by the system to save resources). So in order to keep our music playing even as we go about other tasks, we should use a Service. Services have higher “priority” in the eyes of the Android system, and so don’t get sacrificed for resources as readily as normal Activities. MediaPlayer In order to make a music service, we need to briefly explain how to play music with MediaPlayer. This is the main API for playing sound and video (e.g., if you want to play .mp3 files). Android actually has a total of three (3) audio APIs! The SoundPool API is great for short sound effects that play simultaneously (though you need to do extra work to load those clips ahead of time), such as for simple games. The AudioTrack API allows you to play audio at a very low level (e.g., by “pushing” bytes to a stream). This is useful for generated Audio (like MIDI music) or if you’re trying to do some other kind of low-level stuff. MediaPlayer is very simple to use, particularly when playing a locally defined resource (e.g., something in res/raw/). You simply use a factory to make a new MediaPlayer object, and then call .play() on it: MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.my_sound_file); mediaPlayer.start(); // no need to call prepare(); create() does that for you We can also call .pause() to pause the music, .seekTo() to jump to a particular millisecond, and .stop() to stop the music. Note that when we stop(), we also need to release any resources used by the MediaPlayer (to free up memory): mediaPlayer.release(); mediaPlayer = null; We can also implement and register a MediaPlayer.OnCompletionListener to do something when a song finishes playing. Finally, it is possible to use MediaPlayer to play files from a ContentProvider or even off the Internet! String url = &quot;http://........&quot;; // your URL here MediaPlayer mediaPlayer = new MediaPlayer(); mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC); mediaPlayer.setDataSource(url); mediaPlayer.prepareAsync(); //prepare media in the background (buffering, etc) //.prepare() for synchronous buffering mediaPlayer.setOnPreparedListener(this); //handle when file is buffered mediaPlayer.start(); Creating a Service In order to make our music service, we are going to subclass the Service class itself (don’t forget to include the Service in the Manifest) and manually set up all the pieces. Specifically, we will fill in the lifecycle callbacks: onCreate() we can include, though it doesn’t need to do anything. onStartCommand() should create and start our MediaPlayer. We can return START_NOT_STICKY so the music doesn’t start up again randomly if the system needs to destroy the Service (since it won’t get recreated). Important: Normally with a Service we would create a background thread to handle any extraneous work (such as preparing the music to play, as done with the create() method). However, this may not be necessary for MediaPlayer when loading resources. onDestroy() can stop, release, and clean-up the MediaPlayer. We can implement this in a separate helper function for reuse. If we want to handle pausing, we can specify that in the Intent we send to the service (e.g., via a custom ACTION or an Extra). But a more effective approach is to use Service Binding; see below for details. We can now have our Activity startService() and stopService() in order to play our music in the “background”, even if we leave and return to the Activity! 13.4 Foreground Services Services are normally “background” tasks, that run without any user interface and that the user isn’t aware of (e.g., for downloading or uploading data, etc). But music playing is definitely something that the user is aware of, and in fact may want to interact with it! So we’d like the Service to have some kind of user interface, but we’d like to still keep that Service separated from an Activity (so that it can run with the Activity being active). To do this, we use what is called a Foreground Service. Foreground Services represent Services that are divorced from Activities (they are Services after all), but the user is aware of them—and accordingly, have an even higher survival priority if the OS gets low on memory! Foreground services require a Notification in the status bar, similar to the Notifications we’ve created before. This Notification will effectively act as the “user interface” for the Service, and let the user see and be aware of its execution! We create this Notification inside the Service’s onStartCommand() method, then pass it to the startForeground() method in order to put our Service in the foreground: String songName = &quot;The Entertainer&quot;; PendingIntent pendingIntent = PendingIntent.getActivity(getApplicationContext(), 0, new Intent(getApplicationContext(), MainActivity.class), PendingIntent.FLAG_UPDATE_CURRENT); Notification notification = new NotificationCompat.Builder(this) .setSmallIcon(android.R.drawable.ic_media_play) .setContentTitle(&quot;Music Player&quot;) .setContentText(&quot;Now playing: &quot;+songName) .setContentIntent(pendingIntent) .setOngoing(true) //cannot be dismissed by the user .build(); startForeground(NOTIFICATION_ID, notification); //make this a foreground service! Some details about this Notification: We build and set the icon, title, and text as in the previous lecture. We give the Notification a PendingIntent to run when selected. This PendingIntent can just open up our MainActivity, allowing us to control the Player. (Alternatively, we could use Notification Actions to control the music directly). We set the Notification to be ongoing, in order to enforce that it cannot be dismissed by the user. Importantly, once we are done doing foreground work (e.g., playing music), we should call stopForeground(true) to get rid of the foreground service. This is a good thing to do in our stopMusic() helper (called from onDestroy()). There are a couple of other details that you should handle if you’re making a full-blown music player app, including: keeping the phone from going to sleep, playing other audio at the same time (e.g., notification sounds; ringtones), switching to external speakers, etc. See the guide for more details. 13.5 Bound Services As mentioned above, there are two “types” of Services: Started Services (Services launched with startService()) and Bound Services. A Bound Service is a Service that acts as the “server” in a client-server setup: it allows for client Activities to “connect” to it (bind it) and then exchange messages with it—primarily by calling methods on the Service. These messages can even be across processes, allowing for interprocess communication! This is useful when you want interact with the Service from an Activity in some way (e.g., if we want to pause() our music), or if we want to make the service’s capabilities available to other applications. We make a Bound Service by having the Service implement and utilize the onBind() callback. This method returns an IBinder object (the I indicates that it’s an Interface, following a Java convention common in enterprise software). When Activities connect to this Service (using the bindService() method), this IBinder object is passed to them, and they can use it to get access to the Service process to call methods on it. Effectively, the binding process produces an object that represents that Service, so Activities can call methods on the Service without needing to send it Intents! As an example, let’s add the ability to “pause” the music being played as a bound service: The first thing we need to do is have our Service implement the onBind() method. To do this, we will need an IBinder object to return (that is: an object of a class that implements the IBinder interface). For “local services” (e.g., Services that are run in the same process), the easiest way to get an IBinder is to extend the Binder class: public class MyBinder extends Binder { //implements IBinder //binder class methods will go here! } private final IBinder mBinder = new MyBinder(); //singleton instance variable Our local version starts “empty” for now; we’ll add details below. We will just return this object from onBind(). Because the Activity is given a copy of this MyBinder object, that class can be designed to support the Activity communicating with the Service in a couple of different ways: The IBinder can provide public methods for the Activity to call. These methods can then access instance variables of the Service (since the MyBinder is a nested class). This causes the IBinder to literally act as the “public interface” for the Service! //in MyBinder public String getSongName() { return songName; //access Service instance variable } The IBinder can provide access to the Service itself (via a getter that returns the Service object). The Activity can then call any public methods provided by that Service class. //in MyBinder public MusicService getService() { // Return this instance of this Service so clients can call public methods on it! return MusicService.this; } The IBinder can provide access to some other object “owned” by the Service, which the Activity can then call methods on (e.g., the MediaPlayer). This is somewhat like a compromise between the first two options: you don’t need to implement a specific public interface on the IBinder, but you also don’t have to provide full access to your Service object! This is good for only exposing part of the Service. In the Activity, we need to do a bit more work in order to interact with the bound Service. We bind to a Service using bindService(Intent, ServiceConnection, flag). We can do this whenever we want the Service to be available (onStart() is a good option, so it is available when the Activity is active). The Intent parameter should be addressed to the Service we want to bind. The ServiceConnection parameter is a reference to an object that implements the ServiceConnection interface, providing callbacks that can be executed when the Activity connects to the Service. We can have the Activity implement the interface, or create a separate anonymous class: /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { // We&#39;ve bound to LocalService, cast the IBinder and get LocalService instance MyBinder binder = (MyBinder) service; mService = binder.getService(); mBound = true; } public void onServiceDisconnected(ComponentName arg0) { mBound = false; } }; The onServiceConnected() callback handles the actual connection, and is where we get access to that IBinder. We can use that IBinder to fetch the Service object to call methods on, saving that as an instance variable to do stuff to it! We’ll also track whether or not the Service has been bound to avoid any null errors. Finally, the flag parameter indicates some options for how the Service should be bound (e.g., for specifying survival priority). Conetxt.BIND_AUTO_CREATE is a good default, specifying that the binding should create the Service object if needed. Once a Service is bound, we can call methods on that Service (which must exist!)—allowing us to support the “pause” button. We should also call unbindService() when the Activity stops, in order to free up resources: protected void onStop() { if (mBound) { unbindService(this); } super.onStop(); } Keep in mind that binding a Service DOES NOT call onStartCommand(), but simply creates the Service and gives us access to it! Bound Services are not by default considered “started”, and are generally kept around by the OS as long as they are bound. If we do “start” a Bound Service (e.g., with startService()), we will need to remember to stop it later! This example is just for local services (that are accessed within the same process—within the same Application). If we want the Service to be available to other processes (i.e., other Applications), we need to do more work. Specifically, we use Handler and Messenger objects to pass messages between these processes (similar to the example we did for passing messages between threads); for more details, see the example in the guide, as well as the complete sample classes MessengerService and MessengerServiceActivities. https://developer.android.com/guide/components/services.html↩ https://developer.android.com/reference/android/os/AsyncTask.html↩ https://developer.android.com/guide/components/processes-and-threads.html↩ https://developer.android.com/images/service_lifecycle.png↩ https://developer.android.com/guide/components/services.html#ExtendingService↩ "],
["sensors.html", "Lecture 14 Sensors 14.1 Motion Sensors 14.2 Rotation", " Lecture 14 Sensors This lecture discusses how to access and utilize hardware sensors built into Android devices. These sensors can be used to detect changes to the device (such as its motion via the accelerometer) or its surrounding environment (such as the weather via a thermometer or barometer). Additionally, the system is structured so you can develop and connect your own sensor hardware if needed—such as connecting to a medical device or some other kind of tricorder. This lecture references code found at https://github.com/info448/lecture14-sensors. 14.1 Motion Sensors To continue to emphasize to mobility of Android devices (they can be picked up and moved, shook around, tossed in the air, etc.), this lecture will demonstrate how to use motion sensors to detect how an Android device is able to measure its movement. Nevertheless, Android does provide a general framework for interacting with any arbitrary sensor (whether built into the device or external to it); motion sensors are just one example. There are many different sensor types46 defined by the Android framework. The interfaces for these sensors are defined by the Android Alliance rather than Google, since the interface needs to exist between hardware and software (so multiple stakeholders are involved). In particular, we’ll focus on using the accelerometer, which is used to detect acceleration force (e.g., how fast the device is moving in some direction). This sensor is found on most devices, and has the added benefit of being a relatively “low-powered” sensor—its ubiquity and low cost of usage makes it ideal for detecting motions! The accelerometer is an example of a motion sensor, which is used to detect how the device moves in space: tilting, shaking, rotating, or swinging. Motion sensors are related to but different from position sensors, which determine where the device is in space: for example, the device’s current rotation, facing, or proximity to another object (e.g., someone’s face). Position sensors different from location sensors (like GPS) in that they measure position relative to the device rather than relative to the world. It is also possible to detect motion using a gravity sensor (which measures the direction of gravity relative to the device), a gyroscope (measures the rate of spin of the device), or a number of other sensors. However, the accelerometer is the most common and can be used in combination with other sensors as needed. We do not need any special permissions to access the accelerometer. But because our app will rely on a certain piece of hardware that—while common—may not be present on every device, we will want to make sure that anyone installing our app (e.g., from the Play Store) has that hardware. We can specify this requirement in the Manifest with a &lt;uses-feature&gt; element: &lt;uses-feature android:name=&quot;android.hardware.sensor.accelerometer&quot; android:required=&quot;true&quot; /&gt; This declaration doesn’t actually prevent the user from installing the app, though it will cause the Play Store to list it as “incompatible”. Effectively, it’s just an extra note. Accessing Sensors In Android, we start working with sensors by using the SensorManager47 class, which will tell us information about what sensors are available, as well as let us register listeners to record sensor readings. The class is actually a Service provided by the Android System which manages all of the external sensors—very similar to the FragmentManager used to track fragments and the NotificationManager used to track notifications. We can get a reference to the SensorManager object using: mSensorManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE); Just like how we accessed the Notification Service, we ask the Android System to “get” us a reference to the Sensor Service, which is a SensorManager. The SensorManager class provides a number of useful methods. For example, the SensorManager#getSensorList(type) method will return a list of sensors available to the device (the argument is the “type” of sensor to list; use Sensor.TYPE_ALL to see all sensors). The sensors are returned as a List&lt;Sensor&gt;—each Sensor48 object represents a particular sensor installed on the device. The Sensor class includes information like the sensor type (which is not represented via subclassing, because otherwise we couldn’t easily add our own types! Composition over inheritance). Devices may have multiple sensors of the same type; in order to access the “main” sensor, we use the SensorManager#getDefaultSensor(type) method. This method will return null if there is no sensor of that type (allowing us to check if the sensor even exists), or the “default” Sensor object of that type (as determined by the OS and manufacturer). mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); If no valid sensor is available, we can have the Activity close on its own by calling finish() on it. In order to get readings from the sensor, we need to register a listener for the event that occurs when a sensor sample is available. We can do this using the SensorManager: mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_NORMAL); The first parameter is a SensorEventListener, which will handle the callbacks when a SensorEvent (a reading) is produced. It is common to make the containing Activity the listener, and thus have it implement the interface and its two callbacks (described below). The second parameter is the sensor to listen to, and the third parameter is a flag indicating how often to sample the environment. SENSOR_DELAY_NORMAL corresponds to a 200,000 microsecond (200ms) delay between samples; use SENSOR_DELAY_GAME for a faster 20ms delay (e.g., if making a motion-based game). Important be sure to unregister the listener in the Activity’s onPause() callback in order to “turn off” the sensor when it is not directly being used. Sensors can cause significant battery drain (even if the accelerometer is on the low end of that), so it is best to minimize resource usage. Equivalently, you can register the sensor in the onResume() function to have it start back up. We can utilize the sampled sensor information by filling in the onSensorChanged(event) callback. This callback is executed whenever a new sensor reading occurs (so possibly 50 times a second)! The onAccuracyChanged() method is used to handle when the sensor switches modes in some way; we will leave that blank for now. In the onSensorChanged() method, sensor readings are stored in the sensorEvent.values variable. This variable is an array of floats, but the size of the array and the meaning/range of its values are entirely depending on the sensor type that produced the event (which can be determined via the sensorEvent.sensor.getType() method). When working with the accelerometer, each element in the float[] is the acceleration force (in \\(m/s^2\\)) along each of the three Cartesian axes (x, y, and z in order): Coordinate system (relative to a mobile device). Image from source.android.com49. Composite Sensors If you Log out these coordinates while the phone sitting flat on a table (not moving), you will notice that the numbers are not all 0.0. This is because gravity is always exerting an accelerating force, even when the device is at rest! Thus in order to determine the actual acceleration, we would need to “factor out” the force due to gravity. This requires a little bit of linear algebra; the Android documentation has an example of the math (and an additional version can be found in the sample app). However, an easier solution is to utilize a second sensor. For example, we can read the current force due to gravity from a magnetometer or a gyroscope, and then do some math to subtract that reading from the accelerometer. We can effectively combine these two sets of readings by listening not to the accelerometer, but to the Linear acceleration sensor instead. This is an example of a composite sensor, a “virtual” sensor that combines readings from multiple pieces of hardware to produce useful results. Composite sensors allow us to query a single sensor for a set of data, even if that data is being synthesized from multiple other sensor components (similar to how the FusedLocationApi allows us to get location from multiple location receivers). For example, the linear acceleration sensor uses the accelerometer in combination with the gyroscope (or the magnetometer if there is no gyroscope). This sensor is thus able to sample the acceleration independent of gravity automatically. It is theoretically possible for a device to provide dedicated hardware for a composite sensor, but no distinction is made by the Android software. The source of the sensor readings is abstracted. Note that not all devices will have a linear acceleration sensor! Android provides many such compound sensors, and they are incredibly useful for simplifying sensor interactions. 14.2 Rotation Acceleration is all good and well, but it only detects motion when the phone is moving. If we tilt the phone to one side, it will measure that movement… but then the acceleration goes back to 0 since the phone has stopped moving. What if we want to detect something like the tilt of the device? The gravity sensor (TYPE_GRAVITY) can give this information indirectly by specifying the direction of gravity (which way is down), but it is a bit hard to parse meaning from the values. So a better option is to use a Rotation Vector Sensor. This is another composite (virtual) sensor that is used to determine the current rotation (angle) of the device by combining readings from the accelerometer, magnetometer, and gyroscope. After registering a listener for this sensor, we can see that the onSensorChanged(event) callback once again provides three float values from the sensed event. These values represent the phone’s rotation in quaternions. This is a lovely but complex coordinate system (literally complex: it uses imaginary numbers to measure angles). Instead, we’d like to convert this into rotation values that we understand, such as the degrees of device roll, pitch, and yaw50. Our approach will be somewhat round-about, but it is useful for understanding how the device measures and understands its motion. In computer systems, rotations are almost always stored as matrices (a mathematical structure that looks like a table of numbers). Matrices can be used to multiply vectors to produce a new, transformed vector—the matrix represents a (linear) mapping. Because a “direction” (e.g., the phone’s facing) is represented by a vector, that direction can be multiplied by a matrix to represent a “change” in the direction. A matrix that happens to correspond with a transformation that rotates a vector by some angle is called a rotation matrix. Derivation of a 2D rotation matrix. You can actually use matrices to represent any affine transformation (including movement, skewing, scaling, etc)… and these transformations can be specified for things like animation. 30% of doing 3D Computer Graphics is simply understanding and working with these transformations. Luckily, we don’t actually need to know any of the math for deriving rotation matrices, as Android has a built-in method that will automatically produce a rotation matrix from a the rotation quaternion provided by the rotation vector sensor: SensorManager.getRotationMatrixFromVector(targetMatrix, vector) This method takes in a float[16], representing a 4x4 matrix (one dimensions for each axis x, y, and z, plus one dimension to represent the “origin” in the coordinate system. These are known as homogenous coordinates). This array will be filled with the resulting values of the rotation matrix. The method doesn’t produce a new array because allocating memory is time-intensive—so you need to provide your own (ideally reused) array. A 4x4 rotation matrix may not seem like much of an improvement towards getting human-readable orientation angles. So as a second step we can use the SensorManager.getOrientation(matrix, targetArray) method to convert that rotation matrix into a set of radian values that are the angles the phone is rotated around each axis—thereby telling us the orientation. Note this method also takes a (reusable) float[3] as a parameter to contain the resulting angles. The resulting angles can be converted to degrees and outputted using some basic Math and String functions: String.format(&quot;%.3f&quot;,Math.toDegrees(orientation[0]))+&quot;\\u00B0&quot; //include the degree symbol! The rotation vector sensor works well enough, but another potential option in API 18+ is the Game rotation vector sensor. This compound sensor is almost exactly the same as the ROTATION_VECTOR sensor, but it does not use the magnetometer so is not influenced by magnetic fields. This means that rather than having “0” rotation be based on compass directions North and East, “0” rotation can be based on some other starting angle (determined by the gyroscope). This can be useful in certain situations where magnetic fields may introduce errors, but can also involve gyroscope-based sampling drift over time. We can easily swap this in, without changing most of our code. We can even check the API version dynamically in Java using: if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) { //... API 18+ } This strategy is useful for any API dependent options, including external storage access and SMS support! Coordinates As illustrated above, motion sensors use a standard 3D Cartesian coordinate system, with the x and y axes matching what you expect on the screen (with the “origin” at the center of the phone), and the z coming out of the front of the device (following the right-hand rule as a proper coordinate system should). However, there are a few “gotchyas” to consider. For example, note that the values returned by the getOrientation() method are not in x,y,z order (but instead in z, x, y order)—and in fact represent rotations around the -x and -z axes. This is detailed in the documentation, and can be confirmed through testing. Thus you need to be careful about exactly what units you’re working with when accessing a particular sensor! Moreover, the coordinate system used by the sensors is based on the device’s frame of reference, not on the Activity or the software configuration! The x axis always goes across the “natural” orientation of the device (portrait mode for most devices, though landscape mode for some tablets), and rotating the device (e.g., into landscape mode) won’t actually change the coordinate system. This is because the sensors are responding to the hardware’s orientation, and not considering the software-based configuration. One solution to dealing with multiple configurations is to use the SensorManager#remapCoordinateSystem() method to “remap” the rotation matrix. With this method, you specify which axes should be transformed into which other axes (e.g., which axes will become the new x and y), and then pass in a rotation matrix to adjust. You can then fetch the orientation from this rotation matrix as before. You can determine the device’s current orientation with Display#getRotation() method: Display display = ((WindowManager) getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay(); display.getRotation(); It is also common for some motion-based applications (such as games or other graphical systems) to be restricted to a single configuration, so that you wouldn’t need to dynamically handle coordinate systems within a single device. https://source.android.com/devices/sensors/sensor-types.html↩ https://developer.android.com/reference/android/hardware/SensorManager.html↩ http://developer.android.com/reference/android/hardware/Sensor.html↩ https://developer.android.com/images/axis_device.png↩ https://en.wikipedia.org/wiki/Aircraft_principal_axes↩ "],
["graphics.html", "Lecture 15 Graphics and Touch 15.1 Drawing Graphics 15.2 Touch and Gestures 15.3 Property Animation", " Lecture 15 Graphics and Touch This lecture discusses some different ways to add “visual motion” (graphical animation) to Android applications. It covers 2D drawing with custom Views, Property Animations (also used in Material effects), and how to handle touch-based gestures. This lecture references code found at https://github.com/info448/lecture15-graphics. 15.1 Drawing Graphics Android provides a 2D Graphics API similar in both spirit and usage to the HTML5 Canvas API: it provides an interface by which the developer can programmatically generate 2D, raster-based images. This API can be used for drawing graphs, showing manipulated images, and even performing animations! As in HTML5, in Android this API is available via the Canvas51 class. Similar to the HTML5 &lt;canvas&gt; element or the Java SE Graphics2D class, the Android Canvas provides a graphical “context” upon which the developer can “draw” rectangles, circles, and even images (Bitmaps) to be shown on the screen. Custom Views In order to draw pictures, we need to have a View to draw on (which will provide the Canvas context). The easiest way to get this View is to create it ourselves: define a custom View which we can specify as having a “drawn” appearance. We can make our own special View by subclassing it (remember: Buttons and EditTexts are just subclasses of View!), and then filling in a callback function (onDraw()) that specifies how that View is rendered on the screen. The word render in this case means to “bring into being”, meaning to generate a graphical image and putting it on the screen. Customizing a View isn’t too hard, but to save time a complete example is provided in the lecture code in the form of the DrawingView class. Notes about this classes implementation are below: The class extends View to subclass the base View class. Also notice how we specify a custom view as a &lt;view&gt; element in the Layout XML, indicating the class attribute. View has a number of different of constructors. We override them all, since each one is used by a different piece of the Android system (and thus we need to provide custom implementations for each). However, we’ll have each call the “last” one in order to actually do any setup. In the constructor we set up a Paint, which represents how we want to draw: color, stroke width, font-size, anti-aliasing options, etc. We’ll mostly use Paint objects for color. We override the onSizeChanged() callback, which will get executed when the View changes size. This occurs on inflation (which happens as part of an Activity’s onCreate, meaning the callback will be called on rotation). This callback can act a little bit like a Fragment’s onCreateView(), in that we can do work that is based on the created View at this point. We should also override the onMeasure() callback, as recommend by the Android guides. This callback is used to specify how the View should be sized in response to its width or height being set as wrap_content. This is particularly important for making things like custom Buttons. However, our example will skip this for time and space, since the DrawingView is intended to always take up the entire screen. Finally, we override onDraw(), which is where the magic happens. This method gets called whenever the View needs to be displayed (like paintComponent() in the Swing framework). This callback is passed a Canvas object as a parameter, providing the context we can draw on! Like all other lifecycle callbacks: we never call onDraw()!! The Android UI system calls it for us! The provided Canvas can be drawn on in a couple of ways: We can call methods like drawColor() (to fill the background), drawCircle(), or drawText() to draw specific shapes or entities on it. These methods are similar in usage to the HTML5 Canvas. We can also draw a Bitmap, which represents a graphics raster (e.g., a 2D array of pixels). If we have a Bitmap, we can set the colors of individual pixels (using setPixel(x,y,color)), and then draw the Bitmap onto the Canvas (thereby double-buffering!). This is useful for pixel-level drawing, or when you want to make more complex graphics or artwork. If you’ve used MS Paint, it’s the difference between the shape drawing options and the “zoomed in” pixel coloring. Note that we cause the Canvas to be “redrawn” (so our onDraw() method to be called) by calling invalidate() on the View: this causes Android to need to recreate it, thereby redrawing it. By repeatedly calling invalidate() we can do something approximating animation! We can do this via a recursive loop by calling invalidate() at the end of onDraw(). This lets us “request” that Android cause onDraw() to be called again once it is finished, but we don’t call it. As a demo, we can make the Ball slide off the screen by changing it’s position slightly: ball.cx += ball.dx; ball.cy += ball.dy; We can also add in wall collisions: if(ball.cx + ball.radius &gt; viewWidth) { //left bound ball.cx = viewWidth - ball.radius; ball.dx *= -1; } else if(ball.cx - ball.radius &lt; 0) { //right bound ball.cx = ball.radius; ball.dx *= -1; } else if(ball.cy + ball.radius &gt; viewHeight) { //bottom bound ball.cy = viewHeight - ball.radius; ball.dy *= -1; } else if(ball.cy - ball.radius &lt; 0) { //top bound ball.cy = ball.radius; ball.dy *= -1; } Animation is the process of “imparting life” (from the Latin “anima”). We tend to mean giving something motion—making an object appear to move over time. Consider what that means for how people understand “life”. Video animation involves showing a sequences of images over time. If the images go fast enough, then the human brain interprets them as being part of the same successive motion, and any objects in those images will be considered to be “moving”. Each image in this sequence is called a “frame”. Film tends to be 24 frames per second (fps), video is 29.97fps, and video games aim at 60fps. Any video running at at least 16fps will be perceived as mostly smooth motion. Hitting that 16fps can actually be pretty difficult, since determining what to draw is computationally expensive! If we’re calculating every pixel on a 600x800 display, that’s half a million pixels we have to calculate! At 60fps, that’s 28 million pixels per second. For scale, a 1Ghz processor can do 1 billion operations per second—so if each pixel requires 5 operations, we’re at 15% of our processor. This is part of why most graphical systems utilize a dedicated GPU (graphical processing unit)—it provides massive parallelization to speed up this process. SurfaceViews Since all this calculation (at pixel-level detail) can take some time, we want to be careful it doesn’t block the UI thread! We’d like to instead do the drawing in the background. The rendering itself needs to occur on the UI Thread, but we want all of the drawing logic to occur on the background thread, so that the UI work is as fast as possible (think: hanging up a pre-printed poster rather than needing to print it entirely). However, an AsyncTask isn’t appropriate, because we want to do this repeatedly. Similarly, an IntentService may not be able to respond fast enough if we need to wait for the system to deliver Intents. Android provides a class that is specially designed for being “drawn” on a background thread: the SurfaceView. Unlike basic Views that are somewhat ephemeral, a SurfaceView includes a dedicated drawing surface that we can interact with in a separate thread. It is designed to support this threading work without requiring too much synchronization code. These take even more work to setup, so a complete example (DrawingSurfaceView) is again provided in the lecture code: This class extends SurfaceView and implements SurfaceHolder.Callback. A SurfaceHolder is an object that “holds” (contains) the underlying drawable surface; somewhat similar to the ViewHolder pattern utilized with an Adapter. We interact with the SurfaceView through the holder to make sure that we’re thread-safe: that only one thread is interacting with the surface at a time. In general there will be two threads trading off use of the holder: our background thread that is drawing on the surface (“printing the poster”), and then UI thread that is showing the surface to the user (“hanging the printed poster”). You can think of the holder as the poster in this metaphor! We register the holder in the constructor with the provided getHolder() method, and register ourselves for callbacks when the holder changes. We also instantiate a new Runnable, which will represent the callback executed in a separate (background) thread to do the drawing. The SurfaceHolder.Callback interface requires methods about when the surface changes, and so we fill those in: onSurfaceCreated() starts our background thread (because the surface has now been created) onSurfaceChanged() ends up acting a lot like onSizeChanged() from the basic DrawingView onSurfaceDestroyed() stops the background thread in a “safe” way (code adapted from Google) If we look at the Runnable, it’s basically an infinite loop: Grab the Surface’s Canvas, “locking” it so only used in this (background) thread. Draw on it. Then “push” the Canvas back out to the rest of the world, basically saying “we’re done drawing, you can show it to the user now”. Overall, this process will cause the Surface to “redraw” as fast as possible, all without blocking the UI thread! This is great for animation, which can be controlled and timed (e.g., in the update() helper method by only updating variables at a particular rate). Moreover, it provides a drawable surface that can be interacted with! And that gives us a drawable surface that we can interact with in the same way, using the same kind of movement/interaction logic. This demonstrates one way to create low-level game and animation logic using basic Java work; no specific game engines are required (though those exist as well). 15.2 Touch and Gestures As this point we have some simple animation and movement, but we would like to make it more interactive. Our View takes up the entire screen so we don’t want to add buttons, but there are other options available. In particular, we can add Touch Gestures. Touch screens are a huge part of Android devices (and mobile devices in general, especially since the first iPhone) that are familiar to most users. We’ve already indirectly used the touch interface, with how we’ve had users click on buttons (theoretically using the touch screen). But here we’re interested in more than just button clicks, which really could come from anywhere. Instead, we’re interested in how we can react to where the user might touch the screen, and even the different ways the user might caress the screen: flings, drags, multi-touch, etc. Android devices automatically detect various touching interactions (that’s how buttons work); we can respond to these touch events by overriding the onTouchEvent() callback, which is executed whenever there something happens that involves the touch screen. For example, we can log out the event to see the kind of details it includes. There are lots of things that can cause TouchEvents, so much of our work involves trying to determine what semantic “gesture” the user made. Luckily, Android provides a number of utility methods and classes to help with this. The most basic is MotionEvent#getActionMasked(), which extracts the “action type” of the event from the motion that was recorded: int action = motionEvent.getActionMasked(); //get action constant float x = event.getX(); //get location of event float y = event.getY() - getSupportActionBar().getHeight(); //closer to center... switch(action) { case (MotionEvent.ACTION_DOWN) : //put finger down //e.g., move ball view.ball.cx = x; view.ball.cy = y; return true; case (MotionEvent.ACTION_MOVE) : //move finger //e.g., move ball view.ball.cx = x; view.ball.cy = y; return true; case (MotionEvent.ACTION_UP) : //lift finger up case (MotionEvent.ACTION_CANCEL) : //aborted gesture case (MotionEvent.ACTION_OUTSIDE) : //outside bounds default : return super.onTouchEvent(event); } This lets us react to basic touching. For example, we can make it so that taps (ACTION_DOWN) will “teleport” the ball to where we click! We can also use the ACTION_MOVE events to let us drag the ball around. Advanced Gestures We can also detect and react to more complex gestures: long presses, double-taps, or “flings” (a flick or swipe on the screen). As with basic gestures, the Material Design specification details some specific patterns that you should consider when utilizing these interactions. Android provides a GestureDetector class that can be used to identify these actions. The easiest way to use this class—particularly when we’re interested in a particular gesture (like fling)—is to extend GestureDetector.SimpleOnGestureListener to make our own “listener” for gestures. We can then override the callbacks for the gestures we’re interested in responding to: e.g., onFling(). Note that the official documentation says we should also override the onDown() method and have it return true to indicate that we’ve “consumed” (handled) the event—similar to what we’ve done with OptionsMenus. If we return false from this method, then “the system assumes that you want to ignore the rest of the gesture, and the other methods of GestureDetector.OnGestureListener never get called.” However, in my testing the gesture detection works either way, but we’ll follow the spec for now. We can instantiate a GestureDetector by passing in our listener into a GestureDetectorCompat constructor: mDetector = new GestureDetectorCompat(this, new MyGestureListener()); Then in the Activity’s onTouchEvent() callback, we can pass the event into the Gesture Detector to process: boolean gesture = this.mDetector.onTouchEvent(event); //check gestures first! if(gesture){ return true; } Since the detector’s onTouchEvent() returns a boolean for whether or not a gesture was detected, we can check for whether we should otherwise handle the gesture ourselves. This gives us the ability to “fling” the Ball by taking the detected fling velocity and assigning that as the Ball’s velocity. Note that we need to negate the velocities since they are registered as “backwards” from the coordinates our drawing system is utilizing (though this doesn’t match the documented examples). Scaling down the velocity to 3% produce a reasonable Ball movement speed for me. We can also have the Ball slow down by 1% on each update so it drifts to a stop! 15.3 Property Animation We’ve seen how we can create animations simply by adjusting the drawing we do on each frame. This is great for games or other complex animations if we want to have a lot of control over our graphical layout… but sometimes we want to have some simpler, platform-specific effects (that run smoother!) Android actually involves a number of different animation systems that can be used within and across Views: We’ve previously talked about some Material Animations built into the Material Design support library; in particular we discussed creating Activity transition. Android also includes a robust framework for Scene Transitions even outside of Material; see Adding Animations for more details. Android also supports OpenGL Animations for doing 3D animated systems. This requires knowing the OpenGL API. In this section, we will discuss how to use Property Animation. This is a general animation framework in which you specify a start state for an Object property (attribute), an end state for that property, and a duration for the animation; the Android systems then changes the property from the start state to the end over that length of time—thereby producing animation! The change in property state over time (that is, at any given “frame”) is calculated using interpolation. This is basically a “weighted average” between the the start and end states, where the weight is determined by how close you are to the “start” or “end”. While we often use linear interpolation (so that being 70% across means the end gets 70% of the weight), it is also possible to use non-linear interpolation) (e.g., you need to get 70% across in for the end to have 50% of the weight). Linearly interpolating colors The main engine for doing this kind of interpolated animation in Android is the ValueAnimator52 class. This class lets you specify the start state, end state, and animation duration. It will then be able to run through and calculate all of the “intermediate” values throughout the interpolated animation. The ValueAnimator class provides a number of static methods (e.g., .ofInt(), .ofFloat(), .ofArgb()) which creates “animators” for interpolating different value types. For example: ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f); //interpolate between 0 and 1 animation.setDuration(1000); //over 1000ms (1 second) animation.start(); //run the animation Of course, just performing this interpolation over time doesn’t produce any visible result—it’s changing the numbers, but those numbers don’t correspond to anything. We can access the interpolated values by registering a listener and overriding the callback we’re interested in observing (e.g., onAnimationUpdate() from ValueAnimator.AnimatorUpdateListener). But more commonly, we want to have our interpolated animation change the property of some object—for example, the color of a View, the position of an Button, or the instance variables of an object such as a Ball. We can do this easily using the ObjectAnimator53 subclass. This subclass runs an animation just like the ValueAnimator, but has the built-in functionality to change a property of an object on each interpolated step. It does this by calling a setter for that property—thus the object needs to have a setter method for the property we want to animate: //change the &quot;alpha&quot; property of foo: will call `foo.setAlpha(float)` ObjectAnimator anim = ObjectAnimator.ofFloat(foo, &quot;alpha&quot;, 0f, 1f); anim.setDuration(1000); anim.start(); This example will mutate the object by calling the setAlpha() method (the name of the method is generated from the property name following normal CamelCasing style). If the object lacks such a setter, such as because we are using a class provided by someone else, we can either make a “wrapper” which will call the appropriate mutating function, or just utilize a ValueAnimator with an appropriate listener. For example, we can use this approach to change the circle’s size or position using an interpolated animation (make it “pulse”). Note that we’re just changing the object property; the only reason we see the changed drawing is because Android is constantly refreshing our SurfaceView. The ObjectAnimator interpolator methods support a number of variations as well: As long as the object has an appropriate getter, it is possible to only pass the Animator an ending value (indicating that the animation should interpolate “from current state to specified end state”) We can use .setRepeatCount(ObjectAnimator.INFINITE) and .setRepeatMode(ObjectAnimator.REVERSE) to cause it to repeat back and forth. If we want to include multiple animations in sequence, we can use an AnimatorSet, which gives us methods used to specify the ordering: //example from docs ObjectAnimator animX = ObjectAnimator.ofFloat(obj, &quot;x&quot;, 50f); ObjectAnimator animY = ObjectAnimator.ofFloat(obj, &quot;y&quot;, 100f); AnimatorSet animSetXY = new AnimatorSet(); animSetXY.playTogether(animX, animY); animSetXY.start(); AnimatorSet animations can get complicated, and we may want to reuse them. Thus best practice is to instead define them in XML as resources. Animation resources are put inside the /res/animator directory (not the /res/anim/ folder, which is for View Animations). &lt;set android:ordering=&quot;together&quot;&gt; &lt;!-- together is default --&gt; &lt;objectAnimator android:propertyName=&quot;x&quot; android:duration=&quot;500&quot; android:valueTo=&quot;400&quot; android:valueType=&quot;intType&quot;/&gt; &lt;!-- ... --&gt; &lt;/set&gt; See Property Animation Resources54 for the full XML schema. Note that by defining animations as resources, it also means that we can easily have different device configurations use different animations (e.g., perhaps objects move faster on larger displays). In order to utilize the XML, we will need to inflate the Animator resource, just as we have done with Layouts: ObjectAnimator anim = (ObjectAnimator)AnimatorInflater.loadAnimator(context, R.anim.my_animation); anim.setTarget(myObject); anim.start(); Note that we can also use this same framework to animate changes to Views: Buttons, Images, etc. Views are objects and have properties (along with appropriate getter and setter methods), so we can use just an ObjectAnimator! See Animating Views for a list of properties we can change (a list that includes x, y, rotation, alpha, scaleX, scaleY, and others) To make this process even simpler, Android also provides a ViewPropertyAnimator class. This Animator is able to easily animate multiple properties together (at the same time), and does so in a much more efficient way. We can access this Animator via the View#animate() method. We then call relevant shortcut methods on this Animator to “add in” addition property animations to the animation set: //animate x (to 100) and y (to 300) together! myView.animate().x(100).y(300); This allows you to easily specify moderately complex property animations for View objects. But really, if you want to animate layout changes on a modern device, you should use transitions, such as the ones we used with Material design. There are many more ways to customize exactly what you want your animation to be. You can also look at official demos for more examples of different styles of animation. https://developer.android.com/reference/android/graphics/Canvas.html↩ http://developer.android.com/guide/topics/graphics/prop-animation.html#value-animator↩ http://developer.android.com/guide/topics/graphics/prop-animation.html#object-animator↩ http://developer.android.com/guide/topics/resources/animation-resource.html#Property↩ "],
["styles-themes.html", "Lecture 16 Styles &amp; Themes 16.1 Defining Styles 16.2 Themes Resources", " Lecture 16 Styles &amp; Themes In this chapter you will learn to use Android Styles &amp; Themes to easily modify and abstract the appearance of an app’s user interfaces—that is, the XML resource attributes that define what your Views look like. This tutorial will walk you through creating and using styles to modify views, though you should also reference the official documentation for more details and examples. The code for this tutorial can be found at https://github.com/info448/lab-styles. You will be working almost exclusively with the XML resources (e.g., res/layout/activity_main.xml) in the provided code, so make sure to look those over before you begin. The main layout describes a very simple screen showing a pile of TextViews organized in a RelativeLayout. 16.1 Defining Styles If you look at the TextViews, you’ll see that they share a lot of the same attributes: text sizing, width and height, boldness, etc. If you decided that all of the text should be bigger (e.g., for readability), then you’d need to change 6 different attributes—which is a lot of redundant work. Enter Styles. Styles encapsulate a collection of XML properties, allowing you to define a set of properties once and then use a single attribute to apply all of those properties to a view. This provides almost the same functionality as a CSS rule describing a class declaration, but without the “cascading” part. Styles are themselves defined as an XML resource&amp;mdsah;specifically a &lt;style&gt; element inside the res/values/styles.xml file. This XML file was created for us when Android Studio created the project. Open the file, and you can see that it even has some initial content in it! Style resource files, like String resource files, use &lt;resource&gt; as a top-level element, declaring that this XML file contains (generic-ish) resources to use. Styles are declared with a &lt;style&gt; tag, which represents a single style. You can almost think of this as a “class” in CSS (though again, without the cascading behavior). The &lt;style&gt; element is given a name attribute, similar to how we’d define a CSS class name. Names are normally written using PascalCase: they need to be legal Java identifiers since they will be compiled into R, and since they are “classes” we capitalize them! We’ll discuss the parent attribute in the starter code in the next section. We define &lt;item&gt; elements as nested children of the &lt;style&gt; element. Each &lt;item&gt; represents a single attribute we want our style to include, similar to a single property of a CSS rule. &lt;item&gt; elements get a name attribute which is the the name of the property you want to include. For example: name=&quot;android:layout_width&quot; to specify that this item refers to the layout_width attribute. The content of the &lt;item&gt; tag is the value we want to assign to that attribute, e.g., wrap_content (not in quotes, because the content of an XML tag is already a String!) Finally, you can specify that you want a particular View (e.g., in your layout) to have a style by giving that View a style attribute, with a value that references the style that you’ve defined (using @style/..., since this resource has type “style”). Note that the style attribute does not use the android namespace! Practice: Define a new style (e.g., TextStyle) that specifies the attributes shared by the 6 TextViews: the text size, the width, and the height. Additionally, have the style define the text color as UW purple. Then, refactor these TextViews so that they use the style you just defined instead of duplicating attributes. See how much code you’ve saved? After you’ve done that, go ahead and change the size of all the TextViews to be 22sp. You should be able to make this change in exactly one place! Style Inheritance This is a good start, but we still have some duplicated attributes—in particular, the “labels” share a couple of attributes (e.g., they are all bold). Since each View can only have a single style and there is no cascading, if we wanted to create a separate LabelStyle style, it would end up duplicating some attributes of the TextStyle (size and color). Ideally we would like to not have to redefine a style if it only changes a little bit. Luckily, while styles don’t cascade, they can inherit items from one another (a la Java inheritance, e.g., extends). We can establish this inheritance relationship by specifying the parent attribute for the &lt;style&gt;, and having it reference (with @) the “parent” style: &lt;style name=&quot;ChildStyle&quot; parent=&quot;@style/ParentStyle&quot;&gt; ... &lt;/style&gt; This will cause the ChildStyle to include all of the &lt;item&gt; elements defined in the parent style. We can then “override” the inherited properties by redefining the &lt;item&gt; you want to change, just like when inheriting and overriding Java methods. When inheriting from our own custom styles (e.g., ones that we’ve defined within the same package), it’s also possible to use Dot Notation instead of the parent attribute. For example, naming a style ParentStyle.ChildStyle will define a style (ChildStyle) that inherits from ParentStyle. This would be referenced in the layout as @style/ParentStyle.ChildStyle. The dot notation is used to “namespace” the inherited class as if it were a “nested” class we wanted to reference. We can chain these together as much as we want: MyStyle.Red.Big is a style that inherits from Red and MyStyle. However, this style cannot also be referenced as MyStyle.Big.Red style—it’s not using a CSS class selector, but Java class inheritance! Note that often name style classes based on this namespaced inheritance, so the “child class” is named after an adjective (e.g., Big) that is used to describe the appearance change of the parent element. Text.Big would be an appropriate style naming convention. Pratice: Define another style (e.g., Label) that inherits from your first style to encapsulate attributes shared by the labels (e.g., boldness). Refactor your layout so that the labels use this new style. Define another style (e.g., Gold) that inherits from your Label’s style and has a background color that is UW Gold and a text color of black. Apply this style to one of your labels. It is best to utilize styles for elements that share semantic meaning, not just specific attributes! For example, buttons and labels that will be duplicated, headers shared across screens, etc. This will help you avoid needing to frequently change or overwrite styles in the future just because you want to make one button look different; changes to the style should reflect changes to the appearance of semantic elements. This is the same guideline that is used for determining whether you should define a CSS class or not! This blog post has a good summary. Built-in Styles Android also includes a large number of built-in platform styles that we can apply and/or inherit from. These must be inherited via the parent attribute (you can’t use dot notation for them). They are referenced with the format: &lt;style name=&quot;MyStyle&quot; parent=&quot;@android:style/StyleName&quot;&gt;...&lt;/style&gt; There are a bunch of these, all of which are defined in the R.style. This makes discoverability difficult, as not all of the styles are documented. To understand exactly what style effects you’re inheriting, Android recommends you browse the source code and seeing how they are defined. Yes, this is like trying to learn Bootsrap by reading the CSS file. Author’s opinion: most of the styles are not very effective bases for inheritance; you’re often better using your own. Practice: Define a new style for the Button at the bottom of the screen that inherits from the built-in MediaButton style (but give it a text size of 22sp). What does the inheritance do to the appearance? Styles for Text Views If your style primarily is defining text appearance attributes such as font size or text color, you alternatively have the option to utilize the android:textAppearance attribute instead. This attribute is available only on TextView elements (including subclaseses such as EditText or Button), and should be assigned a reference to a &lt;style&gt; element. Moreover, a View can have both a style and a textAppearance—in effect letting you apply two different styles to the same element! &lt;!-- for example, inherit from built-in TextAppearance style --&gt; &lt;style name=&quot;MyTextAppearance&quot; parent=&quot;TextAppearance.AppCompat&quot;&gt; &lt;item name=&quot;android:textColor&quot;&gt;#0F0&lt;/item&gt; ... &lt;/style&gt; &lt;TextView style=&quot;@style/MyStyle&quot; android:TextAppearance=&quot;@style/MyTextAppearance&quot; /&gt; The intention of this attribute is to let you specify different broad styles for Views (e.g., whether buttons should be rounded, the backgrounds and padding of cards), but still be able to have unified text styling (font a size), as well as different “types” of fonts (e.g., Large or Small text). In practice, styles that purely modify text appearance should be applied view textAppearance, while all other styles should be applied via the style attribute/ 16.2 Themes Unlike CSS, Android styling is NOT inherited by child elements: that is, if you apply a style to a ViewGroup (a layout), that style will not be applied to all the child components of that ViewGroup. Thus you can’t “style” a layout and have the styling rule apply throughout the layout. The option that is available is to apply a that style as a Theme. Themes are styles that are applied to every View in a Context (an Activity or the whole Application). You can’t get any finer granularity of style sharing (without moving to per-View Styles). Theme styles will apply to every View in the context, though we can overwrite the styling for a particular View as normal. Themes are styles, and so are defined the exact same way (as &lt;style&gt; elements inside a resource XML file). You can define them in either styles.xml, theme.xml, or any other values file—resource filenames are arbitrary, and their content will still be compiled into R no matter which file the elements are defined in. Themes are applied to an Activity or Application by specifying an android:theme attribute in the Manifest (where the Activity/Application is defined). If you look at the starter project’s Manifest created by Android Studio, you’ll see that it already has a theme (AppTheme). In fact, this is the &lt;style&gt; that was provided inside styles.xml! Practice: Experiment with removing the theme attribute from the application. How does your app’s appearance change? NOTE: you will need to change MainActivity to subclass Activity, not AppCompatActivity, in order to fully adjust the theme. You might also try commenting out the stylings you applied to the individual TextViews to really see what happens. Material Themes Along with built-in styles, Android provides a number of platform-specific themes. And again, the somewhat unhelpful recommendation is to understand these by browsing the source code, or the list in R.style (scroll down to constants that start with Theme). One of the most useful set of Android-provided themes are the Material Themes. These are themes that support Google’s Material Design, a visual design language Google uses (or aims to use) across its products, including Android. Material themes were introduced in Lollipop (API 21) and so are only available on devices running API 21+ (though there are compatibility options). There are two main Material themes: @android:style/Theme.Material: a Dark version of the theme @android:style/Theme.Material.Light: a Light version of the theme And many variants: @android:style/Theme.Material.Light.DarkActionBar: a Light version with a Dark action bar (Dark backgroud, Light contents) @android:style/Theme.Material.Light.LightStatusBar: a Light version with a Light action bar (Light background, Dark contents) @android:style/Theme.Material.Light.NoActionBar: a Light version with no action bar. … etc. See R.style for more options (do a ctrl-f “find” for Material) Practice: Experiment with applying different material themes to your application How does your app’s appearance change? Give your application a Dark Material theme! Theme Attributes One of the big advantages of Themes is that they can be used to define theme attributes that can be referenced from inside individual, per-View Styles. This allows the Theme to effective “skin” the View. For example, a Theme could define a “color scheme” as a set of attributes; these attributes can then be referenced by the Style as e.g., “the primary color of the current theme”. Theme-level attributes are referenced in the XML using the ? symbol (in place of the @ symbol). For example: ?android:textColorPrimary will refer to the value of the &lt;item name=&quot;textColorPrimary&quot;&gt; element inside the Theme. Indeed, one of the advantages of the Material Themes is that they are implemented to utilize a small set of color theme attributes, making it incredibly easy to specify a color scheme for your app. See Customize the Color Palette for a diagram of what theme attributes color what parts of the screen. Note it is possible to apply a Theme to an individual View or ViewGroup, causing the theme attributes (and ONLY the theme attributes!) to be “inherited” by any child elements. This allows you to specify color palettes for specific parts of your layout. Practice: Redefine the colors in your custom Styles (from the first practice steps) so that they reference the theme attribute colors instead of purple and gold. What happens now when you change the application’s Material Theme between light and dark? Can you have the logo image reference those color theme attributes as well? Hint: use the tint attribute. Practice: Modify the provided AppTheme style (in styles.xml) with the following changes: Have it inherit from a Material Theme (your choice of which) Have it define theme attribute colors using the UW colors (purple and gold). Use these theme attribute colors to “Huskify” your app (including the colors in your custom Styles) Finally, set the theme of your app back to AppTheme—and you should now have a UW flavored app! Resources Styling Views on Android Without Going Crazy (blog post) "],
["fragment-viewpager.html", "Lecture 17 Fragments: ViewPager 17.1 Define a SearchFragment 17.2 Add the ViewPager and Adapter 17.3 Add User Interaction", " Lecture 17 Fragments: ViewPager In this chapter, you will practice working with Fragments and layouts. Specifically, you will modify the Movie application from Lecture 6 so that it uses a ViewPager, an interactive View offered by the Android Support Library that will allow you to “page” (swipe) through different Fragments. You will modify the application so that the user can swipe through a “search” screen, the list of search results, and the details about a particular movie. The code for this tutorial can be found at https://github.com/info448/lab-viewpager. Note that it is also possible to complete this tutorial directly on top of the complete branch of the Lecture 6 demo code. IMPORTANT NOTE: you should not modify the provided MovieListFragment or the DetailFragment classes (those Fragments are self-contained and so can be used in multiple layouts!). You will need to create one new Fragment though, and make substantial modifications to the MainActivity 17.1 Define a SearchFragment Your ViewPager will need to support three different Fragments. While the MovieFragment and DetailFragment have been defined already, you will need to create a third. Create a new Fragment called SearchFragment (use the File &gt; New &gt; Fragment &gt; Fragment (Blank) menu in Android Studio). Your SearchFragment will need to include the following components The layout for the Fragment should contain the search EditText and Button taken from the activity_main layout. You can add some layout_gravity to center the inputs. You should also remove the onClick XML attribute, as click handling will be specified in the Java. In the SearchFragment class, be sure to define a newInstance() factory method. The method doesn’t need to take any arguments (and thus you don’t need to specify an argument bundle). Typing newInstance will allow Android Studio to tab-complete the method! The SearchFragment will need to communicate with other Fragments, and thus you will need to define an interface (e.g., OnSearchListener) that the containing Activity can implement. This interface should support a single public method (e.g., onSearchSubmitted(String searchTerm)) which will allow the Fragment to pass the entered search term to the Activity. Remember to check that the containing Activity implements the interface in the Fragment’s onAttach() callback. Finally, in the onCreateView() callback, add a click listener to the button so that when it is clicked, it calls the onSeachSubmitted() callback function on the containing Activity (which you’ve established has that method!) Remember that you can call findViewById() on the root view. 17.2 Add the ViewPager and Adapter Your MainActivity will need to contain a ViewPager View (since all the other Views have been moved to Fragments!). Add a android.support.v4.view.ViewPager element in the activity_main.xml layout resource, finding this View in the Activity’s onCreate() callback. This will replace the previous FrameLayout that was used as a container. Just like with a ListView, a ViewPager requires a (custom) adapter in order to map from which “page” is shown to the Fragment that is rendered. Add a new inner class (e.g., MoviePagerAdapter) that subclasses FragmentStatePagerAdapter. As in the documentation example, You will need to provide a constructor that takes in a (Support) FragmentManager, and calls the appropriate super constructor. The getItem() function returns which Fragment is shown for a particular page number. You should implement this function so that page 0 shows a SearchFragment, page 1 shows a MovieListFragment, and page 2 shows a DetailsFragment. You can declare each of these three Fragments as instance variables, then simply return them from this method. It’s okay to “hard-code” this logic for the purposes of this demonstration. The getCount() function returns how many pages the Pager supports. Note that you will need to include some logic for this: before a search has occurred, there is only one page! After the search, there are two pages (the search and the results), and after a result option is selected there are three pages (the search, the results, and the details). Finally, we will be “replacing” Fragments inside the Pager as the user interacts with the app (e.g., changing the MovieListFragment to one with different search results)—such as by changing the objects that the instance variables refer to. However, the ViewPager “preloads” adjacent Fragment pages as an optimization technique; thus it “caches” the Fragments and won’t actually load any updated Views. As a work-around, override the getItemPosition() function (which is called whenever the Pager needs to determine if an item’s position has changed): public int getItemPosition(Object object) { return POSITION_NONE; } Note that this is a memory-intensive workaround (but works for demonstration purposes); for a cleaner solution, see this discussion. Once you’ve defined the your adapter, instantiate it in the Activity’s onCreate() callback, and use ViewPager#setAdapter() to specify the Pager’s adapter. If you also instantiate a SearchFragment in the onCreate() callback, then you should be able to run the application and see that Fragment appear as a page (though there is nothing else to swipe to yet). 17.3 Add User Interaction Finally, you will need to adjust the Fragment callback methods inside the Activity (e.g., onSearchSubmitted() and onMovieSelected()) so that they interact with the ViewPager. This will involve removing previous code (the ViewPager does not need to utilize FragmentTransactions). When the search term is submitted from the SearchFragment, your Activity should instantiate a new (potentially different) MovieListFragment result list for that search term. The PagerAdapter should return an appropriate page count depending on whether a result list has been instantiated or not. However, simply creating a different Fragment will not cause the Adapter to change—you need to let the Adapter know that the model it is adapting into a view has changed! You can do this by calling the notifyDataSetChanged() method on the adapter. After you’ve modified (and notified!) the Adapter, you can change which page is displayed using the ViewPager#setCurrentItem() method. This will let you take the user to the “results” page! Similarly, modify the movie selection callback so that when a movie is selected from the list, your Activity instantiates a new (potentially different) DetailFragment. Remember to notify the adapter that the data set has changed, and to change which page is currently shown. This will replace the previous behavior of the callback. Once you’ve made these changes, you should be able to search for movies, see the results, and view the details for movies. Swipe left and right to navigate between pages! "],
["bluetooth.html", "Lecture 18 Bluetooth", " Lecture 18 Bluetooth In this chapter you will learn about some of the pieces for creating a connection between two co-located devices using Bluetooth. This will let you gain some familiarity with the Bluetooth API, as well as further practice working with Intents. The code for this tutorial can be found at https://github.com/info448/lab-bluetooth. This tutorial involves filling in the remaining pieces from a Sample Project provided by Google. Google includes lots of samples demonstrating how to use particular pieces of functionality; reading and adapting the provided projects is a great way to learn new skills. There are a lot of comments, though that sometimes makes it hard to follow all the pieces. Read carefully! Also be sure to open the API documentation for reference! The emulator doesn’t support Bluetooth, so you will need to run this project on a physical device! Your task is to fill in the missing pieces of code, following the instructions below. I’ve marked each location with a TODO comment, which should show up in blue in Android Studio. Start by reading through The Basics to get a sense for what classes will be used and what their roles are. You only need to focus on the first 4: BluetoothAdapter, BluetoothDevice, BluetoothSocket, and BluetoothServerSocket (the rest are for other kinds of Bluetooth connections, like audio transfer and stuff). You don’t need to know all the methods or details of these classes, but should be familiar with their general, one-sentence purposes! You’ll need to request permission to use Bluetooth. Add the appropriate &lt;uses-permission&gt; attributes: one for BLUETOOTH (for communication; included) and one for BLUETOOTH_ADMIN (to “discover” devices and make connections). The main UI is defined in the BluetoothChatFragment class, which is a Fragment that holds the chat system. Start by filling in the onCreate() callback by fetching the default Bluetooth adapter and saving it to an instance variable (mBluetoothAdapter). If the adapter doesn’t exist (is null), you should Toast a message that Bluetooth isn’t available (using the Activity's Application Context so that the Toast lasts), and then call finish() on the Fragment’s Activity (to close the application). You’ll want your app to make sure that the user has Bluetooth turned on. In the Fragment’s onStart(), check whether the the BluetoothAdapter is enabled. If not, you’ll want to prompt the user to enable it, such as by launching the “Settings” app. Create an Implicit Intent for the action BluetoothAdapter.ACTION_REQUEST_ENABLE, and send this Intent for a result (with the result code of REQUEST_ENABLE_BT). Look in the Fragment’s onActivityResult() method to see what happens when we get a response back! The BluetoothChatService (stored in the instance variable mChatService) is an object representing a “background service”—think an AsyncTask but with a much longer lifespan. This particular service handles sending bytes of data back and forth over Bluetooth. We’ll talk about Services more later in the course. In order for a device to connect to yours over Bluetooth, your device will need to be discoverable: effectively, it has to respond to public queries about its existence (sort of like having your instant messaging status as “Online/Available”). In the Fragment’s ensureDiscoverable() helper method, check if the device is currently discoverable by calling getScanMode() on the BluetoothAdapter; it should return a value of BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE. If this IS NOT the case, then you should send another Implicit Intent (start an Activity, though not for a result) to handle the BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE action. This intent should include (put) an extra that has the key BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION and a value of 300, so that we are in “discoverable” mode for 300 seconds. The discovery of devices is controlled by the DeviceListActivity Activity. This is a separate Activity that will actually appear as a popup dialog (though it doesn’t use DialogFragment; it just “themes” the Activity as a dialog in the Manifest). The Activity’s onCreate() does a lot of UI work (including setting up an Adapter!), but it also needs to set up a BroadcastReceiver to listen for events like when devices are found. (This is the equivalent of declaring a &lt;receiver&gt; and &lt;intent-filter&gt; in the Manifest, but we need to do it in Java since the Receiver isn’t a separate class and since we want to do it dynamically). First instantiate a new IntentFilter object (giving it the BluetoothDevice.ACTION_FOUND action). Then use the registerReceiver(receiver, intentFilter) method, passing it the already-existing receiver (mReceiver) and the IntentFilter you just created! Then repeat the above two steps, but this time for the Bluetooth.ACTION_DISCOVERY_FINISHED action. This will register an additional IntentFilter on the same receiver. We can actually begin searching for devices by filling in the Activity’s doDiscovery() helper method (which is called when the Scan button is pressed). Add a check to see if the BluetoothAdapter currently isDiscovering(). If so, then you should tell the adapter to cancelDiscovery(). Whether or not the check was true (so even if we canceled the discovery), tell the adapter to startDiscovery() to begin searching for devices! Once the user has selected a device to connect to, we handle that connection back in the BluetoothChatFragment. Fill in that class’s connectDevice() helper method to connect to the device! First you’ll want to get the device’s “address” (a MAC address that acts as a unique identifier) from the Intent’s extras: get the Bundle of extras from the Intent, then get the String with the key DeviceListActivity.EXTRA_DEVICE_ADDRESS. You can then find the device (a BluetoothDevice object) by calling the .getRemoteDevice() method on the BluetoothAdapter and passing this address. Finally, you can use the mChatService’s .connect() method to connect to this device (passing down the secure option as a second parameter). The BluetoothChatService#connect() method creates a new Thread to do the communication work, and opens up network sockets so that messages can be passed between the devices. (This is actually part of the hard part or working with Bluetooth; luckily we have a class to abstract that for us!) The last part is to actually send a message! In the sendMessage() helper in BluetoothChatFragment, fill in the details so that the String can be sent to the socket in the chat service. First you need to convert the message String into a byte[] (for communication over the socket). Use the String’s getBytes() method to convert. Then you can tell mChatService to .write() those bytes! We then need to reset the mOutStringBuffer instance variable (which keeps track of the message that has been typed so far). Use .setLength() to give it a length of 0, which will effectively make it empty. And finally, because we’ve changed the outgoing message, set the text of the mOutEditText TextView to be the (now empty) mOutStringBuffer. And that’s it! You should now have a working chat system! Search for and connect to someone else’s device and try saying “hello”! When you finish the lab, you should probably turn off the Bluetooth radio on your device. Android’s Bluetooth implementation has critical security flaws that can be hacked to execute malicious code. Unless you’ve patched with the latest security update (meaning you have the latest device), it is recommended that you avoid using Bluetooth. "],
["maps.html", "Lecture 19 Maps 19.1 Create a Map Activity 19.2 Specifying the User Interface 19.3 Markers and Drawings", " Lecture 19 Maps This chapter will introduce you to the Google Maps Android API which allows you to very easily add an interactive map to your application. 19.1 Create a Map Activity There is no scaffolding code for this tutorial; instead, you should create a new project from scratch. Note that you can test your project either on the emulator or a physical device: just make sure the device has the Google APIs included. Start a new project in Android Studio (“Map Lab” is a fine project name). Target SDK 15 like usual. But here’s where things get different! Instead of starting with an “Empty Activity”, start with a Google Maps Activity. This will create you a new Activity whose layout includes an XML-defined SupportMapFragment. (This is just another Fragment subclass, so you could include it in a layout wherever you wanted. You can stick with the default layout for now). Getting an API Key In order to access and show a Google Map, you need to register and get an API key (this is like a special password that lets your app access Google’s map data). When you create the Maps Activity, Android Studio should open up the google_maps_api.xml resource file. This file contains instructions on how to get an API key (i.e., paste the giant pre-generated link into your browser, and then copy the generated key into the XML resource). The instructions found in the google_maps_api.xml file. (If you already have a Google Maps API Key, you can add this package &amp; device to that key in the Google Developer Console). After you’ve entered the key, you should be able to build and run your app, and see a displayed map! 19.1.1 The SupportMapFragment Take a moment to open up the generated MapsActivity and its associated layout (by default layouts/activity_maps.xml) and read over the initial code. The layout resource contains a single &lt;fragment&gt; element (like we’ve defined before), in this case referring to an instance of the SupportMapFragment class. This fragment represents the interactive map. It’s just a subclass of Fragment (with a few extra methods), so everything we’ve learned about Fragments applies. The Fragment is defined in the XML, so we don’t need to use a FragmentTransaction to add it in the Java code. But we do use the FragmentManager to get access to that fragment so that we can call a single method on it: getMapAsync(). This gets access to a GoogleMap object, which does all the work of downloading map tiles, handling pans and zooms, and drawing markers and shapes. The getMapAsync() method loads this object asynchronously (as is done with the GoogleApiClient), and will notify a listener when the object is available. Because the MapsActivity implements the OnMapReadyCallback interface, it is a listener and so its onMapReady() callback will be called and passed the object for us to handle. Once the the object is available via the callback, we can start calling methods on it: e.g., to show a marker at a particular latitude/longitude (LatLng), and to position the map’s “camera” to focus on that spot. 19.2 Specifying the User Interface The Java code is able to position the map, but if we want to specify a “default” position, you should instead do that work in the Fragment’s definition in the XML resource file. Check out the list of available XML attributes for defining the user interface of your map. Customize the map so that: It is by default centered on Mary Gates Hall. (You will need to delete the positioning Java code so that it doesn’t override your XML). It is zoomed in so that we can see the see the whole fountain on the map It shows the “zoom control buttons” (so that you can zoom in using the emulator!) It shows both satellite imagery and roads/buildings at the same time. 19.3 Markers and Drawings Showing a map is great, but what we really want to do is customize what it shows: that is, we want to draw on it! There are a couple of things we can draw, one of the most common of which is Markers that indicate a single location on the map. You can create a Marker by instantiating a new MarkerOptions object and passing it into the GoogleMap object’s addMarker() method. See the documentation for ways to customize these markers. The most common options are setting the position (required), the title (text that appears when the user clicks the marker), and snippet (additional text). Create a marker centered in the center of the fountain. The marker should be purple or gold in color, and clicking on it should tell the user something about the ducks who dwell there! You can show customized information (including pictures, etc) when markers are clicked using Info Windows. Drawing Shapes You can also draw free-form shapes on the map, anchored to particular locations. These include lines, circles, and generic polygons. One of the best options for drawing is the Polyline, which is a series of connected line segments (like a “path” in SVG). In order to create a Polyline, you instantiate a PolylineOptions object. You can add() points (LatLng objects) to this object, extending the line from one point to the next. This PolylineOptions object is then passed to the GoogleMap object’s addPolyline() method. You can also specify other visual properties such as the color and the width of the Polyline. Note that the width is measure in screen pixels—it will be the same no matter what zoom level you are at! (If you wanted it to change dynamically, you’d need to do that work on your own). Using a Polyline, draw a giant “W” in either purple or gold centered on the fountain. Bonus if want to make it look like the UW logo! Or better yet: can you use a combination of Polylines, Circles, and Polygons to draw an approximation of the iSchool logo? "],
["memory.html", "Lecture 20 Memory Management 20.1 Memory Allocation 20.2 The Memory Monitor 20.3 Memory Leaks", " Lecture 20 Memory Management Android is designed to run on resource constrained devices, and one of the most constrained resources is the device’s memory. Because of this, a large part of the Android framework and how we interact with application components deals with how the system manages memory, making sure sufficient memory is available for whatever the user wants to do. In this short tutorial, you will explore how the Android operating system handles memory, and learn how to use the Android Monitor’s Memory Monitor to view your application’s memory usage and identify potential memory leaks. The code for this tutorial can be found at https://github.com/info448/lab-memory. Note that you will not be required to write much code for this lab; it is more about using the tools and inspecting the logged output to get a sense for how memory is handled in Android. You should be able to complete this tutorial on either the emulator or a physical device. This tutorial is based on Android Studio version 2.3.3. Android Studio 3.0 introduces a different set of profiling tools, though they should work in a similar way. 20.1 Memory Allocation First, a short introduction to how memory is handled by a computer (including mobile computers): The basic idea is that your computer has some amount of storage space (in RAM) dedicating to remembering all of the variables and objects that you create in your program. If you declare a new variable int number = 448; that value (448) is “written down” in memory so it can be used later. For example, this int takes up 32 bits, or 4 bytes, of memory. Every single variable you create takes up some amount of memory (see e.g., here). This data is stored in a section of memory called the “heap”, which is the part of memory dedicated to dynamic memory (e.g., values that may only need to be remembered for a short time). You can think of the heap as a something like a giant array or list of bytes, a certain number of which are allocated (given) to each new value that needs to be stored. Thus if spots 0 through 100 in the heap are allocated, declaring a new variable may be allocated (placed) at spot 101. Example of memory allocation, from dynatrace.com. Memory management thus involves answering two questions: Where do we put new values that we need to allocate memory for? What do we do with variables that we no longer need to remember? Java (and by extension, Android) answers the second question in part by using what is called the garbage collector. This is a system process that periodically “sweeps” (searches) for any values that are no longer being used—that is, the variables are out of scope or otherwise cannot be referenced. These values are then “garbage collected”: the space is deallocated so that future values can be placed there instead. Garbage collection is a bit like going through an apartment and marking rooms as “vacant” if no one lives there anymore. Java’s garbage collection means we don’t need to handle deallocating memory ourselves—unlike in languages such as C where you need to manually manage your own memory! The Android framework is structured so that when memory gets low, the system will destroy any stopped Activities, thereby allowing them to be garbage collected (and freeing up the memory to be used by a different application). You’ll be able to see this process in action in the next section. 20.2 The Memory Monitor Since we’re interested in the memory used by the application, you should enable and view the Memory Monitor provided by Android Studio. If you look at the bottom panel (the Android Monitor panel) where you normally see the Logcat results, you should see a tab called Monitors. Click on this to view the memory usage over time (you can ignore the other monitors for now). Android Memory Monitor (Google) The dark-blue section represents allocated memory (i.e., the amount of memory being used to store variables), while the light-blue section represents free memory (in this case, the amount of memory that the application is budgeted by the operating system). Each section also has a size in megabytes listed on the right. We’re primarily interested in the dark-blue allocated memory, but check in with the instructor if you have questions about the free memory. When you first start up the app, you should see that some memory has been allocated, but it shouldn’t be changing at all (since the MainActivity doesn’t create any new variables after it is created). But let’s change that! While watching the monitor, click on the “BLANK ACTIVITY” button to be taken to a new (blank) Activity. Did you see the bar go up?! This is because opening a new Activity required allocating additional memory for that Activity (particularly its Views, since it doesn’t do much else). Of course, the bar didn’t go up by much; that’s because this simple Activity doesn’t require a lot of memory. In practice, even a lot of Buttons and TextViews don’t require large amounts of memory. Navigate back to the MainActivity. You might see the memory allocation increase a little more, as restarting the Activity can cause the Views to need to be recreated. Garbage Collection Let’s see how the Java (technically, Dalvik) virtual machine handles memory. From the MainActivity, click on the button to go to the ProgressActivity. This Activity will show the progress towards completing a number of undefined tasks (it’s just showing a bunch of ProgressBar Views, which use a bit more memory than standard buttons). When you visited this Activity, you should have seen the memory allocation jump up! Now try navigating back and forth between the MainActivity and the ProgressActivity. You should see the allocated memory continue to increase (since we need to keep recreating those spinners), getting closer and closer to the amount of “free” memory. Eventually, Android will decide that it’s out of memory, and will initiate garbage collection, deallocating the memory that has previously been used to create the old spinners which are no longer needed (because that instance of the Activity is gone). Android will sometimes increase the amount of free memory available as the app asks for more. This is normal. When the garbage collection occurs, you should see the amount of allocated memory suddenly drop. Those “cliffs” are the garbage collector running. There are actually different forms of garbage collection (which make different decisions about which values are “old enough” to be deallocated), and the one that you just triggered may not have collected everything. You can also use the memory monitor to manually initiate garbage collection—this is useful for checking if memory is actually being used, or just hasn’t been cleaned up yet. Manually initiate the garbage collection by clicking the “Initiate GC” button () at the top of the memory monitor panel. What happens? Were there other values that could be cleaned up? Note that in practice, you should not try to perform garbage collection on your own—let the system do its own work (it is optimized to make sure that the computer doesn’t slow down too much when trying to do cleanup, which requires additional processing). This button is purely for testing and inspection. 20.3 Memory Leaks Android’s garbage collection does a fine job of cleaning up memory… assuming that it can correctly identify the values that aren’t being used. This can sometimes be tricky: Java decides that a value is eligible for garbage collection whenever there are no longer any references to that value (e.g., no variables are in scope). However, if you’re not careful it’s often easy to leave an extra reference floating around that you didn’t intend, thereby keeping the memory from being deallocated. This is referred to as a memory leak (because the amount of available space is “leaking” away). For example, consider the BirdActivity class, that you can view by clicking on the “BIRD ACTIVITY” button. This activity shows a relatively high-resolution image of a bird—when you open the Activity, you should see the amount of allocated memory jump up dramatically since we need to load that Drawable into memory. If you click on the BirdActivity’s button, you’ll be taken to (another) blank Activity. Since the bird image is no longer being shown, it should no longer be used and thus should be eligible for garbage collection. Hit the “Initiate GC” button again to request that Android sweep up and reclaim that memory. What happens? You’ll notice that the large amount of memory allocated to the image doesn’t go away… it looks like the bird isn’t being garbage collected! Why not? Recall that when we start new Activities, old Activities are put on a back stack, allowing us to be able to hit the “back” button and return to the previous Activity. This means that each Activity in the stack contains a reference to the previous ones… including the resources that they have loaded into memory! So there is in fact a reference to that image—it’s in the object that is stored on the backstack! This can be a problem. It means that because we have that history, the amount of memory available to our application is smaller even though we’re not actually looking at the pretty bird right now. We can fix this by utilizing the Activity lifecycle callbacks. Specifically, you can remove the reference to the image when the the Activity stops, and then reload the image when the Activity starts again. For practice, in the BirdActivity, override the onStop() method. Inside this method, set the ImageView’s drawable to be null. Similarly, override the the onStart() method so it loads and displays the image when the Activity is (re)started. You can just move the relevant code from onCreate(). Once you’ve done this, try navigating to the BirdActivity and clicking the button to go to the BlankBirdActivity. Use the “Initiate GC” button to force a garbage collection sweep—does the image’s memory get cleaned up now? While this does mean that we’re not using as much memory when the Activity isn’t shown, it does mean that returning to the Activity is slightly slower (since we need to reload the image). This is the fundamental trade-off in all of programming optimization: use of space vs. use of time. Now you should have a sense for how values in Android can influence memory usage. The main take-away is that you want to be careful to de-reference any object that take significant memory (like images or other media; this is why we released the MediaPlayer when discussing Services). Additionally: note that static variables are never de-referenced and so are never garbage-collected. Thus you want to avoid static variables for anything more complex than a String to avoid more memory leaks! Finally, if you use the memory monitor and see memory usage stacking up, that is not necessarily a memory leak or other problem: it could just be that the system hasn’t run garbage collection yet! A memory leak is when resources that should be able to be reclaimed cannot be—but as long as you keep variables local and de-reference large objects, you’ll be fine! Android Studio includes numerous other monitors for profiling the performance of your application. See Android Monitor and Performance and Power for more details. Additionally, Android Studio 3 contains a new set of profiling tools (but the basic concepts work the same way). Avoid pre-mature optimization! Make sure that you can get your app working first, and then utilize these tools to solve specific problems, such as slow performance. "],
["multi-touch.html", "Lecture 21 Multi-Touch 21.1 Identifying Fingers 21.2 Drawing Touches 21.3 Moving Fingers 21.4 Other Multi-Touch Gestures", " Lecture 21 Multi-Touch In this short chapter, you will practice working with touch interaction by implementing support for multi-touch gestures, or the ability to detect two or more different “contacts” (fingers) independently. Multi-touch is actually a pretty awesome interaction mode; it’s very “sci-fi”. Specifically, you will be implementing an simple animated app that graphically tracks the location of all 5 of your fingers. The code for this tutorial can be found at https://github.com/info448/lab-multitouch. Note that the starter code builds on the example presented in Lecture 15. The emulator doesn’t support multi-touch, so you will need to run this project on a physical device. 21.1 Identifying Fingers Android lets you react to multiple touches by responding to ACTION_POINTER_DOWN events, which occur when a second “pointer” (finger) joins the gesture (after the ACTION_DOWN event). The first finger starts the gesture with an ACTION_DOWN event. then subsequent fingers produce ACTION_POINTER_DOWN events. Similarly, there are ACTION_POINTER_UP events for removing fingers, until the last finger is removed which causes the ACTION_UP event. Practice: In MainActivity.java, add further cases to the onTouchEvent() callback and log out when subsequent fingers are placed and lifted. Here the tricky part: each finger that is currently “down” can cause events independently. That is, if we move a finger, then an ACTION_MOVE event will occur. Similarly, if we remove a finger, then an ACTION_POINTER_UP event will occur. So the question is, how do we know which finger caused the event? Underneath the hood, pointers are stored in a list (think: an ArrayList), so each has a pointer index (a number representing their index in that list). But these indices can change as you interact with the device. For example, lifting up a finger will could cause that pointer to be removed from the list, thus moving all of the other pointers up an index. In fact, the index is allowed to change between each event—while they often stay in order, there is no assurance that they will. The exact behavior of these indices is not specified or enforced by the framework, so we need to treat those values as unstable and cannot use them to “track” particular fingers. However, each pointer that comes down is assigned a consistent pointer id number that we can refer to it by. This id will be associated with that finger for the length of time that contact is being made. In general, the first finger down will be id 0, and no matter what happens to the list order that pointer’s id will stay the same. Practice: track pointer ids using the following procedure: When a Touch event occurs, determine the pointer index which caused the event. Do this by calling the getActionIndex() method on the MotionEvent object. Note that this only actually applies to POINTER_DOWN or POINTER_UP events, otherwise it will just return 0 (for the “main finger” of the event). Get the unique pointer id for whatever finger caused the event. Do this by calling the getPointerId(pointerIndex) method on the MotionEvent. This will give you the unique id associated with the event’s finger. 21.2 Drawing Touches Once you know which pointer has gone up and down, you can respond to it by modifying the drawing displayed by the App. Add the falling functionality to the the DrawingSurfaceView: Add an instance variable touches that is a HashMap mapping pointer ids (Integers) to Ball objects. This will track a single “ball” for each touch. Add a method addTouch() that takes in a pointer id as well as the x,y coordinates of the touch point. This method should add a new Ball (at the given coordinates) to the touches map (with the given pointer id). Because this method will need to work across threads in the DrawingSurfaceView, you should make sure the method is synchronized (specifying that keyword in the method signature). Call this method on the drawing View from MainActivity when a new finger is put down—including the first finger! This may be from two different types of events. Pass the pointer index as a parameter to the getX() and getY() methods to determine the coordinates of that particular pointer! Add a method removeTouch() that takes in a pointer id, and removes the Ball that corresponds to that touch. This method should also be synchronized. Call this method on the drawing View from MainActivity when a finger is lifted—including the last finger! Modify the render() method so that the View draws each of the Ball objects in the HashMap at their stored location. You can use gold paint for this. Recall that you can get an iterable sequence of the values for a HashMap using the .values() method. This should cause your app to show a small ball underneath each finger that goes down, with the balls disappearing when a finger is lifted. Make sure each ball is big enough to see! 21.3 Moving Fingers Now we just need to handle finger movements. With a MOVE action, the event doesn’t track which finger has moved—instead, the pointer index of that action is always going to be 0 (the main pointer), even if a different finger moved! However, the event does include information about how many pointers are involved in it (that is: how many pointers are currently down): we can get that number with the MotionEvent#getPointerCount() method. We don’t know which pointer index each finger has, but we do know that they will be consecutive indices (because they are stored in a list). Moreover—as was the case previously—each pointer will have its own x and y coordinates, representing the current position of that pointer (this may or may not have “moved” from the previous event). Thus we can just loop through all of the pointer indices and get the pointer id for each one. We can then specify that we want the corresponding Ball to update its position to match the “current” pointer position. Again, most of the Balls will not have moved, but we know at least one of them did and so we will just update everything to make sure it works! Add a method moveTouch() to the drawing View that takes in a pointer id (e.g., Ball id), and the “latest” x,y coordinates for that Ball. Update the appropriate Ball’s position to reflect these latest coordinates (use .get() to access a HashMap value by its key). This method should again be synchronized. In MainActivity, when a MOVE event occurs, loop through all of the pointer indices in the event. Get the pointer id and x,y coordinates of each, and use those to call the moveTouch() method on the drawing View. You will be “moving” all of the balls, even if most are just moving to the same place they were. And with that, you should have multi-touch tracking! Try adding and removing fingers in unique orders, moving them around, and make sure that the Balls follow the contacts. Note that tracking individual ids in this way is more commonly used to make sure you’re ignoring extra multiple touches. See the docs or this developer blog post for details. 21.4 Other Multi-Touch Gestures We can respond to common multi-touch gestures (like “pinch to scale”) by using another kind of GestureDetector called a ScaleGestureDetector. As before, we subclass the simple version (ScaleGestureDetector.SimpleOnScaleGestureListener), and fill in the onScale() method. You can get the “scale factor” from the gesture with the .getScaleFactor() method. As a further bonus exercise, you might try to use the gesture to scale the size of a single ball. "],
["java-review.html", "A Java Review A.1 Building Apps with Gradle A.2 Class Basics A.3 Inheritance A.4 Interfaces A.5 Polymorphism A.6 Abstract Methods and Classes A.7 Generics A.8 Nested Classes", " A Java Review Android applications are written primarily in the Java Language. This appendix contains a review of some Java fundamentals needed when developing for Android, presented as a set of practice exercises. The code for these exercises can be found at https://github.com/info448/appendix-java-review. A.1 Building Apps with Gradle Consider the included Dog class found in the src/main/java/edu/info448/review/ folder. This is a very basic class representing a Dog. You can instantiate and call methods on this class by building and running the Tester class found in the same folder. - You can just use any text editor, like VS Code, Atom, or Sublime Text to view and edit these files. You’ve probably run Java programs using an IDE, but let’s consider what is involved in building this app “by hand”, or just using the JDK tools. There are two main steps to running a Java program: Compiling This converts the Java source code (in .java files) into JVM bytecode that can be understood by the virtual machine (in .class) files. Running This actually loads the bytecode into the virtual machine and executes the main() method. Compiling is done with the javac (“java compile”) command. For example, from inside the code repo’s directory, you can compile both the .java files with: # Compile all .java files javac src/main/java/edu/info448/review/*.java Running is then done with the java command: you specify the full package name of the class you wish to run, as well as the classpath so that Java knows where to go find classes it depends on: # Runs the Tester#main() method with the `src/main/java` folder as the classpath java -classpath ./src/main/java edu.info448.review.Tester Practice: Compile and run this application now. Practice: Modify the Dog class so that it’s .bark() method barks twice (&quot;Bark Bark!&quot;). What do you have to do to test that your change worked? You may notice that this development cycle can get pretty tedious: there are two commands we need to execute to run our code, and both are complex enough that they are a pain to retype. Enter Gradle. Gradle is a build automation system: a “script” that you can run that will automatically perform the multiple steps required to build and run an application. This script is defined by the build.gradle configuration file. Practice: open that file and look through its contents. The task run() is where the “run” task is defined: do you see how it defines the same arguments we otherwise passed to the java command? You can run the version of Gradle included in the repo with the gradlew &lt;task&gt; command, specifying what task you want to the build system to perform. For example: # on Mac/Linux ./gradlew tasks # on Windows gradlew tasks Will give you a list of available tasks. Use gradlew classes to compile the code, and gradlew run to compile and run the code. Helpful hint: you can specify the “quite” flag with gradlew -q &lt;task&gt; to not have Gradle output its build status (handy for the run task) Practice: Use gradle to build and run your Dog program. See how much easier that is? We will be using Gradle to build our Android applications (which are much more complex than this simple Java demo)! A.2 Class Basics Now consider the Dog class in more detail. Like all classes, it has two parts: Attributes (a.k.a., instance variables, fields, or member variables). For example, String name. Notice that all of these attributes are private, meaning they are not accessible to members of another class! This is important for encapsulation: it means we can change how the Dog class is implemented without changing any other class that depends on it (for example, if we want to store breed as a number instead of a String). Methods (a.k.a., functions). For example bark() Note the method declaration public void wagTail(int). This combination of access modifier (public), return type (void), method name (wagTail) and parameters (int) is called the method signature: it is the “autograph” of that particular method. When we call a method (e.g., myDog.wagTail(3)), Java will look for a method definition that matches that signature. Method signatures are very important! They tell us what the inputs and outputs of a method will be. We should be able to understand how the method works just from its signature. Notice that one of the methods, .createPuppies() is a static method. This means that the method belongs to the class, not to individual object instances of the class! Practice: try running the following code (by placing it in the main() method of the Tester class): Dog[] pups = Dog.createPuppies(3); System.out.println(Arrays.toString(pups)); Notice that to call the createPuppies() method you didn’t need to have a Dog object (you didn’t need to use the new keyword): instead you went to the “template” for a Dog and told that template to do some work. Non-static methods (ones without the static keyword, also called “instance methods”) need to be called on an object. Practice: Try to run the code Dog.bark(). What happens? This is because you can’t tell the “template” for a Dog to bark, only an actual Dog object! In general, in 98% of cases, your methods should not be static, because you want to call them on a specific object rather than on a general “template” for objects. Variables should never be static, unless they are also final constants (like the BEST_BREED variable). In Android, static variables cause significant memory leaks, as well as just being generally poor design. A.3 Inheritance Practice: Create a new file Husky.java that declares a new Husky class: package edu.info448.review; //package declaration (needed) public class Husky extends Dog { /* class body goes here */ } The extends keyword means that Husky is a subclass of Dog, inheriting all of its methods and attributes. It also means that that a Husky instance is a Dog instance. Practice: In the Tester, instantiate a new Husky and call bark() on it. What happens? Because we’ve inherited from Dog, the Husky class gets all of the methods defined in Dog for free! Try adding a constructor that takes in a single parameter (name) and calls the appropriate super() constructor so that the breed is &quot;Husky&quot;, which makes this a little more sensible. We can also add more methods to the subclass that the parent class doesn’t have. Practice: add a method called .pullSled() to the Husky class. Try calling .pullSled() on your Husky object. What happens? Then try calling .pullSled() on a Dog object. What happens? Finally, we can override methods from the parent class. Practice: add a bark() method to Husky (with the same signature), but that has the Husky “woof” instead of “bark”. Test out your code by calling the method in the Tester. A.4 Interfaces Practice: Create a new file Huggable.java with the following code: package edu.info448.review; public interface Huggable { public void hug(); } This is an example of an interface. An interface is a list of methods that a class promises to provide. By implementing the interface (with the interface keyword in the class declaration), the class promises to include any methods listed in the interface. This is a lot like hanging a sign outside your business that says “Accepts Visa”. It means that if someone comes to you and tries to pay with a Visa card, you’ll be able to do that! Implementing an interface makes no promise about what those methods do, just that the class will include methods with those signatures. Practice: change the Husky class declaration: java public class Husky extends Dog implements Huggable {...} Now the the Husky class needs to have a public void hug() method, but what that method does is up to you! A class can still have a .hug() method even without implementing the Huggable interface (see TeddyBear), but we gain more benefits by announcing that we support that method. Just like how hanging an “Accepts Visa” sign will bring in more people who would be willing to pay with a credit card, rather than just having that option available if someone asks about it. Why not just make Huggable a superclass, and have the Husky extend that? Because Husky extends Dog, and you can only have one parent in Java! And because not all dogs are Huggable, and not all Huggable things are Dogs, there isn’t a clear hierarchy for where to include the interface. In addition, we can implement multiple interfaces (Husky implements Huggable, Pettable), but we can’t inherit from multiple classes This is great for when we have other classes of different types but similar behavior: e.g., a TeddyBear can be Huggable but can’t bark() like a Dog! Practice: Make the class TeddyBear implement Huggable. Do you need to add any new methods? What’s the difference between inheritance and interfaces? The main rule of thumb: use inheritance (extends) when you want classes to share code (implementation). Use interfaces (implements) when you want classes to share behaviors (method signatures). In the end, interfaces are more important for doing good Object-Oriented design. Favor interfaces over inheritance! A.5 Polymorphism Implementing an interface also establishes an is a relationship: so a Husky object is a Huggable object. This allows the greatest benefit of interfaces and inheritance: polymorphism, or the ability to treat one object as the type of another! Consider the standard variable declaration: Dog myDog; //= new Dog(); The variable type of myDog is Dog, which means that variable can refer to any value (object) that is a Dog. Practice: Try the following declarations (note that some will not compile!) Dog v1 = new Husky(); Husky v2 = new Dog(); Huggable v2 = new Husky(); Huggable v3 = new TeddyBear(); Husky v4 = new TeddyBear(); If the value (the thing on the right side) is an instance of the variable type (the type on the left side), then you have a valid declaration. Even if you declare a variable Dog v1 = new Husky(), the value in that object is a Husky. If you call .bark() on it, you’ll get the Husky version of the method (Practice: try overriding the method to print out &quot;barks like a Husky&quot; to see). You can cast between types if you need to convert from one to another. As long as the value is a instance of the type you’re casting to, the operation will work fine. Dog v1 = new Husky(); Husky v2 = (Husky)v1; //legal casting The biggest benefit from polymorphism is abstraction. Consider: ArrayList&lt;Huggable&gt; hugList = new ArrayList&lt;Huggable&gt;(); //a list of huggable things hugList.add(new Husky()); //a Husky is Huggable hugList.add(new TeddyBear()); //so are Teddybears! //enhanced for loop (&quot;foreach&quot; loop) //read: &quot;for each Huggable in the hugList&quot; for(Huggable thing : hugList) { thing.hug(); } Practice: What happens if you run the above code? Because Huskies and Teddy Bears share the same behavior (interface), we can treat them as a single “type”, and so put them both in a list. And because everything in the list supports the Huggable interface, we can call .hug() on each item in the list and we know they’ll have that method—they promised by implementing the interface after all! A.6 Abstract Methods and Classes Take another look at the Huggable interface you created. It contains a single method declaration… followed by a semicolon instead of a method body. This is an abstract method: in fact, you can add the abstract keyword to this method declaration without changing anything (all methods are interfaces are implicitly abstract, so it isn’t required): public abstract void hug(); An abstract method is one that does not (yet) have a method body: it’s just the signature, but no actual implementation. It is “unfinished.” In order to instantiate a class (using the new keyword), that class needs to be “finished” and provide implementations for all abstract methods—e.g., all the ones you’ve inherited from an interface. This is exactly how you’ve used interfaces so far: it’s just another way of thinking about why you need to provide those methods. If the abstract keyword is implied for interfaces, what’s the point? Consider the Animal class (which is a parent class for Dog). The .speak() method is “empty”; in order for it to do anything, the subclass needs to override it. And currently there is nothing to stop someone who is subclassing Animal from forgetting to implement that method! We can force the subclass to override this method by making the method abstract: effectively, leaving it unfinished so that if the subclass (e.g., Dog) wants to do anything, it must finish up the method. Practice: Make the Animal#speak() method abstract. What happens when you try and build the code? If the Animal class contains an unfinished (abstract) method… then that class itself is unfinished, and Java requires us to mark it as such. We do this by declaring the class as abstract in the class declaration : public abstract class MyAbstractClass {...} Practice: Make the Animal class abstract. You will need to provide an implementation of the .speak() method in the Dog class: try just having it call the .bark() method (method composition for-the-win!). Only abstract classes and interfaces can contain abstract methods. In addition, an abstract class is unfinished, meaning it can’t be instantiated. Practice: Try to instantiate a new Animal(). What happens? Abstract classes are great for containing “most” of a class, but making sure that it isn’t used without all the details provided. And if you think about it, we’d never want to ever instantiate a generic Animal anyway—we’d instead make a Dog or a Cat or a Turtle or something. All that the Animal class is doing is acting as an abstraction for these other classes to allow them to share implementations (e.g., of a walk() method). Abstract classes are a bit like “templates” for classes… which are themselves “templates” for objects. A.7 Generics Speaking of templates: think back to the ArrayList class you’ve used in the past, and how you specified the “type” inside that List by using angle brackets (e.g., ArrayList&lt;Dog&gt;). Those angle brackets indicate that ArrayList is a generic class: a template for a class where a data type for that class is itself a variable. Consider the GiftBox class, representing a box containing a TeddyBear. What changes would you need to make to this class so that it contains a Husky instead of a TeddyBear? What about if it contained a String instead? You should notice that the only difference between TeddyGiftBox and HuskyGiftBox and StringGiftBox would be the variable type of the contents. So rather than needing to duplicate work and write the same code for every different type of gift we might want to give… we can use generics. Generics let us specify a data type (e.g., what is currently TeddyBear or String) as a variable, which is set when we instantiate the class using the angle brackets (e.g., new GiftBox&lt;TeddyBear&gt;() would create an object of the class with that type variable set to be TeddyBear). We specify generics by declaring the data type variable in the class declaration: public class GiftBox&lt;T&gt; {...} (T is a common variable name, short for “Type”. Other options include E for Elements in lists, K for Keys and V for Values in maps). And then everywhere you would have put a datatype (e.g., TeddyBear), you can just put the T variable instead. This will be replace by an actual type at compile time. Warning: always use single-letter variable names for generic types! If you try to name it something like String (e.g., public class GiftBox&lt;String&gt;), then Java will interpret the word String to be that variable type, rather than refering to the java.lang.String class. This a lot like declaring a variable int Dog = 448, and then calling Dog.createPuppies(). Practice: Try to make the GiftBox class generic and instantiate a new GiftBox&lt;Husky&gt; A.8 Nested Classes One last piece: we’ve been putting attributes and methods into classes… but we can also define additional classes inside a class! These are called nested or inner classes. We’ll often nest “helper classes” inside a bigger class: for example, you may have put a Node class inside a LinkedList class: public class LinkedList { //nested class public class Node { private int data; public Node(int data) { this.data = data; } } private Node start; public LinkedList() { this.start = new Node(448); } } Or maybe we want to define a Smell class inside the Dog class to represent different smells, allowing us to talk about different Dog.Smell objects. (And of course, the Dog.Smell class would implement the Sniffable interface…) Nested classes we define are usually static: meaning they belong to the class not to object instances of that class. This means that there is only one copy of that nested blueprint class in memory; it’s the equivalent to putting the class in a separate file, but nesting lets us keep them in the same place and provides a “namespacing” function (e.g., Dog.Smell rather than just Smell). Non-static nested classes (or inner classes) on the other hand are defined for each object. This is important only if the behavior of that class is going to depend on the object in which it lives. This is a subtle point that we’ll see as we provide inner classes required by the Android framework. "],
["java-swing.html", "B Java Swing Framework B.1 Events B.2 Layouts and Composites", " B Java Swing Framework Android applications are user-driven graphical applications. In order to become familiar with some of the coding patterns involved in this kind of software, it can be useful to consider how to build simple graphical applications in Java using a different GUI framwork: the Swing library. This appendix references code found at https://github.com/info448/appendix-java-swing. Note that this tutorial involves Java Programming: you can either do this in Android Studio, or just using a light-weight text editor such as Visual Studio Code or Sublime Text. The Swing library is a set of Java classes used to specify graphical user interfaces (GUIs). These classes can be found in the javax.swing package. They also rely on the java.awt package (the “Advanced Windowing Toolkit”), which is an older GUI library that Swing builds on top of. Fun fact: Swing library is named after the dance style: the developers wanted to name it after something hip and cool and popular. In the mid-90s. Let’s look at an incredibly basic GUI class: MyGUI found in the src/main/java/ folder. The class subclasses (extends) JFrame. JFrame represents a “window” in your operating system, and does all the work of making that window show up and interact with the operating system in a normal way. By subclassing JFrame, we get that functionality for free! This is how we build all GUI applications using this framework. Most of the work defining a Swing GUI happens in the JFrame constructor (called when the GUI is “created”). We first call the parent constructor (passing in the title for the window), and then call a method to specify what happens when we hit the “close” button. We then instantiate a JButton, which is a class representing a Java Button. Note that JButton is the Swing version of a button, building off of the older java.awt.Button class. We then .add() this button to the JFrame. This puts the button inside the window. This process is similar to using jQuery to add an HTML element to web page. Finally, we call .pack() to tell the Frame to resize itself to fit the contents, and then .setVisible() to make it actually appear. We run this program from main by just instantiating our specialized JFrame, which will contain the button. You can compile and run this program with ./gradlew -q run. And voila, we have a basic button app! B.1 Events If we click the button… nothing happens. Let’s make it print out a message when clicked. We can do this through event-based programming (if you remember handling click events from JavaScript, this is the same idea). Most computer systems see interactions with its GUI as a series of events: the event of clicking a button, the event of moving the mouse, the event of closing a window, etc. Each thing you interact with generates and emits these events. So when you click on a button, it creates and emits an “I was clicked!” event. (You can think of this like the button shouting “Hey hey! I was pressed!”) We can write code to respond to this shouting to have our application do something when the button is clicked. Events, like everything else in Java, are Objects (of the EventObject type) that are created by the emitter. A JButton in particular emits ActionEvents when pressed (the “action” being that it was pressed). In other words, when buttons are pressed, they shout out ActionEvents. In order to respond to this shouting, we need to “listen” for these events. Then whenever we hear that there is an event happening, we can react to it. This is like a person manning a submarine radar, or hooking up a baby monitor, or following someone on Twitter. But this is Java, and everything in Java is based on Objects, we need an object to listen for these events: a “listener” if you will. Luckily, Java provides a type that can listen for ActionEvents: ActionListener. This type has an actionPerformed() method that can be called in response to an event. We use the Observer Pattern to connect this listener object to the button (button.addActionListener(listener)). This registers the listener, so that the Button knows who to shout at when something happens. (Again, like following someone on Twitter). When the button is pressed, it will go to any listeners registered with it and call their actionPerformed() methods, passing in the ActionEvent it generated. But look carefully: ActionListener is not a concrete class, but an abstract interface. This means if we want to make an ActionListener object, we need to create a class that implements this interface (and provides the actionPerformed() method that can be called when the event occurs). There are a few ways we can do this: We already have a class we’re developing: MyGUI! So we can just make that class implement ActionListener. We’ll fill in the provided method, and then specify that this object is the listener, and voila. This is my favorite way to create listeners in Java (since it keeps everything self-contained: the JFrame handles the events its buttons produce). We’ll utilize a variant of this pattern in Android: we’ll make classes implement listeners, and then “register” that listener somewhere else in the code (often in a nested class). But what if we want to reuse our listener across different classes, but don’t want to have to create a new MyGUI object to listen for a button to be clicked? We can instead use an inner or nested class. For example, create a nested class MyActionListener that implements the interface, and then just instantiate one of those to register with the button. This could be a static nested class, but then it wouldn’t be able to access instance variables (because it belongs to the class, not the object). So you might want to make it an inner class instead. Of course then you can’t re-use it elsewhere without making the MyGUI (whose instance variables it referenes anyway)… but at least we’ve organized the functionality. It seems sort of silly to create a whole new MyActionListener class that has one method and is just going to be instantiated once. So what if instead of giving it a name, we just made it an anonymous class? This is similar to how you’ve made anonymous variables by instantiating objects without assigning them to named variables, you’re just doing the same thing with a class that just implements an interface. The syntax looks like: button.addActionListener(new ActionListener() { //class definition (including methods to override) goes in here! public void actionPerformed(ActionEvent event) { //... } }); This is how buttons are often used in Android: we’ll create an anonymous listener object to respond to the event that occurs when they are pressed. B.2 Layouts and Composites What if we want to add a second button? If we try to just .add() another button… it replaces the one we previously had! This is because Java doesn’t know where to put the second button. Below? Above? Left? Right? In order to have the JFrame contain multiple components, we need to specify a layout, which knows how to organize items that are added to the Frame. We do this with the .setLayout() method. For example, we can give the frame a BoxLayout() with a PAGE_AXIS orientation to have it lay out the buttons in a vertical row. container.setLayout(new BoxLayout(container, BoxLayout.PAGE_AXIS)); container.add(theButton); container.add(otherButton); Java has different LayoutManagers that each have their own way of organizing components. We’ll see this same idea in Android. What if we want to do more complex layouts? We could look for a more complex LayoutManager, but we can actually achieve a lot of flexibility simply by using multiple containers. For example, we can make a JPanel object, which is basically an “empty” component. We can then add multiple buttons to this this panel, and add that panel to the JFrame. Because JPanel is a Component (just like JButton is), we can use the JPanel exactly as we used the JButton—this panel just happens to have multiple buttons. And since we can put any Component in a JPanel, and JPanel is itself a Component… we can create nest these components together into a tree in an example of the Composite Pattern. This allows us to create very complex user interfaces with just a simple BoxLayout! This is similar to how we can create complex web layouts just by nesting lots of &lt;div&gt; elements. "],
["publishing.html", "C Publishing C.1 Signing an App", " C Publishing This short chapter discusses how to publish your Android application, producing a version of the app that can be shared with others. In particular, it explains how to cryptographically sign your app and build it so it can be installed by people who are not using Android Studio. Before you actually distribute your application, you should make sure it is fully ready to be published. Google provides an excellent list of things to do before releasing your application, as well as a more detailed checklist for releasing an app on the Play Store. Particularly common tasks include: removing extraneous Logging commands, and checking for accessibility and localization. Once you have completed these steps, you are ready to build and sign your app. C.1 Signing an App As described in lecture 1, building an Android application involves compiling Java and XML code into DVM bytecode, and then packing this code (along with assets and graphics) into a .apk file. But in order to install this .apk file onto a device, it needs to be cryptographically signed though the inclusion of a public-key certificate. This certificate corresponds with a private key (a secret code) held by you (the developer). Because each public-key cert is associated with a code only you as the developer knows (similar to a password), it is able to act as an identifying signature for your app: only you know the secret password, so only you are able to provide this particular certificate. Thus by signing the .apk with your signature, you are marking the package as being developed by you and not someone else—just like a signature on a check. Android uses these signatures as a security feature to ensure that any future updates come from the same person (no malicious app updates!), as well as to help verify the source of an installed package. The secret private keys are stored on your computer in .keystore files (think: a database of private keys). You may have multiple different keystores on your machine. By default, when you build and run an app in Android Studio, the IDE automatically generates a debug certificate for you to sign your application with. This certificate is not secure (it’s an automatically generated password!) so isn’t trustworthy for app stores (like the Play Store)… but it is sufficient for being able to install and run your application through Android Studio. By default, keys are stored in the ~/.android folder on Mac and Linux, and the C:\\Users\\USER_NAME\\.android\\ folder on Windows. You can view the debug key (e.g., on Mac) using the command: keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android The -alias is a name of the particular certificate, and the -storepass and keypass arguments are literal passwords associated with the store (database) and certificate (in the database) respectively. The fact that this store is password protected is what makes it secret and accessible only to the developer. Scroll down to see the “Certificate fingerprints”; for example, the SHA1 certificate is used when getting a Google Maps API key. Importantly, each computer running Android Studio will produce it’s own unique debug certificate. That means that the “signature” identifying your app will different for every different computer: even if it has the same package and the same source code, Android will consider it a “different” program because it was built (in debug mode) on a different machine. This is particularly important when things like API keys (e.g., for Google Maps) are linked to a particular digital signature; it means that each development machine would need to have its unique signature associated with the API! In addition to the automatically generated debug certificates, you can sign apps with your own generated release certificate. This is a certificate not automatically created by Android Studio, but is still associated with a secret “password” that only you know. These certificates are also stored in a .keystore file, which is created and password-protected by the developer. Because this keystore is kept secret and locked, only the developer is able to sign the built .apk with a verifiable signature, thereby ensuring that any updates to the application must have come from that developer. I like to think of debug certificates as like cheap, easily-reproducible Bic pens, and release certificates like fancy golden quills. When multiple developers are working on an app, each will be signing their testing versions with their own cheap Bics. But when it comes to releasing the project, you need to get out the expensive golden quill to do the signing. The validity of an app is dependent on which “pen” is used to sign it. (In this metaphor, the .keystore file is a pen case). Release .apk In order to generate a shareable release .apk, you will need to produce a release certificate to sign the app with, then build and sign the .apk with that certificate. Android studio makes it easy to sign a release build (follow the link for more details and examples). In short, select Build &gt; Generate Signed APK from the menu, and follow the wizard’s instructions! You will be prompted for a location for the .keystore file to use (e.g., where to store your release pens). I recommend making a file somewhere in your user’s home directory (e.g., ~/android-release.jks). Note that you can use the same private key (found in the keystore) for multiple apps. It is also possible to configure Android Studio to automatically sign your application when building for release. Be sure you remove signing information from your build files so your passwords don’t get uploaded to GitHub! The built and signed .apk will be created in the destination folder you selected. This file can then be shared: uploaded to the Google Play Store, hosted on a web page, or emailed directly to someone to install. Note that installing .apk files from outside the Play Store—even when signed—requires the user to opt-in for apps from unknown sources. "]
]
