[
["index.html", "Android Development: Lecture Notes About this Book", " Android Development: Lecture Notes Joel Ross October 02, 2017 About this Book This book compiles lecture notes and tutorials for the INFO 448 Mobile Development: Android course taught at the University of Washington Information School (most recently in Autumn 2017). The goal of these notes is to provide learning materials for students in the course or anyone else who wishes to learn the basics of developing Android applications. These notes cover the tools, programming languages, and architectures needed to develop applications for the Android platform. This course expects you to have “journeyman”-level skills in Java (apprenticeship done, not yet master). It uses a number of intermediate concepts (like generics and inheritance) without much fanfare or explanation (though see the appendix). It also assumes some familiarity with developing interactive applications (e.g., client-side web applications). These notes are primarily adapted from the official Android developer documentation, compiling and synthesizing those guidelines for pedagogical purposes (and the author’s own interpretation/biases). Please refer to that documentation for the latest information and official guidance. This book is currently in alpha status. Visit us on GitHub to contribute improvements. This book is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["introduction.html", "Lecture 1 Introduction 1.1 Android History 1.2 Building Apps 1.3 App Source Code 1.4 Logging &amp; ADB 1.5 Adding Interaction", " Lecture 1 Introduction This course focuses on Android Development. But what is Android? Android is an operating system. That is, it’s software that connects hardware to software and provides general services. But more than that, it’s a mobile specific operating system: an OS designed to work on mobile (read: handheld, wearable, carry-able) devices. Note that the term “Android” also is used to refer to the “platform” (e.g., devices that use the OS) as well as the ecosystem that surrounds it. This includes the device manufacturers who use the platform, and the applications that can be built and run on this platform. So “Android Development” technically means developing applications that run on the specific OS, it also gets generalized to refer to developing any kind of software that interacts with the platform. 1.1 Android History If you’re going to develop systems for Android, it’s good to have some familiarity with the platform and its history, if only to give you perspective on how and why the framework is designed the way it is: 2003: The platform was originally founded by a start-up “Android Inc.” which aimed to build a mobile OS operating system (similar to what Nokia’s Symbian was doing at the time) 2005: Android was acquired by Google, who was looking to get into mobile 2007: Google announces the Open Handset Alliance, a group of tech companies working together to develop “open standards” for mobile platforms. Members included phone manufacturers like HTC, Samsung, and Sony; mobile carriers like T-Mobile, Sprint, and NTT DoCoMo; hardware manufacturers like Broadcom and Nvidia; and others. The Open Handset Alliance now (2017) includes 86 companies. Note this is the same year the first iPhone came out! 2008: First Android device is released: the HTC Dream (a.k.a. T-Mobile G1) Specs: 528Mhz ARM chip; 256MB memory; 320x480 resolution capacitive touch; slide-out keyboard! Author’s opinion: a fun little device. 2010: First Nexus device is released: the Nexus One. These are Google-developed “flagship” devices, intended to show off the capabilities of the platform. Specs: 1Ghz Scorpion; 512MB memory; .37&quot; at 480x800 AMOLED capacitive touch. For comparison, the iPhone 8 Plus (2017) has: ~2.54Ghz hex-core A11 Bionic 64bit; 3GB RAM; 5.5&quot; at 1920x1080 display. (As of 2016, this program has been superseded by the Pixel range of devices). 2014: Android Wear, a version of Android for wearable devices (watches) is announced. 2016: Daydream, a virtual reality (VR) platform for Android is announced. In short, Google keeps pushing the platform wider so it includes more and more capabilities. Android is incredibly popular! (see e.g., here, here, and here) In any of these analyses there are some questions about what exactly is counted… but what we care about is that there are a lot of Android devices out there! And more than that: there are a lot of different devices! Android Versions Android has gone through a large number of “versions” since it’s release: Date Version Nickname API Level Sep 2008 1.0 Android 1 Apr 2009 1.5 Cupcake 3 Sep 2009 1.6 Donut 4 Oct 2009 2.0 Eclair 5 May 2010 2.2 Froyo 8 Dec 2010 2.3 Gingerbread 9 Feb 2011 3.0 Honeycomb 11 Oct 2011 4.0 Ice Cream Sandwich 14 July 2012 4.1 Jelly Bean 16 Oct 2013 4.4 KitKat 19 Nov 2014 5.0 Lollipop 21 Oct 2015 6.0 Marshmallow 23 Aug 2016 7.0 Nougat 24 Aug 2017 8.0 Oreo 26 Each different “version” is nicknamed after a dessert, in alphabetical order. But as developers, what we care about is the API Level, which indicates what different programming interfaces (classes and methods) are available to use. You can check out an interactive version of the history through Marshmallow at https://www.android.com/history/ For current usage breakdown, see https://developer.android.com/about/dashboards/ Additionally, Android is an “open source” project released through the “Android Open Source Project”, or ASOP. You can find the latest version of the operating system code at https://source.android.com/; it is very worthwhile to actually dig around in the source code sometimes! While new versions are released fairly often, this doesn’t mean that all or even many devices update to the latest version. Instead, users get updated phones historically by purchasing new devices (every 18m on average in US). Beyond that, updates—including security updates—have to come through the mobile carriers, meaning that most devices are never updated beyond the version that they are purchases with. This is a problem from a consumer perspective, particularly in terms of security! There are some efforts on Google’s part to to work around this limitation by moving more and more platform services out of the base operating system into a separate “App” called Google Play Services, as well as to divorce the OS from hardware requirements through the new Project Treble. But what this means for developers is that you can’t expect devices to be running the latest version of the operating system—the range of versions you need to support is much greater than even web development! Android applications must be written for heterogeneous devices. Legal Battles When discussing Android history, we would be remiss if we didn’t mention some of the legal battles surrounding Android. The biggest of these is Oracle v Google. In a nutshell, Oracle claims that the Java API is copyrighted (that the method signatures themselves and how they work are protected), so because Google uses that API in Android, Google is violating the copyright. In 2012 a California federal judge decided in Google favor (that one can’t copyright an API). This was then reversed by the Federal Circuit court in 2014. The verdict was appealed to the US Supreme Court in 2015, who refused to hear the case. It then went back to the the district court, which ruled in 2016 that Google’s use of the API was fair use. This ruling is again under appeal. See https://www.eff.org/cases/oracle-v-google for a summary, as well as https://arstechnica.com/series/series-oracle-v-google/ One interesting side effect of this battle: the Android Nougat and later uses the OpenJDK implementation of Java, instead of Google’s own in-violation-but-fair-use implementation see here. This change shouldn’t have any impact on you as a developer, but it’s worth keeping an eye out for potentially differences between Android and Java SE. There have been other legal challenges as well. While not directly about Android, the other major relevant court battle is Apple v Samsung. In this case, Apple claims that Samsung infringed on their intellectual property (their design patents). This has gone back and forth in terms of damages and what is considered infringing; as of this writing, the latest development is that the Supreme Court heard the case and sided with Samsung that infringing design patents shouldn’t lead to damages in terms of the entire device… it’s complicated (the author is not a lawyer). So overall: Android is a growing, evolving platform that is embedded in and affecting the social infrastructures around information technology in numerous ways. 1.2 Building Apps While Android applications can be developed using any programming environment, the official and best IDE for Android programming is Android Studio. This is a fork of JetBrain’s IntelliJ IDEA application—a Java IDE customized for Android development. You will need to download and install this IDE. Be sure to download the Android Studio bundle that includes the Android SDK (Standard Development Kit): the tools and libraries needed for Android development. In particular, the SDK comes with a number of useful command-line tools. These include: adb, the “Android Device Bridge”, which is a connection between your computer and the device (physical or virtual). This tool is used for console output! emulator, which runs the Android emulator: a virtual machine of an Android device. I recommend making sure that you have the SDK tools (the tools and platform-tools folder) available on your computer’s PATH so you can use them from the command-line. By default, the SDK is found at /Users/$USER/Library/Android/sdk on a Mac, and at C:\\Users\\$USERNAME\\AppData\\Local\\Android\\sdk on Windows. While these tools are all built into the IDE, they can be useful fallbacks for debugging or automation. Creating a Project To begin your first application, launch Android Studio (it may take a few minutes to open). From the Welcome screen, choose to “Start a new Android Studio Project”. This will open up a wizard to walk you through setting up the project. The “Company domain” should be a unique domain for you. For this course, you should include your UW NetID, e.g., joelross.uw.edu. Make a mental note of the project location so you can find your work later (e.g., if it’s in Desktop or Documents). On the next screen, you will need to pick the Minimum SDK level that you wish to support—that is, what is the oldest version of Android your application will be able to run on? For this course, unless otherwise specified, you should target API 15 Ice Cream Sandwich (4.0.3) as a minimum, allowing your application to run on pretty much any Android device. Note that the Minimum SDK is different than the Target SDK, which is the version of Android your application has been tested and designed against. The Target SDK indicates what set of API features you have considered/coded against, even if your app can fall back to older devices that don’t include those features. In many ways, the Target SDK is the “highest SDK I’ve worked with”. For most of this course we will target either API 21 (Lollipop) or API 23 (Marshmallow). On the next screen, select to start with an Empty Activity. Activities are the basic component of Android, each of which acts as a “screen” or “page” in your app. Activities are discussed in more detail in the next lecture. Stick with the default name (MainActivity) on the next screen, and hit “Finish”. Android Studio will take a few minutes to create your project and get everything set up. (Keep an eye on the bottom status bar to wait for everything to be finished). Once it is done, you have a complete (if simple) app! Running the App You can run your app by clicking the “Play” or “Run” button at the top of the IDE. But you’ll need an Android Device to run the app on… luckily, Android Studio comes with one: a virtual Android Emulator. This virtual machine models emulates a generic device with hardware you can specify, though it does have some limitations (e.g., no cellular service, no bluetooth, etc). While it has improved recently, the emulator historically does not work very well on Windows—it runs very, very slowly. The best way to speed the emulator up on any operating system is to make sure you have enabled HAXM (Intel’s Acceleration Manager which allows the emulator to utilize your GPU for rendering): this speeds things up considerably. You can usually install this through Android Studio: go to Tools &gt; Android &gt; SDK Manager to open up the SDK manager for downloading different versions of the Android SDK and other support software. Under “SDK Tools”, find “Intel x86 Emulator Accelerator (HAXM installer)”, check it, and hit “OK” to download. Note that you may need to do additional installation/configuration manually, see the guides (Mac, Windows). It is of course also possible to run your app on a physical device. These are the best for development (they are the fastest, easiest way to test code), though you’ll need a USB cable to be able to wire your device to your computer. Any device will work for this course; you don’t even need cellular service (just WiFi should work). You will need to turn on developer options in order to install development apps on your device! In order to create an emulator for your machine, go to Tools &gt; Android &gt; AVD Manager to open up the Android Virtual Device Manager. You can then choose “Create Virtual Device…” in order to launch the wizard to specify a new emulator. The Nexus 5 is a good choice of hardware profile for making sure you support “older” devices. The Nexus 5X or Pixel are also reasonable device profiles to test against. For now, you’ll want to use a system image for Lollipop API 21 or 22, and almost certainly on x86 (Intel) hardware. Make sure to select one that includes the Google APIs (so you have access to special Google classes). The advanced settings can be used to specify things like the camera and whether it accepts keyboard input (should be on by default). These settings can always be changed later. After the emulator boots, you can slide to unlock it… and your app should be loaded and started shortly thereafter! Note that if you are unfamiliar with Android devices, you should be sure to play around with the interface to get used to the interaction language, e.g., how to click/swipe/drag/long-click elements to use an app. 1.3 App Source Code Android Studio will create a bunch of project files by default—almost all of which are use for something. By default, it will show your project using the Android view, which organizes the files thematically. If you instead change to the Project view you can see what the actual file system looks like (though we’ll usually stick with the Android view). Android Studio. The “view” chooser is marked in red. In the Android view, files are organized as follows: app/ folder contains our application source code manifests/ contains the Android Manifest files, which is sort of like a “config” file for the app java/ contains the Java source code for your project. This is where the “logic” of the application goes res/ contains XML resource files used in the app. This is where we will put layout/appearance information Gradle Scripts contains scripts for the Gradle build tool, which is used to help compile the source code for installation on an device. Each of these components will be discussed in more detail below. XML Resources The res/ folder contains resource files. Resource files are used to define the user interface and other media assets (images, etc). for the application. Using separate files to define the application’s interface than those used for the application’s logic (the Java code) helps keep appearance and behavior separated. To compare to web programming: the resources contain the HTML/CSS content, while the Java code will contain what would normally by written in JavaScript. The vast majority of resource files are specified in XML (EXtensible Markup Language). XML has the exact same syntax as HTML, but you get to make up your own tags what whatever semantic values you want. Except we’ll be using the tags that Android made up and provided: so defining an Android application interface will be a lot like defining a web page, but with a new set of elements. Note that this course expects you to have some familiarity with HTML or XML, but if not you should be able to infer the syntactical structure from the examples. There are a large number of different kinds of resources, which are organized into different folders: res/drawable/: contains graphics (PNG, JPEG, etc) that will be “drawn” on the screen res/layout/: contains user interface XML layout files for the app’s content res/mipmap/: contains launcher icon files in different resolutions to support different devices res/values/: contains XML definitions for general constants There are other kinds of resources as well: see Available Resources or Lecture 2 for details. The most common resource you’ll work out are the layout resources, which are XML files that specify the visual layout of the component (like the HTML for a web page). If you open a layout file (e.g., activity_main.xml) in Android Studio, by default it will be shown in a “Design” view. This view lets you use a graphical system to lay out your application, similar to what you might do with a PowerPoint slide. Click the “Text” tab at the bottom to switch to the XML code view. Using the design view is frowned upon by many developers for historical resources, even as it becomes more powerful with successive versions of Android Studio. It’s often cleaner and more effective to write out the layouts and content in direct XML code. This is the same difference between writing your own HTML and using something like FrontPage or DreamWeaver or Wix to create a page. While those are legitimate applications, they are seen as less “professional”. This course will focus on the XML code for creating layouts, rather than utilizing the design tool. See here for more on its features. In the code view, you can see the XML: tags, attributes, values. Elements are nested inside one another. The provided XML code defines a layout (a &lt;android.support.constraint.ConstraintLayout&gt;) to organize things, and inside that is a &lt;TextView&gt; (a View representing some text). Note that most of the element attributes are namespaced, e.g. with an android: prefix, to avoid any potential conflicts (so we know we’re talking about Android’s text instead of something else). The android:text attribute of the &lt;TextView&gt; contains some text. You can change that and re-run the app to see it update! You will be able to specify what your app looks like by creating these XML layout files. For example, try replacing the &lt;TextView&gt; with a &lt;Button&gt;: &lt;Button android:id=&quot;@+id/my_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Click Me!&quot; /&gt; This XML defines a Button. The android:text attribute in this case specifies what text is shown on the button. Lecture 2 will describe in more detail the meaning of the other attributes, but you should be able to make a pretty good educated guess based on the names. (You can keep the app: scoped attributes if you want the button to stay in the center of the screen. Positioning will be discussed in Lecture 2). The Manifest Besides resource files, the other XML you may need to edit is the Manifest File AndroidManifest.xml, found in the manifest/ folder in the Android project view. The Manifest acts like a “configuration” file for the application, specifying application-level details such as the app’s name, icon, and permissions. For example, you can change the displayed name of the app by modifying the android:label attribute of the &lt;application&gt; element. By default, the label is a reference to another resource found in the res/values/strings.xml file, which contains definitions for string “constants”. Ideally all user-facing strings—including things like button text—should be defined as these constants. You will usually need to make at least one change to the Manifest for each app (e.g., tweaking the display name), so you should be familiar with it. Java Activities Besides using XML for specifying layouts, Android applications are written in Java, with the source code found in the java/ folder in the Android project view (in a nested folder structure based on your app’s package name). The Java code handles program control and logic, as well as data storage and manipulation. Writing Android code will feel a lot writing any other Java program: you create classes, define methods, instantiate objects, and call methods on those objects. But because you’re working within a framework, there is a set of code that already exists to call specific methods. As a developer, your task will be to fill in what these methods do in order to run your specific application. In web terms, this is closer to working with Angular (a framework) than jQuery (a library). So while you can and will implement “normal” Java classes and models in your code, you will most frequently be utilizing classes a specific set of classes required by the framework, giving Android applications a common structure. The most basic component in an Android program is an Activity, which represents a single screen in the app (see Lecture 3 for more details). The default provided MainActivity class is an example of this: the class extends Activity (actually it extends a subclass that supports Material Design components), allowing you to make your own customizations to the app’s behavior within the Android framework. In this class, we override the inherited onCreate() method that is called by the framework when the Activity starts—this method thus acts a little bit like the constructor for a class (though see Lecture 3 for a more nuanced discussion). We call the super method to make sure the framework does it stuff, and then setContentView() to specify what the content (appearance) of the Activity should be. This is passed in a value from something called R. R is a class that is generated at compile time and contains constants that are defined by the XML “resource” files! Those files are converted into Java variables, which we can access through the R class. Thus R.layout.activity_main refers to the activity_main layout found in the res/layouts/ folder. That is how Android knows what layout file to show on the screen. Dalvik On a desktop, Java code needs to be compiled into bytecode and runs on a virtual machine (the Java Virtual Machine (JVM)). Pre-Lollipop (5.0), Android code ran on a a virtual machine called Dalvik. Fun fact for people with a Computer Science background: Dalvik uses a register-based architecture rather than a stack-based one! A developer would write Java code, which would then be compiled into JVM bytecode, which would then be translated into DVM (Dalvik Virtual Machine) bytecode, that could be run on Android devices. This DVM bytecode is stored in .dex or .odex (“[Optimized] Dalvik Executable”) files, which is what was loaded onto the device. The process of converting from Java code to dex files is called “dexing” (so code that has been compiled and converted is called “dexed”). Dalvik does include JIT (“Just In Time”) compilation to native code that runs much faster than the code interpreted by the virtual machine, similar to the Java HotSpot. This native code is faster because no translation step is needed to talk to the actual hardware (via the OS). However, from Lollipop (5.0) on, Android instead uses Android Runtime (ART) to run code. ART’s biggest benefit is that it compiles the .dex bytecode into native code at installation using AOT (“Ahead of Time”) compilation. ART continues to accept .dex bytecode for backwards compatibility (so the same dexing process occurs), but the code that is actually installed and run on a device is native. This allows for applications to have faster execution, but at the cost of longer install times—and since you only install an application once, this is a pretty good trade. After being built, an Android application (the source, dexed bytecode, and any non-code resources such as images) are packaged into an .apk file. This are basically zip files (it uses the same gzip compression); if you rename the file to be .zip and you can uncompress it! The .apk file is then cryptographically signed to specify its authenticity, and either “side-loaded” onto the device or uploaded to an App Store for deployment. In short: the signed .apk file is basically the “executable” version of your program! Note that the Android application framework code (e.g., the base Activity class) is actually “pre-DEXed” (pre-compiled) on the device; when you write code, you’re compiling against empty code stubs (rather than needing to include those classes in your .apk)! That said, any other 3rd-party libraries you include will be copied into your built app, which can increase its file size both for installation and on the device. Usefully, since Android code is written for a virtual machine anyway, Android apps can be developed and built on any computer’s operating system (unlike some other mobile OS…). Gradle Scripts To summarize, after writing your Java and XML source code, in order to “build” and run your app you need to: Generate Java source files (e.g., R) from the XML resource files Compile the Java code into JVM bytecode “dex” the JVM bytecode into Dalvik bytecode Pack code and other assets into an .apk Cryptographically sign the .apk file to authorize it Transfer the .apk to your device, install, and run it! This is a lot of steps! Luckily the IDE handles it for us using an automated build tool called Gradle. Such tools let you, in effect, specify a single command that will do all of these steps at once. It is possible to customize the build script by modifying the Gradle script files, found in the Gradle Scripts folder in the Android project view. There are a lot of these by default: build.gradle: Top-level Gradle build; project-level (for building!) app/build.gradle: Gradle build specific to the app. Use this one to customize your project!, such as for adding dependencies or external libraries. For example, we can change the Target SDK in here. proguard-rules.pro: config for release version (minimization, obfuscation, etc). gradle.properties: Gradle-specific build settings, shared local.properties: settings local to this machine only settings.gradle: Gradle-specific build settings, shared Note that older Android applications were developed using Apache ANT. The build script was stored in the build.xml file, with build.properties and local.properties containing global and local build settings. While Gradle is more common these days, you should be aware of ANT for legacy purposes. It is also possible to use Gradle to build and install your app from the command-line if you want. You’ll need to make sure that you have a device (either physical or virtual) connected and running. Then from inside the project folder, you can build and install your app with # use the provided Gradle wrapper to run the `installDebug` script ./gradlew installDebug You can also launch the app from the command-line with the command # use adb to start adb shell am start -n package.name/.ActivityName You can run both these commands in sequence by connecting them with an &amp;&amp; (which short-circuits, so it will only launch if the build was successful). 1.4 Logging &amp; ADB In Android, we can’t use System.out.println() because we don’t actually have a console to print to! More specifically, the device (which is where the application is running) doesn’t have access to standard out (stdout), which is what Java means by System.out. It is possible to get access to stdout with adb using adb shell stop; adb shell setprop log.redirect-stdio true; adb shell start, but this is definitely not ideal. Instead, Android provides a Logging system that we can use to write out debugging information, and which is automatically accessible over the adb (Android Debugging Bridge). Logged messages can be filtered, categorized, sorted, etc. Logging can also be disabled in production builds for performance reasons (though it often isn’t, because people make mistakes). To perform this logging, we’ll use the android.util.Log1 class. This class includes a number of static methods, which all basically wrap around println to print to the device’s log file, which is then accessible through the adb. You will need to import the Log class! You can have Android Studio automatically add the import for a class by selecting that class name and hitting alt-return (you will be prompted if the class name is ambiguous). For better results, turn on “Add unambiguous imports on the fly” in the IDE Preferences. The device’s log file is stored persistently… sort of. It’s a 16k file, but it is shared across the entire system. Since every single app and piece of the system writes to it, it fills up fast. Hence filtering/searching becomes important, and you tend to watch the log (and debug your app) in real time! Log Methods Log provides methods that correspond to different level of priority (importance) of the messages being recorded. From low to high priority: Log.v(): VERBOSE output. This is the most detailed, for everyday messages. This is often the go-to, default level for logging. Ideally, Log.v() calls should only be compiled into an application during development, and removed for production versions. Log.d(): DEBUG output. This is intended for lower-level, less detailed messages (but still code-level, that is referring to specific programming messages). These messages can be compiled into the code but are removed at runtime in production builds through Gradle. Log.i(): INFO output. This is intended for “high-level” information, such at the user level (rather than specifics about code). Log.w(): WARN output. For warnings Log.e(): ERROR output. For errors Also if you look at the API… Log.wtf()! These different levels are used to help “filter out the noise”. So you can look just at errors, at errors and warnings, at error, warn, and info… all the way down to seeing everything with verbose. A huge amount of information is logged, so filtering really helps! Each Log method takes two Strings as parameters. The second is the message to print. The first is a “tag”—a String that’s prepended to the output which you can search and filter on. This tag is usually the App or Class name (e.g., “AndroidDemo”, “MainActivity”). A common practice is to declare a TAG constant you can use throughout the class: private static final String TAG = &quot;MainActivity&quot;; Logcat You can view the logs via adb (the debugging bridge) and a service called Logcat (from “log” and “conCATenation”, since it concatenates the logs). The easiest way to check Logcat is to use Android Studio. The Logcat browser panel is usually found at the bottom of the screen after you launch an application. It “tails” the log, showing the latest output as it appears. You can use the dropdown box to filter by priority, and the search box to search (e.g., by tag if you want). Android Studio also lets you filter to only show the current application, which is hugely awesome. Note that you may see a lot of Logs that you didn’t produce, including possibly Warnings (e.g., I see a lot of stuff about how OpenGL connects to the graphics card). This is normal! It is also possible to view Logcat through the command-line using adb, and includes complex filtering arguments. See Logcat Command-line Tool for more details. Something else to test: Cause the app to throw a runtime Exception! For example, you could make a new local array and try to access an item out of bounds. Or just throw new RuntimeException() (which is slightly less interesting). Can you see the Stack Trace in the logs? Logging is fantastic and one of the the best techniques we have for debugging, both in how Activities are being used or for any kind of bug (also RuntimeExceptions). It harkens back to printline debugging, which is still a legitimate debugging process. Note that Android Studio does have a built-in debugger if you’re comfortable with such systems. Toast Logs are great for debugging output, but remember that they are only visible for developers (you need to have your phone plugged into the IDE or SDK!) If you want to produce an error or warning message for the user, you need to use a different technique. One simple, quick way of giving some short visual feedback is to use what is called a Toast. This is a tiny little text box that pops up at the bottom of the screen for a moment to quickly display a message. It’s called a “Toast” because it pops up! Toasts are pretty simple to implement, as with the following example (from the official documentation): Toast toast = Toast.makeText(this, &quot;Hello toast!&quot;, Toast.LENGTH_SHORT); toast.show(); //as one line. Don&#39;t forget to show()! Toast.makeText(this, &quot;Hello toast!&quot;, Toast.LENGTH_SHORT).show(); Toasts are created by using the Toast.makeText() factory method (instead of calling a constructor). This method takes three parameters: the Context, or what is producing the Toast (see Chapter 3), the text to display, and an int constant representing the length the Toast should appear. Toasts are intended to be a way to provide information to the user (e.g., giving them quick feedback), but they can possibly be useful for testing too (though in the end, Logcat is going to be your best bet for debugging, especially when trying to solve crashes or see more complex output). 1.5 Adding Interaction Finally, we’ve created a button and discussed how to show visual information to the user… so let’s hook those together! As with JavaScript, in order to have our button do something, we need to register a callback function that can be executed when the button is clicked. In Java, these callback functions are supplied by “listener” objects who can respond to events (see Appendix B for a more detailed discussion). First, we need to get access to a variable that represents the Button we defined in the XML—similar to what you do with document.getElementById() in JavaScript. The method to access an element in Android is called findViewById(), and can be called directly on the Activity: Button button = (Button)findViewById(R.id.my_button); As an argument, we pass in a value defined in the auto-generated R class that represents the button’s id value—this is based on what we put in the &lt;Button&gt;’s android:id attribute. The exact format is discussed in Lecture 2. Note that the method returns a View (a superclass of Button), so we almost always typecast the result. See Lecture 2 for more on the View class. We can then register a listener (callback) by calling the setOnClickListener() method and passing in an anonymous class to act as the listener: button.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { // Perform action on click } }); Tab completion is your friend!! Try just typing the button., and then selecting the method name from the provided list. Similarly, you can begin to type new OnClick and then tab-complete the rest of the class definition. The Android Studio IDE makes this ubiquitous boilerplate code easy to produce. Finally, we can fill in the method to have it log out or toast something when clicked! http://developer.android.com/reference/android/util/Log.html↩ "],
["resources-and-layouts.html", "Lecture 2 Resources and Layouts 2.1 Resources 2.2 Views 2.3 Layouts 2.4 Inputs", " Lecture 2 Resources and Layouts This lecture discusses Resources, which are used to represent elements or data that are separate from the behavior (functional logic) of an app. In particular, this lecture focuses on how resources are used to define Layouts for user interfaces. This lecture focuses on the XML-based source code in an Android app; the Activities lecture begins to detail the source code written in Java. This lecture references code found at https://github.com/info448/lecture02-layouts. 2.1 Resources Resources can be found in the res/ folder, and represent elements or data that are “external” to the code. You can think of them as “media content”: often images, but also things like text clippings (or short String constants), usually defined in XML files. Resources represent components that are separate from the app’s behavior, so are kept separate from the Java code to support the Principle of Separation of Concerns By defining resources in XML, they can be developed (worked on) without coding tools (e.g., with systems like the graphical “design” tab in Android Studio). Theoretically you could have a Graphic Designer create these resources, which can then be integrated into the code without the designer needing to do a lick of Java. Similarly, keeping resources separate allows you to choose what resources to include dynamically. You can choose to show different images based on device screen resolution, or pick different Strings based on the language of the device (internationalization!)—the behavior of the app is the same, but the “content” is different! What should be a resource? In general: Layouts should always be defined as resources UI controls (buttons, etc) should mostly be defined as resources (they are part of layouts), though behavior will be defined programmatically in Java Any graphic images (drawables) should be defined as resources Any user-facing strings should be defined as resources Style and theming information should be defined as resources As introduced in Lecture 1, there are a number of different resource types used in Android, and which can be found in the res/ folder of a default Android project, including: res/drawable/: contains graphics (PNG, JPEG, etc) res/layout/: contains UI XML layout files res/mipmap/: contains launcher icon files in different resolutions res/values/: contains XML definitions for general constants, which can include: /strings.xml: short string constants (e.g., button labels) /colors.xml: color constants /styles.xml : constants for style and theme details /dimen.xml : dimensional constants (like default margins); not created by default in Android Studio 2.3+. The details about these different kinds of resources is a bit scattered throughout the documentation, but Resource Types2 is a good place to start, as is Providing Resources. R Resources are usually defined as XML (which is similar in syntax to HTML). When an application is compiled, the build tools (e.g., Gradle) will generate an additional Java class called R (for “resource”). This class contains what is basically a giant list of static “constants”—at least one for each XML element. For example, consider the strings.xml resource, which is used to define String constants. The provided strings.xml defines two constants of type &lt;string&gt;. The name attribute specifies the name that the variable will take, and the content of the element gives that variable’s value. Thus &lt;string name=&quot;app_name&quot;&gt;Layout Demo&lt;/string&gt; &lt;string name=&quot;greeting&quot;&gt;Hello Android!&lt;/string&gt; will in effect be compiled into constants similar to: public static final String app_name = &quot;My Application&quot;; public static final String greeting = &quot;Hello Android!&quot;; All of the resource constants are compiled into inner classes inside R, one for each resource type. So an R file containing the above strings would be structured like: public class R { public static class string { public static final String app_name = &quot;My Application&quot;; public static final String greeting = &quot;Hello Android!&quot;; } } This allows you to use dot notation to refer to each resource based on its type (e.g., R.string.greeting)—similar to the syntax used to refer to nested JSON objects! For most resources, the identifier is defined as an element attribute (name attribute for values like Strings; id for specific View elements in layouts). For more complex resources such as entire layouts or drawables, the identifier is the filename (without the file extension): for example R.layout.activity_main refers to the root element of the layout/activity_main.xml file. More generally, each resource can be referred to with [(package_name).]R.resource_type.identifier. Note that the file name string.xml is just a convention for readability; all children of a &lt;resource&gt; element are compiled into R dependent on their type, not their source code location. So it is possible to have lots of different resource files, depending on your needs. The robot_list.xml file is not a standard resource. You can find the generated R.java file inside app/build/generated/source/r/debug/... (Use the Project Files view in Android Studio). If you actually open the R.java file, you’ll see that the static constants are actually just int values that are pointers to element references (similar to passing a pointer* around in the C language); the content of the value is stored elsewhere (so it can be adjusted at runtime; see below). This does mean that in our Java code we usually work with int as the data type for XML resources such as Strings, because we’re actually working with pointers to those resources. For example, the setContentView() call in an Activity’s onCreate() takes in a resource int. You can think of each int constant as a “key” or “index” for that resource (in the list of all resources). Android does the hard work of taking that int, looking it up in an internal resource table, finding the associated XML file, and then getting the right element out of that XML. (By hard work, I mean in terms of implementation. Android is looking up these references directly in memory, so the look-up is fast). Because the R class is included in the Java, we can access these int constants directly in our code (as R.resource_type.identifier), as in the setContentView() method. However, if you want to actually get the String value, you can look that up by using the application’s Resources() object: Resources res = this.getResources(); //get access to application&#39;s resources String myString = res.getString(R.string.myString); //look up value of that resource The other comment method that utilizes resources will be findViewById(int), which is used to reference a View element (e.g., a button) specified in a layout resource in order to call methods on it in Java, as in the example from the previous lecture. The R class is regenerated all time (any time you change a resource, which is often); when Eclipse was the recommend Android IDE, you often needed to manually regenerate the class so that the IDE’s index would stay up to date! You can perform a similar task in Android Studio by using Build &gt; Clean Project and Build &gt; Rebuild Project. It is also possible to reference one resource from another within the XML using the @ symbol, following the schema @[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt;. For example, in the Manifest you can see that the application’s label is referred to via @string/app_name. You can also use the + symbol to create a new resource that we can refer to; this is a bit like declaring a variable inside an XML attribute. This is most commonly used with the android:id attribute (android:id=&quot;@+id/identifier&quot;) to create a variable referring to that View; see below for details. Alternative Resources One main advantage to separating resources from the Java code is that it allows them to be localized and changed depending on the device! Android allows the developer to specify folders for “alternative” resources, such as for different languages or device screen resolutions. At runtime, Android will check the configuration of the device, and try to find an alternative resource that matches that configuration. If it it can’t find a relevant alternative resource, it will fall back to the “default” resource. There are many different configurations that can be used to influence resources; see Providing Resources3. To highlight a few options, you can specify different resources based on: Language and region (e.g., via two-letter ISO codes) Screen size(small, normal, medium, large, xlarge) Screen orientation (port for portrait, land for landscape) Specific screen pixel density (dpi) (ldpi, mdpi, hdpi, xhdpi, xxhdpi, etc.). xxhdpi is pretty common for high-end devices. Note that dpi is “dots per inch”, so these values represent the number of pixels relative to the device size! Platform version (v1, v4, v7… for each API number) Configurations are indicated using the directory name, giving folders the form &lt;resource_name&gt;(-&lt;config_qualifier&gt;)+. For example, the values-fr/ would contain constant values for devices with a French language configuration. Importantly, the resource file itself should to be the same for both the qualifier and unqualified resource name (e.g., values/strings.xml and values-fr/strings.xml). This is because Android will load the file inside the qualified resource if it matches the device’s configuration in place of the “default” unqualified resource. The names need to be the same so one can replace the other! You can see this in action by using the New Resource wizard (File &gt; New &gt; Android resource file) to create a string resource (such as for the app_name) in another language. Change the device’s language settings (via the device’s Settings &gt; Language &amp; Input &gt; Language) to see the content automatically adjust! &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Mon Application&lt;/string&gt; &lt;/resources&gt; You can view the directory structure that supports this by switching to the Package project view in Android Studio. 2.2 Views The most common type of element you’ll define as a resource are Views4. View is the superclass for visual interface elements—a visual component on the screen is a View. Specific types of Views include: TextViews, ImageViews, Buttons, etc. View is a superclass for these components because it allows us to use polymorphism to treat all these visual elements as instances of the same type. We can lay them out, draw them, click on them, move them, etc. And all the behavior will be the same (though subclasses can also have “extra” features). Here’s the big trick: one subclass of View is ViewGroup5. A ViewGroup is a View can contain other “child” Views. But since ViewGroup is a View… it can contain more ViewGroups inside it! Thus we can nest Views within Views, following the Composite Pattern. This ends up working a lot like HTML (which can have DOM elements like &lt;div&gt; inside other DOM elements), allowing for complex user interfaces. Like the HTML DOM, Android Views are thus structured into a tree, what is known as the View hierarchy. Views are defined inside of Layouts—that is, inside a layout resource, which is an XML file describing Views. These resources are “inflated” (rendered) into UI objects that are part of the application. Technically, a Layout is simply a ViewGroup that provide “ordering” and “positioning” information for the Views inside of it. Layouts let the system “lay out” the Views intelligently and effectively. Individual views shouldn’t know their own position; this follows from good good object-oriented design and keeps the Views encapsulated. Android studio does come with a graphical Layout Editor (the “Design” tab) that can be used to create layouts. However, most developers stick with writing layouts in XML. This is mostly because early design tools were pathetic and unusable, so XML was all we had. Although Android Studio’s graphical editor can be effective, for this course you should create layouts “by hand” in XML. This is helpful for making sure you understand the pieces underlying development, and is a skill you should be comfortable with anyway (similar to how we encourage people to use git from the command-line). View Properties Before we get into how to group Views, let’s focus on the individual, basic View classes. As an example, consider the activity_main layout in the lecture code. This layout contains two individual View elements (inside a Layout): a TextView and a Button. All View have properties which define the state of the View. Properties are usually specified within the resource XML as element attributes. Some examples of these property attributes are described below. android:id specifies a unique identifier for the View. This identifier needs to be unique within the layout, though ideally is unique within the entire app for clarity. The @+ syntax is used to define a new View id resource—almost like you are declaring a variable inside the element attribute! You will need to use the @+ whenever you specify a new id, which will allow it to be referenced either from the Java code (as R.id.identifier) or by other XML resources (as @id/identifier). Identifiers must be legal Java variable names (because they are turned into a variable name in the R class), and by convention are named in lower_case format. Style tip: it is useful to prefix each View’s id with its type (e.g., btn, txt, edt). This helps with making the code self-documenting! You should give each interactive View a unique id, which will allow its state to automatically be saved when the Activity is destroyed. See here for details. android:layout_width and android:layout_height are used to specify the View’s size on the screen (see ViewGroup.LayoutParams for documentation). These values can be a specific value (e.g., 12dp), but more commonly are one of two special values: wrap_content, meaning the dimension should be as large as the content requires, plus padding. match_parent, meaning the dimension should be as large as the parent (container) element, minus padding. This value was renamed from fill_parent (which has now been deprecated). Android utilizes the following dimensions or units: dp is a “density-independent pixel”. On a 160-dpi (dots-per-inch) screen, 1dp equals 1px (pixel). But as dpi increases, the number of pixels per dp increases. These values should be used instead of px, as it allows dimensions to work independent of the hardware’s dpi (which is highly variable). px is an actual screen pixel. DO NOT USE THIS (use dp instead!) sp is a “scale-independent pixel”. This value is like dp, but is scaled by the system’s font preference (e.g., if the user has selected that the device should display in a larger font, 1sp will cover more dp). You should always use sp for text dimensions, in order to support user preferences and accessibility. pt is 1/72 of an inch of the physical screen. Similar units mm and in are available. Not recommended for use. android:padding, android:paddingLeft, android:margin, android:marginLeft, etc. are used to specify the margin and padding for Views. These work basically the same way they do in CSS: padding is the space between the content and the “edge” of the View, and margin is the space between Views. Note that unlike CSS, margins between elements do not collapse. android:textSize specifies the “font size” of textual Views (use sp units!), android:textColor specifies the color of text (best practice: reference a color resource!), etc. There are lots of other properties as well! You can see a listing of generic properties in the View6 documentation, look at the options in the “Design” tab of Android Studio, or browse the auto-complete options in the IDE. Each different View class (e.g., TextView, ImageView, etc.) will also have their own set of properties. Note that unlike CSS, styling properties specified in the layout XML resources are not inherited: you’re effectively specifying an inline style attribute for that element, and one that won’t affect child elements. In order to define shared style properties, you’ll need to use styles resources, which are discussed in a later lecture. Views and Java Displaying a View on a screen is called inflating that View. The process is called “inflating” based on the idea that it is “unpacking” or “expanding” a compact resource description into a complex Java Object. When a View is inflated, it is instantiate as an object: the inflation process changes the &lt;Button&gt; XML into a new Button() object in Java, with the property attributes passed as a parameter to that constructor. Thus you can think of each XML element as representing a particular Java Object that will be instantiated and referenced at runtime. This is almost exactly like how JSX components in React are individual objects! Remember that you can get a reference to these objects from the Java code using the findViewById() method. Once you have a reference to a View object in Java, it is possible to specify visual properties dynamically via Java methods (e.g., setText(), setPadding()). However, you should only use Java methods to specify View properties when they need to be dynamic (e.g., the text changes in response to a button click)—it is much cleaner and effective to specify as much visual detail in the XML resource files as possible. It’s also possible to dynamically replace one layout resource with another (see below). Views also have inspection methods such as isVisible() and hasFocus() if you need to check the View’s state. DO NOT instantiate or define Views or View appearances in an Activity’s onCreate() method, unless the properties (e.g., content) truly cannot be determined before runtime! DO specify layouts in the XML instead. Practice Add a new ImageView element that contains a picture. Be sure and specify its id and size (experiment with different options). You should specify the content of the image in the XML resource using the android:src attribute (use @ to reference a drawable), but you can specify the content dynamically in Java code if you want to change it later. ImageView imageView = (ImageView)findViewById(R.id.img_view); imageView.setImageResource(R.drawable.my_image); 2.3 Layouts As mentioned above, a Layout is a grouping of Views (specifically, a ViewGroup). A Layout acts as a container for other Views, to help structure the elements on the screen. Layouts are all subclasses of ViewGroup, so you can use its inheritance documentation to see a (mostly) complete list of options, though many of the listed classes are deprecated in favor of later, more generic/powerful options. LinearLayout Probably the simplest Layout to understand is the LinearLayout. This Layout orders the children Views in a line (“linearly”). All children are laid out in a single direction, but you can specify whether this is horizontal or vertical with the android:orientation property. See LinearLayout.LayoutParams for a list of all attribute options! Remember: since a Layout is a ViewGroup is a View, you can also utilize all the properties discussed above such as padding or background color; the support of the attributes is inherited! (But remember that the properties themselves are not inherited by child elements: you can’t set the textSize for a Layout and have it apply to all child Views). Another common property you might want to control in a LinearLayout is how much of any remaining space the elements should occupy (e.g., should they expand). This is done with the android:layout_weght property. After all element sizes are calculated (via their individual properties), the remaining space within the Layout is divided up proportionally to the layout_weight of each element (which defaults to 0 so default elements get no extra space). See the example in the guide for more details. Useful tip: Give elements 0dp width or height and 1 for weight to make everything in the Layout the same size! This is a similar behavior to the flex-grow property in the CSS Flexbox framework. You can also use the android:layout_gravity property to specify the “alignment” of elements within the Layout (e.g., where they “fall” to). Note that this property is declared for individual child Views to state where they are positioned; the android:gravity property specifies where the content of an element should be aligned. An important point Since Layouts are Views, you can of course nest LinearLayouts inside each other! So you can make “grids” by creating a vertical LinearLayout containing “rows” of horizontal LinearLayouts (which contain Views). As with HTML, there are lots of different options for achieving any particular interface layout. RelativeLayout A RelativeLayout is more flexible (and hence powerful), but can be more complex to use. In a RelativeLayout, children are positioned “relative” to the parent OR to each other. All children default to the top-left of the Layout, but you can give them properties from RelativeLayout.LayoutParams to specify where they should go instead. For example: android:layout_verticalCenter centers the View vertically within the parent. android:layout_toRightOf places the View to the right of the View with the given resource id (use an @ reference to refer to the View by its id): &lt;TextView android:id=&quot;@+id/first&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;FirstString&quot; /&gt; &lt;TextView android:id=&quot;@+id/second&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/first&quot; android:layout_alignParentLeft=&quot;true&quot; android:text=&quot;SecondString&quot; /&gt; You do not need to specify both toRightOf and toLeftOf; think about placing one element on the screen, then putting another element relative to what came before. This can be tricky. For this reason the author prefers to use LinearLayouts, since you can always produce a Relative positioning using enough LinearLayouts (and most layouts end up being linear in some fashion anyway!) ConstraintLayout ConstraintLayout is a Layout provided as part of an extra support library, and is what is used by Android Studio’s “Design” tool (and thus is the default Layout for new layout resources). ConstraintLayout works in a manner conceptually similar to RelativeLayout, in that you specify the location of Views in relationship to one another. However, ConstraintLayout offers a more powerful set of relationships in the form of constraints, which can be used to create highly responsive layouts. See the class documentation for more details and examples of constraints you can add. The main advantage of ConstraintLayout is that it supports development through Android Studio’s Design tool. However, since this course is focusing on implementing the resource XML files rather than using the specific tool (that may change in a year’s time), we will primarily be using other layouts. Other Layouts There are many other layouts as well, though we won’t go over them all in depth. They all work in similar ways; check the individual class’s documentation for details. FrameLayout is a sort of “placeholder” layout that holds a single child View (a second child will not be shown). You can think of this layout as a way of adding a simple container to use for padding, etc. It is also highly useful for situations where the framework requires you to specify a Layout resource instead of just an individual View. GridLayout arranges Views into a Grid. It is similar to LinearLayout, but places elements into a grid rather than into a line. Note that this is different than a Grid_View_, which is a scrollable, adaptable list (similar to a ListView, which is discussed in the next lecture). TableLayout acts like an HTML table: you define TableRow layouts which can be filled with content. This View is not commonly used. CoordinatorLayout is a class provided as part of an extra support library, and provides support for Material Design widgets and animations. See Lecture 5 for more details. Combining and Inflating Layouts It is possible to combine multiple layout resources files. This is useful if you want to dynamically change what Views are included, or to refactor parts of a layout into different XML files to improve code organization. As one option, you can statically include XML layouts inside other layouts by using an &lt;include&gt; element: &lt;include layout=&quot;@layout/sub_layout&quot;&gt; But it is also possible to dynamically load views “manually” (e.g., in Java code) using the LayoutInflator. This is a class that has the job of “inflating” (rendering) Views. LayoutInflator is implicitly used in the setContentView() method, but can also be used independently with the following syntax: LayoutInflator inflator = getLayoutInflator(); //access the inflator (called on the Activity) View myLayout = inflator.inflate(R.layout.my_layout, parentViewGroup, true); //to attach Note that we never instantiate the LayoutInflator, we just access an object that is defined as part of the Activity. The inflate() method takes a couple of arguments: The first parameter is a reference to the resource to inflate (an int saved in the R class) The second parameter is a ViewGroup to act as the “parent” for this View—e.g., what layout should the View be inflated inside? This can be null if there is not yet a layout context; e.g., you wish to inflate the View but not show it on the screen yet. The third (optional) parameter is whether to actually attach the inflated View to that parent (if not, the parent just provides context and layout parameters to use). If not assigning to parent on inflation, you can later attach the View using methods in ViewGroup (e.g., addView(View)). Manually inflating a View works for dynamically loading resources, and we will often see UI implementation patterns that utilize Inflators. However, for dynamic View creation explicit inflation tends to be messy and hard to maintain (UI work should be specified entirely in the XML, without needing multiple references to parent and child Views) so isn’t as common in modern development. A much cleaner solution is to use a ViewStub7. A ViewStub is like an “on deck” Layout: it is written into the XML, but isn’t actually shown until you choose to reveal it via Java code. With a ViewStub, Android inflates the View at runtime, but then removes it from the parent (leaving a “stub” in its place). When you call inflate() (or setVisible(View.VISIBLE)) on that stub, it is reattached to the View tree and displayed: &lt;!-- XML --&gt; &lt;ViewStub android:id=&quot;@+id/stub&quot; android:inflatedId=&quot;@+id/subTree&quot; android:layout=&quot;@layout/mySubTree&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; //Java ViewStub stub = (ViewStub)findViewById(R.id.stub); View inflated = stub.inflate(); There are many other options for displaying or changing View content. Just remember to define as much of the View as possible in the XML, so that the Java code is kept simple and separate. 2.4 Inputs So far we you have used some basic Views such as TextView, ImageView, and Button. A Button is an example of an Input Control. These are simple (read single-purpose; not necessarily lacking complexity) widgets that allow for user input. There are many such widgets in addition to Button, mostly found in the android.widget package. Many correspond to HTML &lt;input&gt; elements, but Android provided additional widgets at well. You can change the lecture code’s MainActivity to show a View of R.id.input_control_layout to see an example of many widgets (as well as a demonstration of a more complex layout!). These widgets include: Button, a widget that affords clicking. Buttons can display text, images or both. EditText, a widget for user text entry. Note that you can use the android:inputType property to specify the type of the input similar to an HTML &lt;input&gt;. Checkbox, a widget for selecting an on-off state. RadioButton, a widget for selecting from a set of choices. Put RadioButton elements inside a RadioGroup element to make the buttons mutually exclusive. ToggleButton, another widget for selecting an on-off state. Switch, yet another widget for selecting an on-off state. This is just a ToggleButton with a slider UI. It was introduced in API 14 and is the “modern” way of supporting on-off input. Spinner, a widget for picking from an array of choices, similar to a drop-down menu. Note that you should define the choices as a resource (e.g., in strings.xml). Pickers: a compound control around some specific input (dates, times, etc). These are typically used in pop-up dialogs, which will be discussed in a future lecture. …and more! See the android.widget package for further options. All these input controls basically work the same way: you define (instantiate) them in the layout resource, then access them in Java in order to define interaction behavior. There are two ways of interacting with controls (and Views in general) from the Java code: Calling methods on the View to manipulate it. This represents “outside to inside” communication (with respect to the View). Listening for events produced by the View and responding to then. This represents “inside to outside” communication (with respect to the View). An example of the second, event-driven approach was introduced in Lecture 1. This involves registering a listener for the event (after acquiring a reference to the View with findViewById()) and then specifying a callback method (by instantiating the Listener interface) that will be “called back to” when the event occurs. It is also possible to specify the callback method in the XML resource itself by using e.g., the android:onClick attribute. This value of this attribute should be the name of the callback method: &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;handleButtonClick&quot; /&gt; The callback method is declared in the Java code as taking in a View parameter (which will be a reference to whatever View caused the event to occur) and returning void: public void handleButtonClick(View view) { } We will utilize a mix of both of these strategies (defining callbacks in both the Java and the XML) in this class. Author’s Opinion: It is arguable about which approach is “better”. Specifying the callback method in the Java code helps keep the appearance and behavior separate, and avoids introducing hidden dependencies for resources (the Activity must provide the required callback). However, as buttons are made to be pressed, it isn’t unreasonable to give a “name” in the XML resource as to what the button will do, especially as the corresponding Java method may just be a “launcher” method that calls something else. Specifying the callback in the XML resource may often seem faster and easier, and we will use whichever option best supports clarity in our code. Event callbacks are used to respond to all kind of input control widgets. CheckBoxes use an onClick callback, ToggleButtons use onCheckedChanged, etc. Other common events can be found in the View documentation, and are handled via listeners such as OnDragListener (for drags), OnHoverListener (for “hover” events), OnKeyListener (for when user types), or OnLayoutChangeListener (for when the layout changes). In addition to listening for events, it is possible to call methods directly on referenced Views to access their state. In addition to generic View methods such as isVisible() or hasFocus(), it is possible to inquire directly about the state of the input provided. For example, the isChecked() method returns whether or not a checkbox is ticked. This is also a good way of getting access to inputted content from the Java Code. For example, call getText() on an EditText control in order to fetch the contents of that View. For practice, try to log out the contents of the included EditText control when the Button is pressed! Between listening for events and querying for state, we can fully interact with input controls. Check the official documentation for more details on how to use specific individual widgets. https://developer.android.com/guide/topics/resources/available-resources.html↩ http://developer.android.com/guide/topics/resources/providing-resources.html↩ http://developer.android.com/reference/android/view/View.html↩ http://developer.android.com/reference/android/view/ViewGroup.html↩ http://developer.android.com/reference/android/view/View.html#lattrs↩ http://developer.android.com/training/improving-layouts/loading-ondemand.html↩ "],
["activities.html", "Lecture 3 Activities 3.1 Making Activities 3.2 The Activity Lifecycle 3.3 Context 3.4 Multiple Activities", " Lecture 3 Activities This lecture introduces Activities, which are the basic component used in Android applications. Activities provide a framework for the Java code that allows the user to interact with the layouts defined in the resources. This lecture references code found at https://github.com/info448/lecture03-activities. According to Google: An Activity is an application component that provides a screen with which users can interact in order to do something. You can think of an Activity as a single screen in your app, the equivalent of a “window” in a GUI system. Note that Activities don’t need to be full screens: they can also be floating modal windows, embedded inside other Activities (like half a screen), etc. But we’ll begin by thinking of them as full screens. We can have lots of Activities (screens) in an application, and they are loosely connected so we can easily move between them. In many ways, an Activity is a “bookkeeping mechanism”: a place to hold state and data, and tell to Android what to show on the display. It functions much like a Controller (in the Model-View-Controller sense) in that regard! Also to note from the documentation8: An activity is a single, focused thing that the user can do. which implies a design suggestion: Activities (screens) break up your App into “tasks”. Each Activity can represent what a user is doing at one time. If the user does something else, that should be a different Activity (and so probably a different screen). 3.1 Making Activities We specify an Activity for an app by subclassing (extending) the framework’s Activity class. We use inheritance to make a specialized type of Activity. By extending this class, we inherit all of the methods that are needed to control how the Android OS interacts with the Activity—behaviors like showing the screen, allowing Activities to change, and closing the Activity when it is no longer being used. If you look at the default Empty MainActivity, it actually subclasses AppCompatActivity, which is itself a already a specialized subclass of Activity that provides an ActionBar (the toolbar at the top of the screen with the name of you app). If you change the class to just extend Activity, that bar disappears. To make this change, you will need to import the Activity class! The keyboard shortcut to import a class in Android Studio is alt+return, or you can do it by hand (look up the package in the documentation)! I recommend that you change the IDE’s preferences to automatically import classes you use. There are a number of other built-in Activity subclasses that we could subclass instead. We’ll mention them as they become relevant. Many of the available classes have been deprecated in favor of Fragments, which are sort of like “sub-activities” that get nested in larger Activities. Fragments will be discussed in a later lecture. 3.2 The Activity Lifecycle An important point to note: does this Activity have a constructor that we call? No! We never write code that instantiates our Activity (that is: we never call new MainActivity()). There is no main() method in Android. Activities are created and managed by the Android operating system when the app is launched. Although we never call a constructor or main() method, Activities do have an very well-defined lifecycle—that is, a series of events that occur during usage (e.g., when the Activity is created, when it is stopped, etc). When each of these events occur, Android executes a callback method, just like how you specified the onClick() method to react to a button press. We can override these lifecycle callbacks in order to do special actions (read: run our own code) when these events occur. What is the lifecycle? Lifecycle state diagram, from Google9. See also an alternative, simplified diagram. There are 7 “events” that occur in the Activity Lifecycle, which are designated by the callback function that they execute: onCreate(): called when the Activity is first created/instantiated. This is where you initialize the UI (e.g., specify which layout to use), and otherwise do the kinds of work that might go in a constructor. onStart(): called just before the Activity becomes visible to the user. The difference between onStart() and onCreate() is that onStart() can be called more than once (e.g., if you leave the Activity, thereby hiding it, and come back later to make it visible again). onResume(): called just before user interaction starts, indicating that the Activity is ready to be used! This is a little bit like when that Activity “has focus”. While onStart() is called when the Activity becomes visible, onResume() is called when it is ready for interaction. It is possible for an Activity to be visible but not interactive, such as if there is a modal pop-up in front of it (partially hiding it). “onFocus” would have been a better name for this callback. onPause(): called when the system is about to start another Activity (so this one is about to lose focus). This is the “mirror” of onResume(). When paused, the activity stays visible! This callback is usually used to quickly and temporarily store unsaved changes (like saving an email draft in memory) or stop animations or video playback. The Activity may be being closed (and so is on its way out), but could just be losing focus. onStop(): called when the Activity is no longer visible. (e.g., another Activity took over, but also possibly because the current Activity has been destroyed). This callback is a mirror of onStart(). This callback is where you should persist any state information (e.g., saving the user’s document or game state). It is intended to do more complex “saving” work than onPause(). onRestart(): called when the Activity is coming back from a “stopped” state. This event allows you to run distinct code when the App is being “restarted”, rather than created for the first time. It is the least commonly used lifecycle callback. onDestroy(): called when the Activity is about to be closed. This can happen because the user ended the application, or (and this is important!) because the OS is trying to save memory and so kills the Activity on its own. The onDestroy() callback can do final app cleanup, but its is considered better practice to have such functionality in onPause() or onStop(), since they are more reliably executed. Activities are also destroyed (and recreated) when the device’s configuration changes—such as if you rotate the phone! Android apps run on devices with significant hardware constraints in terms of both memory and battery life. Thus the Android OS is very aggressive about not leaving apps running “in the background”. If it determines that an App is no longer necessary (such as because it has been hidden for a while), that app will be destroyed (shut down). Note that this destruction is unpredictable, as the “necessity” of an app being open is dependent on the OS’s resource allocation rules. Thus in practice, you should implement Activities as if they could be destroyed at any moment—you cannot rely on them to continue running if they are not visible. Note that apps may not need to use all of these callbacks! For example, if there is no difference between starting from scratch and resuming from stop, then you don’t need an onRestart() (since onStart() goes in the middle). Similarly, onStart() may not be needed if you just use onCreate() and onResume(). But these lifecycles allow for more granularity and the ability to avoid duplicate code. Overriding the Callback Methods When you create an new Empty MainActivity, the onCreate() callback has already been overridden for you, since that’s where the layout is specified. Notice that this callback takes a Bundle as a parameter. A Bundle is an object that stores key-value pairs, like a super-simple HashMap (or an Object in JavaScript, or dictionary in Python). Bundles can only hold basic types (numbers, Strings) and so are used for temporarily “bundling” small amounts of information. See before for details. Also note that we call super.onCreate(). Always call up the inheritance chain!. This allows the system-level behavior to continue without any problem. We can also add other callbacks: for example, onStart() (see the documentation for examples). Again, the IDE’s auto-complete feature lets you just type the name of the callback and get the whole method signature for free! We can quickly add in the event callbacks and Log.v() calls to confirm that they are executed. Then you can use the phone to see them occur: onCreate(), onStart() and onResume() are called when the app is instantiated. You can onPause() the Activity by dragging down the notification drawer from the top of the screen. You can onStop() the Activity by going back to the home screen (click the circle at the bottom). You can onDestroy() the Activity by changing the configuration and rotating the phone: click the “rotate” button on the emulator’s toolbar. Saving and Restoring Activity State As mentioned above, an Activity’s onCreate() method takes in a Bundle as a parameter. This Bundle is used to store information about the Activity’s current state, so that if the Activity is destroyed and recreated (e.g., when the phone is rotated), it can restored in the same state and the user won’t lose any data. For example, the Bundle can store state information for View elements, such as what text a user has typed into an EditText. That way when the user rotates their phone, they won’t lose the form input they’ve entered! If a View has been given an android:id attribute, then that id is used to automatically save the state of that View, with no further effort needed on your own. So you should always give input Views ids! You can also add your own custom information to the Bundle by overriding the Activity’s onSaveInstanceState() callback (use the one for AppCompactActivity that only takes one parameter). It takes as a parameter the Bundle that is being constructed with the saved data: you can add more information to this Bundle using an appropriate put() method (similar to the method used for Maps, but type-sensitive): //declare map key as a constant private static final String MSG_KEY = &quot;message_key&quot;; @Override protected void onSaveInstanceState(Bundle outState) { //put value &quot;Hello World&quot; in bundle with specified key outState.putString(MSG_KEY, &quot;Hello World&quot;); super.onSaveInstanceState(outState); } Note that you should always declare Bundle keys as CONSTANTS to help with readability/modifiability and to catch typos. Be sure to always call super.onSaveInstanceState() so that the super class can do its work to save the View hierarchy’s state! In fact, the reason that Views “automatically” save their state is because this method is calling their own onSaveInstanceState() callback. You can access this saved Bundle from the Activity’s onCreate() method when the Activity is recreated. Note that if the Activity is being created for the first time, then the Bundle will be null—checking for a null value is thus a good way to check if the Activity is being recreated or not: protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); if(savedInstanceState != null){ //Activity has been recreated String msg = savedInstanceState.getString(MSG_KEY); } else { //Activity created for first time } } Remember that a Bundle can only hold a small amount of primitive data: just a couple of numbers or Strings. For more complex data, you’ll need to use the alternative data storage solutions discussed in later lectures. 3.3 Context If you look at the documentation for the Activity class, you’ll notice that it is itself a subclass of something called a Context10. Context is an abstract class that acts as a reference for information about the current running environment: it represents environmental data (information like “What OS is running? Is there a keyboard plugged in?”). You can almost think of the Context as representing the “Application”, though it’s broader than that (Application is actually a subclass of Context!) The Context is used to do “application-level” actions: mostly working with resources (accessing and loading them), but also communicating between Activities. Effectively, it lets us refer to the state in which we are running: the “context” for our code (e.g., “where is this occurring?”). It’s a kind of reflection or meta-programming, in a way. For example, the getResources() method discussed in the last chapter is a method of the Context class, because we need to have some way of saying which set of resources to load! There are a couple of different kinds of Contexts we might wish to refer to: The Application context (e.g., an Application object) references the state of the entire application. It’s basically the Java object that is built out of the &lt;application&gt; element in the Manifest (and so contains that level of information). The Activity context (e.g., an Activity object) that references the state of that Activity. Again, this roughly corresponds to the Java objects created out of the &lt;activity&gt; elements from the Manifest. Each of these Context objects exist for the life of its respective component: that is, an Activity Context is available as long as the Activity exists (disappearing after onDestroy()), whereas Application Contexts survive as long as the application does. We’ll almost always use the Activity context, as it’s safer and less likely to cause memory leaks. Inside an Activity object (e.g., in a lifecycle callback function), you can refer to the current Activity using this. And since Activity is a Context, you can also use this to refer to the current Activity context. You’ll often see Context methods—like getResources()—called as undecorated methods (without an explicit this). You’ll need to refer to the Context whenever you want to do something beyond the Activity you’re working with: whether that’s accessing resources, showing a Toast (the first parameter to Toast.makeText() is a Context), or opening another Activity. 3.4 Multiple Activities The whole point of interfacing with the Activity Lifecycle is to handle the fact that Android applications can have multiple activities and interact with multiple other applications. In this section we’ll briefly discuss how to include multiple Activities within an app (in order to sense how the lifecycle may affect them). Note that working with multiple Activities will be discussed in more detail in a later lecture. We can easily create a New Activity through Android Studio by using File &gt; New &gt; Activity. We could also just add a new .java file with the Activity class in it, but using Android Studio will also provide the onCreate() method stub as well as a layout resource. For practice, make a new Empty Activity called SecondActivity. You should edit this Activity’s layout resource so that the &lt;TextView&gt; displays an appropriate message. Importantly, for every Activity you make, an entry gets added to the Manifest file AndroidManifest.xml. This file acts like the “table of contents” for our application, giving information about what your app looks (that is, what Activities it has) like so that the OS can open appropriate Activities as needed. (If you create an Activity’s .java file manually, you will need to add this entry manually as well). Activities are listed as &lt;activity&gt; elements nested in the &lt;application&gt; element. If you inspect the file you will be able to see an element representing the first MainActivity; that entry’s child elements will be discussed later. We can add android:label attributes to these &lt;activity&gt; elements in order to give the Activities nicer display names (e.g., in the ActionBar). Intents In Android, we don’t start new Activities by instantiating them (remember, we never instantiate Activities!). Instead, we send the operating system a message requesting that the Activity perform a particular action (i.e., start up and display on the screen). These messages are called Intents, and are used to communicate between app components like Activities. The Intent system allows Activities to communicate, even though they don’t have references to each other (we can’t just call a method on that other Activity). I don’t have a good justification for the name, other than Intents announce an “intention” for the OS to do something (like start an Activity) You can think of Intents as like letters you’d send through the mail: they are addressed to a particular target (e.g., another Activity—or more properly a Context), and contain a brief message about what to do. An Intent is an object we can instantiate: for example, we can create a new Intent in the event handler for when we click the button on MainActivity. The Intent class has a number of different constructors, but the one we’ll start with looks like: Intent intent = new Intent(MainActivity.this, SecondActivity.class); The first parameter is the Context by which this Intent will be delivered (e.g., this). Note that we use the fully qualified MainActivity.this to indicate that we’re not talking about the anonymous event handler class. The second parameter to this constructor is the Class we want to send the Intent to (the .class property fetches a reference to the class type; this is metaprogramming!). Effectively, it is the “address” on the envelop for the message we’re sending. After having instantiated the Intent, we can use that message to start an Activity by calling the startActivity() method (inherited from Activity), and passing it the Intent: startActivity(intent); This method will “send” the message to the operating system, which will deliver the Intent to the appropriate Activity, telling that Activity to start as soon as it receives the message. With this interaction in place, we can now click a button to start a second activity, (and see how that impacts our lifecycle callbacks). And we can use the back button to go backwards! There are actually a couple of different kinds of Intents (this is an Explicit Intent, because it is explicit about what Activity it’s sent to), and a lot more we can do with them. We’ll dive into Intents in more detail in a later lecture; for now we’re going to focus on mostly Single Activities. For example, if you look back at the Manifest, you can see that the MainActivity has an &lt;intent-filter&gt; child element that allows it to receive particular kinds of Intents—including ones for when an App is launched for the first time! Back &amp; Tasks We’ve shown that we can have lots of Activities (and of course many more can exist across multiple apps), and we are able to move between them by sending Intents and clicking the “Back” button. But how exactly is that “Back” button able to keep track of where to go to? The abstract data type normally associated with “back” or “undo” functionality is a stack, and that is exactly what Android uses. Every time you start a new Activity, Android instantiates that object and puts it on the top of a stack. Then when you hit the back button, that activity is “popped” off the stack and you’re taken to the Activity that is now at the top. An example of the Activity stack, from Google11. However, you might have different “sequences” of actions you’re working on: maybe you start writing an email, and then go to check your Twitter feed through a different set of Activities. Android breaks up these sequences into groups called Tasks. A Task is a collection of Activities arranged in a Stack, and there can be multiple Tasks in the background of your device. Tasks usually start from the Android “Home Screen”—then launching an application starts a new Task. Starting new Activities from that application will add them to the Stack of the Task. If you go back to the Home Screen, the Task you’re currently on is moved to the background, so the “back” button won’t let you navigate that Stack. It’s useful to think of Tasks as being like different tabs in a web browser, with the “back stack” being the history of web pages visited within that tab. As a demonstration, try switching to another (built-in) app and then back to the example app; how does the back button work in each situation? An important caveat: Tasks are distinct from one another, so you can have different copies of the same Activity on multiple stacks (e.g., the Camera activity could be part of both Facebook and Twitter app Tasks if you are on a selfie binge). It is possible to modify this behavior though, see Managing Tasks Up Navigation We can make this “back” navigation a little more intuitive for users by providing explicit up navigation, rather than just forcing users to go back through Activities in the order they viewed them (e.g., if you’re swiping through emails and want to go back to the home list). To do this, we just need to add a little bit of configuration to our Activities: In the Java code, we want to add more functionality to the ActionBar. Think: which lifecycle callback should this specification be put in? //specify that the ActionBar should have an &quot;home&quot; button getSupportActionBar().setHomeButtonEnabled(true); Then in the Manifest, add an android:parentActivityName attribute to the SecondActivity, with a value set to the full class name (including package and appname!) of your MainActivity. This will let you be able to use the “back” visual elements (e.g., of the ActionBar) to move back to the “parent” activity. See Up Navigation for details. &lt;activity android:name=&quot;.SecondActivity&quot; android:label=&quot;Second Activity&quot; android:parentActivityName=&quot;edu.uw.activitydemo.MainActivity&quot;&gt; &lt;meta-data android:name=&quot;android.support.PARENT_ACTIVITY&quot; android:value=&quot;edu.uw.activitydemo.MainActivity&quot; /&gt; &lt;/activity&gt; The &lt;meta-data&gt; element is to provide backwards compatibility for API level 15 (since the android:parentActivityName attribute is only defined for API level 16+). https://developer.android.com/reference/android/app/Activity.html↩ http://developer.android.com/images/activity_lifecycle.png↩ https://developer.android.com/reference/android/content/Context.html↩ http://developer.android.com/images/fundamentals/diagram_backstack.png↩ "],
["data-views.html", "Lecture 4 Data-Driven Views 4.1 ListViews and Adapters 4.2 Networking with Volley", " Lecture 4 Data-Driven Views Lecture 3 discussed how to use Views to display content and support user interaction. This lecture extends those concepts and presents techniques for creating data-driven views—views that can dynamically present a data model in the form of a scrollable list. It also explains how to access data on the web using the Volley library. Overall, this process demonstrates a common way to connect the user interface for the app (defined as XML) with logic and data controls (defined in Java), following the Model-View-Controller architecture found throughout the Android framework. This lecture references code found at https://github.com/info448/lecture04-lists. 4.1 ListViews and Adapters In particular, this lecture discussed how to utilize a ListView12, which is a ViewGroup that displays a scrollable list of items! A ListView is basically a LinearLayout inside of a ScrollView (which is a ViewGroup that can be scrolled). Each element within the LinearLayout is another View (usually a Layout) representing a particular item in a list. But the ListView does extra work beyond just nesting Views: it keeps track of what items are already displayed on the screen, inflating only the visible items (plus a few extra on the top and bottom as buffers). Then as the user scrolls, the ListView takes the disappearing views and recycles them (altering their content, but not re-inflating from scratch) in order to reuse them for the new items that appear. This lets it save memory, provide better performance, and overall work more smoothly. See this tutorial for diagrams and further explanation of this recycling behavior. Note that a more advanced and flexible version of this behavior is offered by the RecyclerView class, which works in mostly the same way but requires a few extra steps to set up. See also this guide for more details. The ListView control uses a Model-View-Controller (MVC) architecture. This is a design pattern common to UI systems which organizes programs into three parts: The Model, which is the data or information in the system The View, which is the display or representation of that data The Controller, which acts as an intermediary between the Model and View and hooks them together. The MVC pattern can be found all over Android. At a high level, the resources provide models and views (separately), while the Java Activities act as controllers. Fun fact: The Model-View-Controller pattern was originally developed as part of the Smalltalk language, which was the first Object-Oriented language! Thus in order to utilize a ListView, we’ll have some data to be displayed (the model), the views (layouts) to be shown, and the ListView itself will connect these together act as the controller. Specifically, the ListView is a subclass of AdapterView, which is a View backed by a data source—the AdapterView exists to hook the View and the data together (just as a controller should). There are other AdapterViews as well. For example, GridView works exactly the same way as a ListView, but lays out items in a scrollable grid rather than a scrollable list. In order to use a ListView, we need to get the pieces in place: First we specify the model: some raw data. We will start with a simple String[], filling it with placeholder data: String[] data = new String[99]; for(int i=99; i&gt;0; i--){ data[99-i] = i+ &quot; bottles of beer on the wall&quot;; } While we normally should define such hard-coded data as an XML resource, we’ll create it dynamically for testing (and to make it changeable later!) Next we specify the view: a View to show for each datum in the list. Define an XML layout resource for that (list_item is a good name and a common idiom). We don’t really need to specify a full Layout (though we could if we wanted): just a basic TextView will suffice. Have the width match_parent and the height wrap_content. Don’t forget an id! &lt;!-- need to include the XML namespace (xmlns) so the `android` namespace validates --&gt; &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/txtItem&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; To make it look better, you can specify android:minHeight=&quot;?android:attr/listPreferredItemHeight&quot; (using the framework’s preferred height for lists), and some center_vertical gravity. The android:lines property is also useful if you need more space. Finally, we specify the controller: the ListView itself. Add that item to the Activity’s Layout resource (practice: what should its dimensions be?) To finish the controller ListView, we ned to provide it with an Adapter13 which will connect the model to the view. The Adapter does the “translation” work between model and view, performing a mapping from data types (e.g., a String) and View types (e.g., a TextView). Specifically, we will use an ArrayAdapter, which is one of the simplest Adapters to use (and because we have an array of data!) An ArrayAdapter creates Views by calling .toString() on each item in the array, and setting that String as the content of a TextView! ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.list_item_layout, R.layout.list_item_txtView, myStringArray); Note the parameters of the constructor: a Context to access resources, the layout resource to use for each item, the TextView within that layout (the target of the mapping), and the data array (the source of the mapping). Also note that this instance utilizes generics: we’re using an array of Strings (as opposed to an array of Dogs or some other type). We acquire a reference to the ListView with findViewById(), and call ListView#setAdapter() to attach the adapter to that controller. ListView listView = (ListView)findViewById(R.id.list_view); listView.setAdapter(adapter); And that’s all that is needed to create a scrollable list of data! To track the process: the Adapter will go through each item in the model, and “translate” that item into the contents of a View. These Views will then be displayed in a scrollable list. Each item in this list is selectable (can be given an onClick callback). This allows us to click on any item in order to (for example) get more details about the item. Utilize the AdapterView#setOnItemClickListener(OnItemClickListener) function to register the callback. The position parameter in the onItemClick() callback is the index of the item which was clicked. Use (Type)parent.getItemAtPosition(position) to access the data value associated with that View. Additionally, each item does have an individual layout, so you can customize these appearances (e.g., if our layout also wanted to include pictures). See this tutorial for an example on making a custom adapter to fill in multiple Views with data from a list! And remember, a GridView is basically the same thing (in fact, we can just change over that and have everything work, if we use polymorphism!) 4.2 Networking with Volley A list with hard-coded data isn’t very useful. It would be better if that data could be accessed dynamically, such as downloaded from the Internet! There are a couple of different ways to programmatically send network requests from an Android application. The “lowest level” is to utilize the HttpURLConnection API. With this API, you call methods to open a connection to a URL and then to send an HTTP Request to that location. The response is returned as an InputStream, which you need to “read” byte by byte in order to reconstruct the received data (e.g., to make it back into a String). See this example for details. While this technique is effective, it can be tedious to implement. Moreover, downloading network data can take a while—and these network method calls are synchronous and blocking, so will prevent other code from running while it downloads—including code that enables the user interface! Such block will lead to the infamous “Application not responding” (ANR) error. While it is possible to send such requests asynchronously on a background thread to avoid blocking, that requires additional overhead work. See the Background Services Lecture for more details. To solve these problems with less work, it can be be more effective to utilize an external library that lets us abstract away this process and just talk about making network requests and getting data back from them. (This is similar to how in web programming the fetch API abstracts the opaque XMLHttpRequest object). In particular, this lecture will introduce the Volley library, which is an external library developed and maintained by Google. It provides a number of benefits over a more “manual” approach, including handling multiple concurrent requests and enabling the caching of downloaded data. It also causes network requests to be handled asynchronously on a background thread without any additional effort! Volley’s main “competitor” is the Retrofit library produced by Square. While Retrofit is usually faster at processing downloaded data, Volley has built-in support for handling images (which will be useful in the future), and has a slightly more straightforward interface. Using Volley Because Volley is an external library (it isn’t built into the Android framework), you need to explicitly download and include it in your project. Luckily, we can use the Gradle build system to do this for us by listing Volley as a dependency for the project. Inside the app-level build.gradle file, add the following line inside the dependencies list: compile &#39;com.android.volley:volley:1.0.0&#39; This will tell Android that it should download and include version 1.0.0 of the Volley library when it builds the app. Hit the “Sync” button to update and rebuild the project. External libraries will be built into your app, increasing the file size of the compiled .apk (there is more code!). Though this won’t cause any problems for us, it’s worth keeping in mind as you design new apps. Once you have included Volley as a dependency, you will have access to the classes and API to use in your code. In order to request data with Volley, you will need to instantiate a Request object based on the type of data you will be downloading: a StringRequest for downloading text data, a JsonRequest for downloading JSON formatted data, or an ImageRequest for downloading images. The constructor for StringRequest, for example, takes 4 arguments: A constant representing the HTTP method (verb) to use. E.g., Request.Method.GET The URL to send the request to (as a String) A Response.Listener object, which defines a callback function to be executed when the response is received. A Response.ErrorListener object, which defines a callback function to be executed in case of an error. Because the last two listener objects are usually defined with anonymous classes, this can make the Request constructor look more complicated than it is: //silly example: get 20 random dinosaur names String url = &quot;http://dinoipsum.herokuapp.com/api/?format=text&amp;words=20&amp;paragraphs=1&quot;; Request myRequest = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() { public void onResponse(String response) { Log.v(TAG, response); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { Log.e(TAG, error.toString()); } }); (Also note that the Response.Listener is a generic class, in which we specify the format we’re expecting the response to come back in. This is String for a StringRequest, but would be e.g., JSONObject for a JsonObjectRequest). In order to actually send this Request, you need a RequestQueue, which acts like a “dispatcher” and handles sending out the Requests on background threads and otherwise managing the network operations. We create a dispatcher with default parameters (for networking and caching) using the Volley.newRequestQueue() factory method: RequestQueue requestQueue = Volley.newRequestQueue(getApplicationContext()); The factory method takes in a Context for managing the cache; the best practice is to use the application’s Context so it isn’t dependent on a single Activity. Once you have a RequestQueue, you can add your request to that in order to “send” it: requestQueue.add(myRequest); If you test this code, you’ll notice that it doesn’t work! The program will crash with a SecurityException. As a security feature, Android apps by default have very limited access to the overall operating system (e.g., to do anything other than show a layout). An app can’t use the Internet (which might consume people’s data plans!) without explicit permission from the user. This permission is given by the user at install time. In order to get permission, the app needs to ask for it (“Mother may I…?”). We do that by declaring that the app uses the Internet in the AndroidManifest.xml file (which has all the details of our app!) &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;!-- put this ABOVE the &lt;application&gt; tag --&gt; Note that Marshmallow introduced a new security model in which users grant permissions at run-time, not install time, and can revoke permissions whenever they want. To handle this, you need to add code to request “dangerous” permissions (like Location, Phone, or SMS access) each time you use it. This process is discussed in the Files and Permissions Lecture. Using the Internet is not a dangerous permission, so only requires the permission declaration in the Manifest. Once we’ve requested permission (and have been granted that permission by virtue of the user installing our application), we can finally connect to the Internet to download data. We can log out the request results to prove we got it! Of course, we’d like to display that data on the screen (rather than just log it out). That is, we want to put it into the ListView, meaning that we need to feed it back into the Adapter (which works to populate the Views). First, clear out any previous data items in the adapter using adapter.clear(). Then use adapter.add() or (adapter.addAll()) to add each of the new data items to the Adapter’s model! Note that you may need to do data parsing on the response body, such as splitting a String or constructing an array or ArrayList out of JSON data. You can call notifyDataSetChanged() on the Adapter to make sure that the View knows the data has changed, but this method is already called by the .add() method so isn’t necessary in this situation. You can use the JsonObjectRequest class to download data as a JSON Object rather than a raw String. JSON Objects and Arrays can be converted into Java Objects/Arrays using two classes: JSONObject and JSONArray. The constructors for each of these classes take a JSON String, and you can call the getJSONArray(key) and getJSONObject(key) in order to get nested objects and arrays from inside a JSONObject or JSONArray. RequestQueue Singletons If you are going to make multiple network requests for your application (which you usually will for anything of a reasonable size), it is wasteful to repeatedly instantiate new RequestQueue objects—these can take up significant memory and step on each others toes. Instead, the best practice is to use the Singleton Design Pattern to ensure that your entire application only uses a single RequestQueue. To do this, you will want to create an entire class (e.g., RequestSingleton) that will control access to a single instance of the Volley RequestQueue: public class RequestSingleton { //make static if an inner class! //the single RequestQueue; static so it exists outside of the object private static RequestQueue requestQueue = null; private RequestSingleton(){} //private constructor; cannot instantiate directly //call this &quot;factory&quot; method to access the Volley RequestQueue public static RequestQueue getInstance(Context ctx) { //only create if it doesn&#39;t exist yet if(requestQueue == null){ requestQueue = Volley.newRequestQueue(ctx.getApplicationContext()); } return requestQueue; //return the single object } } This structure will let you make multiple network requests from multiple components of your app, but without trying to have multiple “dispatchers” taking up memory. https://developer.android.com/guide/topics/ui/layout/listview.html↩ https://developer.android.com/reference/android/widget/Adapter.html↩ "],
["java-review.html", "A Java Review A.1 Building Apps with Gradle A.2 Class Basics A.3 Inheritance A.4 Interfaces A.5 Polymorphism A.6 Abstract Methods and Classes A.7 Generics A.8 Nested Classes", " A Java Review Android applications are written primarily in the Java Language. This appendix contains a review of some Java fundamentals needed when developing for Android, presented as a set of practice exercises. The code for these exercises can be found at https://github.com/info448/appendix-java-review. A.1 Building Apps with Gradle Consider the included Dog class found in the src/main/java/edu/info448/review/ folder. This is a very basic class representing a Dog. You can instantiate and call methods on this class by building and running the Tester class found in the same folder. - You can just use any text editor, like VS Code, Atom, or Sublime Text to view and edit these files. You’ve probably run Java programs using an IDE, but let’s consider what is involved in building this app “by hand”, or just using the JDK tools. There are two main steps to running a Java program: Compiling This converts the Java source code (in .java files) into JVM bytecode that can be understood by the virtual machine (in .class) files. Running This actually loads the bytecode into the virtual machine and executes the main() method. Compiling is done with the javac (“java compile”) command. For example, from inside the code repo’s directory, you can compile both the .java files with: # Compile all .java files javac src/main/java/edu/info448/review/*.java Running is then done with the java command: you specify the full package name of the class you wish to run, as well as the classpath so that Java knows where to go find classes it depends on: # Runs the Tester#main() method with the `src/main/java` folder as the classpath java -classpath ./src/main/java edu.info448.review.Tester Practice: Compile and run this application now. Practice: Modify the Dog class so that it’s .bark() method barks twice (&quot;Bark Bark!&quot;). What do you have to do to test that your change worked? You may notice that this development cycle can get pretty tedious: there are two commands we need to execute to run our code, and both are complex enough that they are a pain to retype. Enter Gradle. Gradle is a build automation system: a “script” that you can run that will automatically perform the multiple steps required to build and run an application. This script is defined by the build.gradle configuration file. Practice: open that file and look through its contents. The task run() is where the “run” task is defined: do you see how it defines the same arguments we otherwise passed to the java command? You can run the version of Gradle included in the repo with the gradlew &lt;task&gt; command, specifying what task you want to the build system to perform. For example: # on Mac/Linux ./gradlew tasks # on Windows gradlew tasks Will give you a list of available tasks. Use gradlew classes to compile the code, and gradlew run to compile and run the code. Helpful hint: you can specify the “quite” flag with gradlew -q &lt;task&gt; to not have Gradle output its build status (handy for the run task) Practice: Use gradle to build and run your Dog program. See how much easier that is? We will be using Gradle to build our Android applications (which are much more complex than this simple Java demo)! A.2 Class Basics Now consider the Dog class in more detail. Like all classes, it has two parts: Attributes (a.k.a., instance variables, fields, or member variables). For example, String name. Notice that all of these attributes are private, meaning they are not accessible to members of another class! This is important for encapsulation: it means we can change how the Dog class is implemented without changing any other class that depends on it (for example, if we want to store breed as a number instead of a String). Methods (a.k.a., functions). For example bark() Note the method declaration public void wagTail(int). This combination of access modifier (public), return type (void), method name (wagTail) and parameters (int) is called the method signature: it is the “autograph” of that particular method. When we call a method (e.g., myDog.wagTail(3)), Java will look for a method definition that matches that signature. Method signatures are very important! They tell us what the inputs and outputs of a method will be. We should be able to understand how the method works just from its signature. Notice that one of the methods, .createPuppies() is a static method. This means that the method belongs to the class, not to individual object instances of the class! Practice: try running the following code (by placing it in the main() method of the Tester class): Dog[] pups = Dog.createPuppies(3); System.out.println(Arrays.toString(pups)); Notice that to call the createPuppies() method you didn’t need to have a Dog object (you didn’t need to use the new keyword): instead you went to the “template” for a Dog and told that template to do some work. Non-static methods (ones without the static keyword, also called “instance methods”) need to be called on an object. Practice: Try to run the code Dog.bark(). What happens? This is because you can’t tell the “template” for a Dog to bark, only an actual Dog object! In general, in 98% of cases, your methods should not be static, because you want to call them on a specific object rather than on a general “template” for objects. Variables should never be static, unless they are also final constants (like the BEST_BREED variable). In Android, static variables cause significant memory leaks, as well as just being generally poor design. A.3 Inheritance Practice: Create a new file Husky.java that declares a new Husky class: package edu.info448.review; //package declaration (needed) public class Husky extends Dog { /* class body goes here */ } The extends keyword means that Husky is a subclass of Dog, inheriting all of its methods and attributes. It also means that that a Husky instance is a Dog instance. Practice: In the Tester, instantiate a new Husky and call bark() on it. What happens? Because we’ve inherited from Dog, the Husky class gets all of the methods defined in Dog for free! Try adding a constructor that takes in a single parameter (name) and calls the appropriate super() constructor so that the breed is &quot;Husky&quot;, which makes this a little more sensible. We can also add more methods to the subclass that the parent class doesn’t have. Practice: add a method called .pullSled() to the Husky class. Try calling .pullSled() on your Husky object. What happens? Then try calling .pullSled() on a Dog object. What happens? Finally, we can override methods from the parent class. Practice: add a bark() method to Husky (with the same signature), but that has the Husky “woof” instead of “bark”. Test out your code by calling the method in the Tester. A.4 Interfaces Practice: Create a new file Huggable.java with the following code: package edu.info448.review; public interface Huggable { public void hug(); } This is an example of an interface. An interface is a list of methods that a class promises to provide. By implementing the interface (with the interface keyword in the class declaration), the class promises to include any methods listed in the interface. This is a lot like hanging a sign outside your business that says “Accepts Visa”. It means that if someone comes to you and tries to pay with a Visa card, you’ll be able to do that! Implementing an interface makes no promise about what those methods do, just that the class will include methods with those signatures. Practice: change the Husky class declaration: java public class Husky extends Dog implements Huggable {...} Now the the Husky class needs to have a public void hug() method, but what that method does is up to you! A class can still have a .hug() method even without implementing the Huggable interface (see TeddyBear), but we gain more benefits by announcing that we support that method. Just like how hanging an “Accepts Visa” sign will bring in more people who would be willing to pay with a credit card, rather than just having that option available if someone asks about it. Why not just make Huggable a superclass, and have the Husky extend that? Because Husky extends Dog, and you can only have one parent in Java! And because not all dogs are Huggable, and not all Huggable things are Dogs, there isn’t a clear hierarchy for where to include the interface. In addition, we can implement multiple interfaces (Husky implements Huggable, Pettable), but we can’t inherit from multiple classes This is great for when we have other classes of different types but similar behavior: e.g., a TeddyBear can be Huggable but can’t bark() like a Dog! Practice: Make the class TeddyBear implement Huggable. Do you need to add any new methods? What’s the difference between inheritance and interfaces? The main rule of thumb: use inheritance (extends) when you want classes to share code (implementation). Use interfaces (implements) when you want classes to share behaviors (method signatures). In the end, interfaces are more important for doing good Object-Oriented design. Favor interfaces over inheritance! A.5 Polymorphism Implementing an interface also establishes an is a relationship: so a Husky object is a Huggable object. This allows the greatest benefit of interfaces and inheritance: polymorphism, or the ability to treat one object as the type of another! Consider the standard variable declaration: Dog myDog; //= new Dog(); The variable type of myDog is Dog, which means that variable can refer to any value (object) that is a Dog. Practice: Try the following declarations (note that some will not compile!) Dog v1 = new Husky(); Husky v2 = new Dog(); Huggable v2 = new Husky(); Huggable v3 = new TeddyBear(); Husky v4 = new TeddyBear(); If the value (the thing on the right side) is an instance of the variable type (the type on the left side), then you have a valid declaration. Even if you declare a variable Dog v1 = new Husky(), the value in that object is a Husky. If you call .bark() on it, you’ll get the Husky version of the method (Practice: try overriding the method to print out &quot;barks like a Husky&quot; to see). You can cast between types if you need to convert from one to another. As long as the value is a instance of the type you’re casting to, the operation will work fine. Dog v1 = new Husky(); Husky v2 = (Husky)v1; //legal casting The biggest benefit from polymorphism is abstraction. Consider: ArrayList&lt;Huggable&gt; hugList = new ArrayList&lt;Huggable&gt;(); //a list of huggable things hugList.add(new Husky()); //a Husky is Huggable hugList.add(new TeddyBear()); //so are Teddybears! //enhanced for loop (&quot;foreach&quot; loop) //read: &quot;for each Huggable in the hugList&quot; for(Huggable thing : hugList) { thing.hug(); } Practice: What happens if you run the above code? Because Huskies and Teddy Bears share the same behavior (interface), we can treat them as a single “type”, and so put them both in a list. And because everything in the list supports the Huggable interface, we can call .hug() on each item in the list and we know they’ll have that method—they promised by implementing the interface after all! A.6 Abstract Methods and Classes Take another look at the Huggable interface you created. It contains a single method declaration… followed by a semicolon instead of a method body. This is an abstract method: in fact, you can add the abstract keyword to this method declaration without changing anything (all methods are interfaces are implicitly abstract, so it isn’t required): public abstract void hug(); An abstract method is one that does not (yet) have a method body: it’s just the signature, but no actual implementation. It is “unfinished.” In order to instantiate a class (using the new keyword), that class needs to be “finished” and provide implementations for all abstract methods—e.g., all the ones you’ve inherited from an interface. This is exactly how you’ve used interfaces so far: it’s just another way of thinking about why you need to provide those methods. If the abstract keyword is implied for interfaces, what’s the point? Consider the Animal class (which is a parent class for Dog). The .speak() method is “empty”; in order for it to do anything, the subclass needs to override it. And currently there is nothing to stop someone who is subclassing Animal from forgetting to implement that method! We can force the subclass to override this method by making the method abstract: effectively, leaving it unfinished so that if the subclass (e.g., Dog) wants to do anything, it must finish up the method. Practice: Make the Animal#speak() method abstract. What happens when you try and build the code? If the Animal class contains an unfinished (abstract) method… then that class itself is unfinished, and Java requires us to mark it as such. We do this by declaring the class as abstract in the class declaration : public abstract class MyAbstractClass {...} Practice: Make the Animal class abstract. You will need to provide an implementation of the .speak() method in the Dog class: try just having it call the .bark() method (method composition for-the-win!). Only abstract classes and interfaces can contain abstract methods. In addition, an abstract class is unfinished, meaning it can’t be instantiated. Practice: Try to instantiate a new Animal(). What happens? Abstract classes are great for containing “most” of a class, but making sure that it isn’t used without all the details provided. And if you think about it, we’d never want to ever instantiate a generic Animal anyway—we’d instead make a Dog or a Cat or a Turtle or something. All that the Animal class is doing is acting as an abstraction for these other classes to allow them to share implementations (e.g., of a walk() method). Abstract classes are a bit like “templates” for classes… which are themselves “templates” for objects. A.7 Generics Speaking of templates: think back to the ArrayList class you’ve used in the past, and how you specified the “type” inside that List by using angle brackets (e.g., ArrayList&lt;Dog&gt;). Those angle brackets indicate that ArrayList is a generic class: a template for a class where a data type for that class is itself a variable. Consider the GiftBox class, representing a box containing a TeddyBear. What changes would you need to make to this class so that it contains a Husky instead of a TeddyBear? What about if it contained a String instead? You should notice that the only difference between TeddyGiftBox and HuskyGiftBox and StringGiftBox would be the variable type of the contents. So rather than needing to duplicate work and write the same code for every different type of gift we might want to give… we can use generics. Generics let us specify a data type (e.g., what is currently TeddyBear or String) as a variable, which is set when we instantiate the class using the angle brackets (e.g., new GiftBox&lt;TeddyBear&gt;() would create an object of the class with that type variable set to be TeddyBear). We specify generics by declaring the data type variable in the class declaration: public class GiftBox&lt;T&gt; {...} (T is a common variable name, short for “Type”. Other options include E for Elements in lists, K for Keys and V for Values in maps). And then everywhere you would have put a datatype (e.g., TeddyBear), you can just put the T variable instead. This will be replace by an actual type at compile time. Warning: always use single-letter variable names for generic types! If you try to name it something like String (e.g., public class GiftBox&lt;String&gt;), then Java will interpret the word String to be that variable type, rather than refering to the java.lang.String class. This a lot like declaring a variable int Dog = 448, and then calling Dog.createPuppies(). Practice: Try to make the GiftBox class generic and instantiate a new GiftBox&lt;Husky&gt; A.8 Nested Classes One last piece: we’ve been putting attributes and methods into classes… but we can also define additional classes inside a class! These are called nested or inner classes. We’ll often nest “helper classes” inside a bigger class: for example, you may have put a Node class inside a LinkedList class: public class LinkedList { //nested class public class Node { private int data; public Node(int data) { this.data = data; } } private Node start; public LinkedList() { this.start = new Node(448); } } Or maybe we want to define a Smell class inside the Dog class to represent different smells, allowing us to talk about different Dog.Smell objects. (And of course, the Dog.Smell class would implement the Sniffable interface…) Nested classes we define are usually static: meaning they belong to the class not to object instances of that class. This means that there is only one copy of that nested blueprint class in memory; it’s the equivalent to putting the class in a separate file, but nesting lets us keep them in the same place and provides a “namespacing” function (e.g., Dog.Smell rather than just Smell). Non-static nested classes (or inner classes) on the other hand are defined for each object. This is important only if the behavior of that class is going to depend on the object in which it lives. This is a subtle point that we’ll see as we provide inner classes required by the Android framework. "],
["java-swing.html", "B Java Swing Framework B.1 Events B.2 Layouts and Composites", " B Java Swing Framework Android applications are user-driven graphical applications. In order to become familiar with some of the coding patterns involved in this kind of software, it can be useful to consider how to build simple graphical applications in Java using a different GUI framwork: the Swing library. This appendix references code found at https://github.com/info448/appendix-java-swing. Note that this tutorial involves Java Programming: you can either do this in Android Studio, or just using a light-weight text editor such as Visual Studio Code or Sublime Text. The Swing library is a set of Java classes used to specify graphical user interfaces (GUIs). These classes can be found in the javax.swing package. They also rely on the java.awt package (the “Advanced Windowing Toolkit”), which is an older GUI library that Swing builds on top of. Fun fact: Swing library is named after the dance style: the developers wanted to name it after something hip and cool and popular. In the mid-90s. Let’s look at an incredibly basic GUI class: MyGUI found in the src/main/java/ folder. The class subclasses (extends) JFrame. JFrame represents a “window” in your operating system, and does all the work of making that window show up and interact with the operating system in a normal way. By subclassing JFrame, we get that functionality for free! This is how we build all GUI applications using this framework. Most of the work defining a Swing GUI happens in the JFrame constructor (called when the GUI is “created”). We first call the parent constructor (passing in the title for the window), and then call a method to specify what happens when we hit the “close” button. We then instantiate a JButton, which is a class representing a Java Button. Note that JButton is the Swing version of a button, building off of the older java.awt.Button class. We then .add() this button to the JFrame. This puts the button inside the window. This process is similar to using jQuery to add an HTML element to web page. Finally, we call .pack() to tell the Frame to resize itself to fit the contents, and then .setVisible() to make it actually appear. We run this program from main by just instantiating our specialized JFrame, which will contain the button. You can compile and run this program with ./gradlew -q run. And voila, we have a basic button app! B.1 Events If we click the button… nothing happens. Let’s make it print out a message when clicked. We can do this through event-based programming (if you remember handling click events from JavaScript, this is the same idea). Most computer systems see interactions with its GUI as a series of events: the event of clicking a button, the event of moving the mouse, the event of closing a window, etc. Each thing you interact with generates and emits these events. So when you click on a button, it creates and emits an “I was clicked!” event. (You can think of this like the button shouting “Hey hey! I was pressed!”) We can write code to respond to this shouting to have our application do something when the button is clicked. Events, like everything else in Java, are Objects (of the EventObject type) that are created by the emitter. A JButton in particular emits ActionEvents when pressed (the “action” being that it was pressed). In other words, when buttons are pressed, they shout out ActionEvents. In order to respond to this shouting, we need to “listen” for these events. Then whenever we hear that there is an event happening, we can react to it. This is like a person manning a submarine radar, or hooking up a baby monitor, or following someone on Twitter. But this is Java, and everything in Java is based on Objects, we need an object to listen for these events: a “listener” if you will. Luckily, Java provides a type that can listen for ActionEvents: ActionListener. This type has an actionPerformed() method that can be called in response to an event. We use the Observer Pattern to connect this listener object to the button (button.addActionListener(listener)). This registers the listener, so that the Button knows who to shout at when something happens. (Again, like following someone on Twitter). When the button is pressed, it will go to any listeners registered with it and call their actionPerformed() methods, passing in the ActionEvent it generated. But look carefully: ActionListener is not a concrete class, but an abstract interface. This means if we want to make an ActionListener object, we need to create a class that implements this interface (and provides the actionPerformed() method that can be called when the event occurs). There are a few ways we can do this: We already have a class we’re developing: MyGUI! So we can just make that class implement ActionListener. We’ll fill in the provided method, and then specify that this object is the listener, and voila. This is my favorite way to create listeners in Java (since it keeps everything self-contained: the JFrame handles the events its buttons produce). We’ll utilize a variant of this pattern in Android: we’ll make classes implement listeners, and then “register” that listener somewhere else in the code (often in a nested class). But what if we want to reuse our listener across different classes, but don’t want to have to create a new MyGUI object to listen for a button to be clicked? We can instead use an inner or nested class. For example, create a nested class MyActionListener that implements the interface, and then just instantiate one of those to register with the button. This could be a static nested class, but then it wouldn’t be able to access instance variables (because it belongs to the class, not the object). So you might want to make it an inner class instead. Of course then you can’t re-use it elsewhere without making the MyGUI (whose instance variables it referenes anyway)… but at least we’ve organized the functionality. It seems sort of silly to create a whole new MyActionListener class that has one method and is just going to be instantiated once. So what if instead of giving it a name, we just made it an anonymous class? This is similar to how you’ve made anonymous variables by instantiating objects without assigning them to named variables, you’re just doing the same thing with a class that just implements an interface. The syntax looks like: button.addActionListener(new ActionListener() { //class definition (including methods to override) goes in here! public void actionPerformed(ActionEvent event) { //... } }); This is how buttons are often used in Android: we’ll create an anonymous listener object to respond to the event that occurs when they are pressed. B.2 Layouts and Composites What if we want to add a second button? If we try to just .add() another button… it replaces the one we previously had! This is because Java doesn’t know where to put the second button. Below? Above? Left? Right? In order to have the JFrame contain multiple components, we need to specify a layout, which knows how to organize items that are added to the Frame. We do this with the .setLayout() method. For example, we can give the frame a BoxLayout() with a PAGE_AXIS orientation to have it lay out the buttons in a vertical row. container.setLayout(new BoxLayout(container, BoxLayout.PAGE_AXIS)); container.add(theButton); container.add(otherButton); Java has different LayoutManagers that each have their own way of organizing components. We’ll see this same idea in Android. What if we want to do more complex layouts? We could look for a more complex LayoutManager, but we can actually achieve a lot of flexibility simply by using multiple containers. For example, we can make a JPanel object, which is basically an “empty” component. We can then add multiple buttons to this this panel, and add that panel to the JFrame. Because JPanel is a Component (just like JButton is), we can use the JPanel exactly as we used the JButton—this panel just happens to have multiple buttons. And since we can put any Component in a JPanel, and JPanel is itself a Component… we can create nest these components together into a tree in an example of the Composite Pattern. This allows us to create very complex user interfaces with just a simple BoxLayout! This is similar to how we can create complex web layouts just by nesting lots of &lt;div&gt; elements. "]
]
